{"root":"0:0:1635","crate_version":"1.6.0","includes_private":false,"index":{"0:19":{"id":"0:19","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[632,46],"end":[632,58]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::CaptureNames","name":"CaptureNames","id":"0:2983:1589","glob":false}},"2:13522:59304":{"id":"2:13522:59304","crate_id":2,"name":"strip_suffix","span":null,"visibility":"public","docs":"Returns a string slice with the suffix removed.\n\nIf the string ends with the pattern `suffix`, returns the substring before the suffix,\nwrapped in `Some`.  Unlike `trim_end_matches`, this method removes the suffix exactly once.\n\nIf the string does not end with `suffix`, returns `None`.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\n```\nassert_eq!(\"bar:foo\".strip_suffix(\":foo\"), Some(\"bar\"));\nassert_eq!(\"bar:foo\".strip_suffix(\"bar\"), None);\nassert_eq!(\"foofoo\".strip_suffix(\"foo\"), Some(\"foo\"));\n```","links":{"self::pattern":"2:13053:1578","prim@char":"1:16005:4439"},"attrs":["#[must_use =\n\"this returns the remaining substring as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"str_strip\", since = \"1.45.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["suffix",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:13448:13028":{"id":"2:13448:13028","crate_id":2,"name":"encode_utf16","span":null,"visibility":"public","docs":"Returns an iterator of `u16` over the string encoded as UTF-16.\n\n# Examples\n\nBasic usage:\n\n```\nlet text = \"Zażółć gęślą jaźń\";\n\nlet utf8_len = text.len();\nlet utf16_len = text.encode_utf16().count();\n\nassert!(utf16_len <= utf8_len);\n```","links":{},"attrs":["#[must_use =\n\"this returns the encoded string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"EncodeUtf16","id":"2:49751:4880","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:22837:6533":{"id":"2:22837:6533","crate_id":2,"name":"SimdUint","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:22838:61535","2:22839:1225","2:22840:1226","2:22841:61551","2:22842:61552","2:22843:61553","2:22844:61554","2:22845:62668","2:22846:62669","2:22847:62670"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Copy","id":"2:3278:106","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"2:22850:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:16":{"id":"0:16","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[632,30],"end":[632,44]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::CaptureMatches","name":"CaptureMatches","id":"0:3031:1588","glob":false}},"2:3422:4852":{"id":"2:3422:4852","crate_id":2,"name":"BitAndAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3424:352"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2945:1588":{"id":"0:2945:1588","crate_id":0,"name":"CaptureMatches","span":{"filename":"src/re_trait.rs","begin":[235,0],"end":[238,16]},"visibility":"public","docs":"An iterator over all non-overlapping successive leftmost-first matches with\ncaptures.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'t","kind":{"lifetime":{"outlives":[]}}},{"name":"R","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"R"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"RegularExpression","id":"0:1367:2655","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Text","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"R"},"trait":{"kind":"resolved_path","inner":{"name":"","id":"0:1367:2655","args":null,"param_names":[]}}}},"bounds":[{"outlives":"'t"}],"generic_params":[]}}]},"fields_stripped":true,"fields":[],"impls":[]}},"0:1369:2793":{"id":"0:1369:2793","crate_id":0,"name":"slots_len","span":{"filename":"src/re_trait.rs","begin":[110,4],"end":[110,33]},"visibility":"default","docs":"The number of capture slots in the compiled regular expression. This is\nalways two times the number of capture groups (two slots per group).","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"primitive","inner":"usize"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"2:3174:135":{"id":"2:3174:135","crate_id":2,"name":"From","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3176:681"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:3774:4724":{"id":"2:3774:4724","crate_id":2,"name":"CoerceUnsized","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"T"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[],"implementations":[]}},"0:820:813":{"id":"0:820:813","crate_id":0,"name":"literal","span":{"filename":"src/literal/mod.rs","begin":[1,0],"end":[55,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:821"],"is_stripped":true}},"0:2408:1980":{"id":"0:2408:1980","crate_id":0,"name":"EndLine","span":{"filename":"src/prog.rs","begin":[345,4],"end":[345,11]},"visibility":"default","docs":"End of line or input.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"plain"}},"1:5739:6004":{"id":"1:5739:6004","crate_id":1,"name":"OpenOptionsExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5740:8272","1:5741:9559"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2414:1983":{"id":"0:2414:1983","crate_id":0,"name":"WordBoundary","span":{"filename":"src/prog.rs","begin":[351,4],"end":[351,16]},"visibility":"default","docs":"Word character on one side and non-word character on other.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"plain"}},"1:5789:6007":{"id":"1:5789:6007","crate_id":1,"name":"DirEntryExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5790:60721"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2450:599":{"id":"0:2450:599","crate_id":0,"name":"end","span":{"filename":"src/prog.rs","begin":[426,4],"end":[426,15]},"visibility":"public","docs":"The end (inclusive) of this byte range.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"u8"}},"2:10306:5347":{"id":"2:10306:5347","crate_id":2,"name":"UpperHex","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10307:660"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:3371:4845":{"id":"2:3371:4845","crate_id":2,"name":"SubAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3373:1354"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:3280:220":{"id":"2:3280:220","crate_id":2,"name":"Sync","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":true,"is_unsafe":true,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"5:6105:2053":{"id":"5:6105:2053","crate_id":5,"name":"repeat","span":null,"visibility":"public","docs":"Creates a new [`String`] by repeating a string `n` times.\n\n# Panics\n\nThis function will panic if the capacity would overflow.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n```\n\nA panic upon overflow:\n\n```should_panic\n// this will panic at runtime\nlet huge = \"0123456789abcdef\".repeat(usize::MAX);\n```","links":{"`String`":"5:8368:216"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use]","#[stable(feature = \"repeat_str\", since = \"1.16.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["n",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:9259:3248":{"id":"2:9259:3248","crate_id":2,"name":"RefUnwindSafe","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":true,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13502:63213":{"id":"2:13502:63213","crate_id":2,"name":"rmatch_indices","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within `self`,\nyielded in reverse order along with the index of the match.\n\nFor matches of `pat` within `self` that overlap, only the indices\ncorresponding to the last match are returned.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse\nsearch, and it will be a [`DoubleEndedIterator`] if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`match_indices`] method can be used.\n\n[`match_indices`]: str::match_indices\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\nassert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n\nlet v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\nassert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n\nlet v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\nassert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n```","links":{"self::pattern":"2:13053:1578","prim@char":"1:16005:4439","`DoubleEndedIterator`":"2:8447:120","str::match_indices":"1:16011:4444"},"attrs":["#[stable(feature = \"str_match_indices\", since = \"1.5.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"RMatchIndices","id":"2:49627:4896","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2023:1540":{"id":"0:2023:1540","crate_id":0,"name":"0","span":{"filename":"src/error.rs","begin":[11,19],"end":[11,24]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"2:3309:4909":{"id":"2:3309:4909","crate_id":2,"name":"Unpin","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":true,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1368:2792":{"id":"0:1368:2792","crate_id":0,"name":"Text","span":{"filename":"src/re_trait.rs","begin":[106,4],"end":[106,35]},"visibility":"default","docs":"The type of the haystack.","links":{},"attrs":[],"deprecation":null,"kind":"assoc_type","inner":{"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"fmt::Debug","id":"2:10291:109","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"default":null}},"0:2440:1631":{"id":"0:2440:1631","crate_id":0,"name":"InstRanges","span":{"filename":"src/prog.rs","begin":[372,0],"end":[378,1]},"visibility":"public","docs":"Representation of the Ranges instruction.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":false,"fields":["0:2441:1808","0:2442:1969"],"impls":[]}},"0:543:1624":{"id":"0:543:1624","crate_id":0,"name":"ExecBuilder","span":{"filename":"src/exec.rs","begin":[113,0],"end":[118,1]},"visibility":"public","docs":"Facilitates the construction of an executor by exposing various knobs\nto control how a regex is executed and what kinds of resources it's\npermitted to use.","links":{},"attrs":["#[allow(missing_debug_implementations)]"],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:3558:4864":{"id":"2:3558:4864","crate_id":2,"name":"Generator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3560:237","2:3561:206","2:3562:62690"],"generics":{"params":[{"name":"R","kind":{"type":{"bounds":[],"default":{"kind":"tuple","inner":[]},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:3504:4725":{"id":"2:3504:4725","crate_id":2,"name":"DerefMut","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3505:545"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Deref","id":"2:3491:116","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:2566:1583":{"id":"0:2566:1583","crate_id":0,"name":"set_unicode","span":{"filename":"src/re_builder.rs","begin":[421,0],"end":[421,47]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2594:3557"],"is_stripped":false}},"2:13428:11324":{"id":"2:13428:11324","crate_id":2,"name":"as_mut_ptr","span":null,"visibility":"public","docs":"Converts a mutable string slice to a raw pointer.\n\nAs string slices are a slice of bytes, the raw pointer points to a\n[`u8`]. This pointer will be pointing to the first byte of the string\nslice.\n\nIt is your responsibility to make sure that the string slice only gets\nmodified in a way that it remains valid UTF-8.","links":{"`u8`":"1:16022:4453"},"attrs":["#[stable(feature = \"str_as_mut_ptr\", since = \"1.36.0\")]","#[must_use]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"raw_pointer","inner":{"mutable":true,"type":{"kind":"primitive","inner":"u8"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"1:6963:5989":{"id":"1:6963:5989","crate_id":1,"name":"AsFd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6964:57473"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13462:5380":{"id":"2:13462:5380","crate_id":2,"name":"rfind","span":null,"visibility":"public","docs":"Returns the byte index for the first character of the last match of the pattern in\nthis string slice.\n\nReturns [`None`] if the pattern doesn't match.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nSimple patterns:\n\n```\nlet s = \"Löwe 老虎 Léopard Gepardi\";\n\nassert_eq!(s.rfind('L'), Some(13));\nassert_eq!(s.rfind('é'), Some(14));\nassert_eq!(s.rfind(\"pard\"), Some(24));\n```\n\nMore complex patterns with closures:\n\n```\nlet s = \"Löwe 老虎 Léopard\";\n\nassert_eq!(s.rfind(char::is_whitespace), Some(12));\nassert_eq!(s.rfind(char::is_lowercase), Some(20));\n```\n\nNot finding the pattern:\n\n```\nlet s = \"Löwe 老虎 Léopard\";\nlet x: &[_] = &['1', '2'];\n\nassert_eq!(s.rfind(x), None);\n```","links":{"`None`":"2:47492:176","self::pattern":"2:13053:1578","prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"usize"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:3811:4866":{"id":"2:3811:4866","crate_id":2,"name":"DispatchFromDyn","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2267:3151":{"id":"0:2267:3151","crate_id":0,"name":"Packed","span":{"filename":"src/literal/imp.rs","begin":[227,4],"end":[227,25]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"slice","inner":{"kind":"resolved_path","inner":{"name":"Literal","id":"20:2951:1960","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}}]}},"0:2266:1540":{"id":"0:2266:1540","crate_id":0,"name":"0","span":{"filename":"src/literal/imp.rs","begin":[226,7],"end":[226,20]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"slice","inner":{"kind":"resolved_path","inner":{"name":"Literal","id":"20:2951:1960","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}}},"1:4745:6040":{"id":"1:4745:6040","crate_id":1,"name":"Seek","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:4746:58780","1:4747:42796","1:4748:58781","1:4749:58782"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"1:5651:6096":{"id":"1:5651:6096","crate_id":1,"name":"OsStringExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5652:57036","1:5653:4950"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10569:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:2358:1630":{"id":"0:2358:1630","crate_id":0,"name":"Inst","span":{"filename":"src/prog.rs","begin":[268,0],"end":[296,1]},"visibility":"public","docs":"Inst is an instruction code in a Regex program.\n\nRegrettably, a regex program either contains Unicode codepoint\ninstructions (Char and Ranges) or it contains byte instructions (Bytes).\nA regex program can never contain both.\n\nIt would be worth investigating splitting this into two distinct types and\nthen figuring out how to make the matching engines polymorphic over those\ntypes without sacrificing performance.\n\nOther than the benefit of moving invariants into the type system, another\nbenefit is the decreased size. If we remove the `Char` and `Ranges`\ninstructions from the `Inst` enum, then its size shrinks from 32 bytes to\n24 bytes. (This is because of the removal of a `Box<[]>` in the `Ranges`\nvariant.) Given that byte based machines are typically much bigger than\ntheir Unicode analogues (because they can decode UTF-8 directly), this ends\nup being a pretty significant savings.","links":{},"attrs":[],"deprecation":null,"kind":"enum","inner":{"generics":{"params":[],"where_predicates":[]},"variants_stripped":false,"variants":["0:2359:1592","0:2362:1805","0:2365:1598","0:2368:1629","0:2371:1625","0:2374:1813","0:2377:1814"],"impls":[]}},"0:3049:1597":{"id":"0:3049:1597","crate_id":0,"name":"ReplacerRef","span":{"filename":"src/re_unicode.rs","begin":[1213,0],"end":[1213,49]},"visibility":"public","docs":"By-reference adaptor for a `Replacer`\n\nReturned by [`Replacer::by_ref`](trait.Replacer.html#method.by_ref).","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"R","kind":{"type":{"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"default":null,"synthetic":false}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:2264:3145":{"id":"0:2264:3145","crate_id":0,"name":"AC","span":{"filename":"src/literal/imp.rs","begin":[226,4],"end":[226,21]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"slice","inner":{"kind":"resolved_path","inner":{"name":"Literal","id":"20:2951:1960","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}}]}},"2:13443:1602":{"id":"2:13443:1602","crate_id":2,"name":"bytes","span":null,"visibility":"public","docs":"An iterator over the bytes of a string slice.\n\nAs a string slice consists of a sequence of bytes, we can iterate\nthrough a string slice by byte. This method returns such an iterator.\n\n# Examples\n\nBasic usage:\n\n```\nlet mut bytes = \"bors\".bytes();\n\nassert_eq!(Some(b'b'), bytes.next());\nassert_eq!(Some(b'o'), bytes.next());\nassert_eq!(Some(b'r'), bytes.next());\nassert_eq!(Some(b's'), bytes.next());\n\nassert_eq!(None, bytes.next());\n```","links":{},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"Bytes","id":"2:49445:1814","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2392:1810":{"id":"0:2392:1810","crate_id":0,"name":"goto1","span":{"filename":"src/prog.rs","begin":[323,4],"end":[323,22]},"visibility":"public","docs":"The first instruction to try. A match resulting from following goto1\nhas precedence over a match resulting from following goto2.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"0:2448:1808":{"id":"0:2448:1808","crate_id":0,"name":"goto","span":{"filename":"src/prog.rs","begin":[422,4],"end":[422,21]},"visibility":"public","docs":"The next location to execute in the program if this instruction\nsucceeds.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"2:12500:6717":{"id":"2:12500:6717","crate_id":2,"name":"SlicePattern","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:12501:2027","2:12502:62214"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:2862:97":{"id":"2:2862:97","crate_id":2,"name":"Borrow","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2864:3328"],"generics":{"params":[{"name":"Borrowed","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"Borrowed"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[],"implementations":[]}},"2:13512:63218":{"id":"2:13512:63218","crate_id":2,"name":"trim_right","span":null,"visibility":"public","docs":"Returns a string slice with trailing whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`.\n\n# Text directionality\n\nA string is a sequence of bytes. 'Right' in this context means the last\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _left_ side, not the right.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \" Hello\\tworld\\t\";\n\nassert_eq!(\" Hello\\tworld\", s.trim_right());\n```\n\nDirectionality:\n\n```\nlet s = \"English  \";\nassert!(Some('h') == s.trim_right().chars().rev().next());\n\nlet s = \"עברית  \";\nassert!(Some('ת') == s.trim_right().chars().rev().next());\n```","links":{},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[deprecated(since = \"1.33.0\", note = \"superseded by `trim_end`\", suggestion =\n\"trim_end\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_end`"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:3278:106":{"id":"2:3278:106","crate_id":2,"name":"Copy","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Clone","id":"2:2887:104","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:3521:131":{"id":"2:3521:131","crate_id":2,"name":"FnMut","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3523:377"],"generics":{"params":[{"name":"Args","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"FnOnce","id":"2:3524:132","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Args"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:2371:1625":{"id":"0:2371:1625","crate_id":0,"name":"Char","span":{"filename":"src/prog.rs","begin":[288,4],"end":[288,18]},"visibility":"default","docs":"Char requires the regex program to match the character in InstChar at\nthe current position in the input.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"resolved_path","inner":{"name":"InstChar","id":"0:2433:1831","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}]}},"0:2400:2026":{"id":"0:2400:2026","crate_id":0,"name":"look","span":{"filename":"src/prog.rs","begin":[336,4],"end":[336,23]},"visibility":"public","docs":"The type of zero-width assertion to check.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"EmptyLook","id":"0:2405:1629","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}},"0:173:1622":{"id":"0:173:1622","crate_id":0,"name":"Compiler","span":{"filename":"src/compile.rs","begin":[32,0],"end":[52,1]},"visibility":"public","docs":"A compiler translates a regular expression AST to a sequence of\ninstructions. The sequence of instructions represents an NFA.","links":{},"attrs":["#[allow(missing_debug_implementations)]"],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"1:6561:6101":{"id":"1:6561:6101","crate_id":1,"name":"JoinHandleExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6562:58736","1:6563:58737"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:10241:5339":{"id":"2:10241:5339","crate_id":2,"name":"Write","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10242:1531","2:10243:56971","2:10245:5222"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1342:1584":{"id":"0:1342:1584","crate_id":0,"name":"re_set","span":{"filename":"src/re_set.rs","begin":[1,0],"end":[507,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2713:1557","0:2815:1602"],"is_stripped":true}},"0:2934:1593":{"id":"0:2934:1593","crate_id":0,"name":"Matches","span":{"filename":"src/re_trait.rs","begin":[165,0],"end":[174,1]},"visibility":"public","docs":"An iterator over all non-overlapping successive leftmost-first matches.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'t","kind":{"lifetime":{"outlives":[]}}},{"name":"R","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"R"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"RegularExpression","id":"0:1367:2655","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Text","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"R"},"trait":{"kind":"resolved_path","inner":{"name":"","id":"0:1367:2655","args":null,"param_names":[]}}}},"bounds":[{"outlives":"'t"}],"generic_params":[]}}]},"fields_stripped":true,"fields":[],"impls":[]}},"0:2465:1557":{"id":"0:2465:1557","crate_id":0,"name":"unicode","span":{"filename":"src/re_builder.rs","begin":[14,4],"end":[14,21]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"2:13516:63220":{"id":"2:13516:63220","crate_id":2,"name":"trim_start_matches","span":null,"visibility":"public","docs":"Returns a string slice with all prefixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. `start` in this context means the first\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be left side, and for right-to-left languages like\nArabic or Hebrew, this will be the right side.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(\"11foo1bar11\".trim_start_matches('1'), \"foo1bar11\");\nassert_eq!(\"123foo1bar123\".trim_start_matches(char::is_numeric), \"foo1bar123\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_start_matches(x), \"foo1bar12\");\n```","links":{"prim@char":"1:16005:4439","self::pattern":"2:13053:1578"},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"trim_direction\", since = \"1.30.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2263:1540":{"id":"0:2263:1540","crate_id":0,"name":"0","span":{"filename":"src/literal/imp.rs","begin":[225,11],"end":[225,19]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}}}},"2:13487:63209":{"id":"2:13487:63209","crate_id":2,"name":"split_once","span":null,"visibility":"public","docs":"Splits the string on the first occurrence of the specified delimiter and\nreturns prefix before delimiter and suffix after delimiter.\n\n# Examples\n\n```\nassert_eq!(\"cfg\".split_once('='), None);\nassert_eq!(\"cfg=\".split_once('='), Some((\"cfg\", \"\")));\nassert_eq!(\"cfg=foo\".split_once('='), Some((\"cfg\", \"foo\")));\nassert_eq!(\"cfg=foo=bar\".split_once('='), Some((\"cfg\", \"foo=bar\")));\n```","links":{},"attrs":["#[stable(feature = \"str_split_once\", since = \"1.52.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["delimiter",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"tuple","inner":[{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}}]}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:22748:6509":{"id":"2:22748:6509","crate_id":2,"name":"SimdFloat","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:22749:6424","2:22750:61535","2:22751:1737","2:22752:61536","2:22753:61537","2:22754:45768","2:22755:61538","2:22756:61539","2:22757:61540","2:22758:61541","2:22759:61542","2:22760:61543","2:22761:61544","2:22762:61545","2:22763:13079","2:22764:61546","2:22765:61547","2:22766:12417","2:22767:61548","2:22768:61549","2:22769:61550","2:22770:61551","2:22771:61552","2:22772:61553","2:22773:61554"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Copy","id":"2:3278:106","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"2:22850:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:13528:63222":{"id":"2:13528:63222","crate_id":2,"name":"trim_left_matches","span":null,"visibility":"public","docs":"Returns a string slice with all prefixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. 'Left' in this context means the first\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _right_ side, not the left.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\nassert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n```","links":{"self::pattern":"2:13053:1578","prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[deprecated(since = \"1.33.0\", note = \"superseded by `trim_start_matches`\",\nsuggestion = \"trim_start_matches\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_start_matches`"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:23134:6425":{"id":"2:23134:6425","crate_id":2,"name":"MaskElement","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"SimdElement","id":"2:23771:6421","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"2:23125:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"5:5833:2002":{"id":"5:5833:2002","crate_id":5,"name":"Concat","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["5:5835:181","5:5836:432"],"generics":{"params":[{"name":"Item","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"Item"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[],"implementations":[]}},"2:3171:149":{"id":"2:3171:149","crate_id":2,"name":"Into","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3173:2119"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:3375:4843":{"id":"2:3375:4843","crate_id":2,"name":"MulAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3377:893"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13478:63208":{"id":"2:13478:63208","crate_id":2,"name":"rsplit_terminator","span":null,"visibility":"public","docs":"An iterator over substrings of `self`, separated by characters\nmatched by a pattern and yielded in reverse order.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\nEquivalent to [`split`], except that the trailing substring is\nskipped if empty.\n\n[`split`]: str::split\n\nThis method can be used for string data that is _terminated_,\nrather than _separated_ by a pattern.\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a\nreverse search, and it will be double ended if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`split_terminator`] method can be\nused.\n\n[`split_terminator`]: str::split_terminator\n\n# Examples\n\n```\nlet v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\nassert_eq!(v, [\"B\", \"A\"]);\n\nlet v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\nassert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n\nlet v: Vec<&str> = \"A.B:C.D\".rsplit_terminator(&['.', ':'][..]).collect();\nassert_eq!(v, [\"D\", \"C\", \"B\", \"A\"]);\n```","links":{"prim@char":"1:16005:4439","str::split_terminator":"1:16011:4444","str::split":"1:16011:4444","self::pattern":"2:13053:1578"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"RSplitTerminator","id":"2:49527:4900","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:1729":{"id":"0:1729","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[762,26],"end":[762,30]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::exec::Exec","name":"Exec","id":"0:2032:1623","glob":false}},"1:6794:6019":{"id":"1:6794:6019","crate_id":1,"name":"CommandExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6795:9555"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10569:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:1748":{"id":"0:1748","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[764,4],"end":[764,44]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::literal::LiteralSearcher","name":"LiteralSearcher","id":"0:2226:1628","glob":false}},"2:13766:138":{"id":"2:13766:138","crate_id":2,"name":"Future","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:13767:181","2:13768:1013"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:40":{"id":"0:40","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[633,48],"end":[633,56]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::Replacer","name":"Replacer","id":"0:1641:1596","glob":false}},"2:13435:59268":{"id":"2:13435:59268","crate_id":2,"name":"get_unchecked_mut","span":null,"visibility":"public","docs":"Returns a mutable, unchecked subslice of `str`.\n\nThis is the unchecked alternative to indexing the `str`.\n\n# Safety\n\nCallers of this function are responsible that these preconditions are\nsatisfied:\n\n* The starting index must not exceed the ending index;\n* Indexes must be within bounds of the original slice;\n* Indexes must lie on UTF-8 sequence boundaries.\n\nFailing that, the returned string slice may reference invalid memory or\nviolate the invariants communicated by the `str` type.\n\n# Examples\n\n```\nlet mut v = String::from(\"🗻∈🌏\");\nunsafe {\n    assert_eq!(\"🗻\", v.get_unchecked_mut(0..4));\n    assert_eq!(\"∈\", v.get_unchecked_mut(4..7));\n    assert_eq!(\"🌏\", v.get_unchecked_mut(7..11));\n}\n```","links":{},"attrs":["#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]","#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}],["i",{"kind":"generic","inner":"I"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"qualified_path","inner":{"name":"Output","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"I"},"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:10933:214","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}}}}}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"I"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:10933:214","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":true,"async":false,"abi":"Rust"},"has_body":true}},"2:13419:13077":{"id":"2:13419:13077","crate_id":2,"name":"is_char_boundary","span":null,"visibility":"public","docs":"Checks that `index`-th byte is the first byte in a UTF-8 code point\nsequence or the end of the string.\n\nThe start and end of the string (when `index == self.len()`) are\nconsidered to be boundaries.\n\nReturns `false` if `index` is greater than `self.len()`.\n\n# Examples\n\n```\nlet s = \"Löwe 老虎 Léopard\";\nassert!(s.is_char_boundary(0));\n// start of `老`\nassert!(s.is_char_boundary(6));\nassert!(s.is_char_boundary(s.len()));\n\n// second byte of `ö`\nassert!(!s.is_char_boundary(2));\n\n// third byte of `老`\nassert!(!s.is_char_boundary(8));\n```","links":{},"attrs":["#[must_use]","#[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]","#[rustc_const_unstable(feature = \"const_is_char_boundary\", issue = \"none\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["index",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:1736":{"id":"0:1736","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[763,27],"end":[763,31]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::input::Char","name":"Char","id":"0:2206:1625","glob":false}},"0:743:3098":{"id":"0:743:3098","crate_id":0,"name":"previous_char","span":{"filename":"src/input.rs","begin":[79,4],"end":[79,49]},"visibility":"default","docs":"Return the Unicode character occurring previous to `at`.\n\nIf no such character could be decoded, then `Char` is absent.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["at",{"kind":"resolved_path","inner":{"name":"InputAt","id":"0:2172:1627","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}]],"output":{"kind":"resolved_path","inner":{"name":"Char","id":"0:2206:1625","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"0:2435:1812":{"id":"0:2435:1812","crate_id":0,"name":"c","span":{"filename":"src/prog.rs","begin":[367,4],"end":[367,15]},"visibility":"public","docs":"The character to test.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"char"}},"0:1000:1614":{"id":"0:1000:1614","crate_id":0,"name":"prog","span":{"filename":"src/prog.rs","begin":[1,0],"end":[447,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2340:1632","0:2358:1630","0:2384:1833","0:2391:1834","0:2398:1832","0:2405:1629","0:2433:1831","0:2440:1631","0:2447:1830"],"is_stripped":true}},"0:1761":{"id":"0:1761","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[765,55],"end":[765,62]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::prog::Program","name":"Program","id":"0:2340:1632","glob":false}},"2:13429:1807":{"id":"2:13429:1807","crate_id":2,"name":"get","span":null,"visibility":"public","docs":"Returns a subslice of `str`.\n\nThis is the non-panicking alternative to indexing the `str`. Returns\n[`None`] whenever equivalent indexing operation would panic.\n\n# Examples\n\n```\nlet v = String::from(\"🗻∈🌏\");\n\nassert_eq!(Some(\"🗻\"), v.get(0..4));\n\n// indices not on UTF-8 sequence boundaries\nassert!(v.get(1..).is_none());\nassert!(v.get(..8).is_none());\n\n// out of bounds\nassert!(v.get(..42).is_none());\n```","links":{"`None`":"2:47492:176"},"attrs":["#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]","#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["i",{"kind":"generic","inner":"I"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"qualified_path","inner":{"name":"Output","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"I"},"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:10933:214","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}}}}}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"I"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:10933:214","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2449:1323":{"id":"0:2449:1323","crate_id":0,"name":"start","span":{"filename":"src/prog.rs","begin":[424,4],"end":[424,17]},"visibility":"public","docs":"The start (inclusive) of this byte range.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"u8"}},"2:13539:56936":{"id":"2:13539:56936","crate_id":2,"name":"make_ascii_lowercase","span":null,"visibility":"public","docs":"Converts this string to its ASCII lower case equivalent in-place.\n\nASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\nbut non-ASCII letters are unchanged.\n\nTo return a new lowercased value without modifying the existing one, use\n[`to_ascii_lowercase()`].\n\n[`to_ascii_lowercase()`]: #method.to_ascii_lowercase\n\n# Examples\n\n```\nlet mut s = String::from(\"GRÜßE, JÜRGEN ❤\");\n\ns.make_ascii_lowercase();\n\nassert_eq!(\"grÜße, jÜrgen ❤\", s);\n```","links":{},"attrs":["#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":null,"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:13063:4876":{"id":"2:13063:4876","crate_id":2,"name":"Pattern","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:13065:3152","2:13066:61638","2:13067:61643","2:13068:61639","2:13069:61641","2:13070:61640","2:13071:61642"],"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"5:5837:4879":{"id":"5:5837:4879","crate_id":5,"name":"Join","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["5:5839:181","5:5840:3327"],"generics":{"params":[{"name":"Separator","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:3515:3316":{"id":"2:3515:3316","crate_id":2,"name":"Drop","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3516:578"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"5:783:222":{"id":"5:783:222","crate_id":5,"name":"ToOwned","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["5:784:3779","5:785:2587","5:786:5424"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:2865:4869":{"id":"2:2865:4869","crate_id":2,"name":"BorrowMut","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2867:1779"],"generics":{"params":[{"name":"Borrowed","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"Borrowed"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Borrow","id":"2:2862:97","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Borrowed"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:8601:157":{"id":"2:8601:157","crate_id":2,"name":"Iterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:8602:2027","2:8603:922","2:8604:5383","2:8607:3841","2:8608:495","2:8610:3693","2:8613:5384","2:8614:5385","2:8615:5386","2:8616:5387","2:8618:2992","2:8620:5388","2:8621:5389","2:8623:841","2:8626:5390","2:8633:5391","2:8635:5392","2:8638:1909","2:8639:2085","2:8640:5393","2:8642:5394","2:8644:5395","2:8647:1306","2:8648:2054","2:8649:5396","2:8653:5397","2:8656:5398","2:8657:5399","2:8658:5400","2:8660:3966","2:8661:1913","2:8663:5401","2:8666:5402","2:8668:5403","2:8678:5404","2:8693:5405","2:8695:5406","2:8699:5407","2:8708:5408","2:8711:5409","2:8713:5410","2:8716:276","2:8723:294","2:8730:2518","2:8737:5411","2:8746:5412","2:8756:1014","2:8763:5413","2:8770:2045","2:8771:2043","2:8772:4796","2:8784:4795","2:8791:4794","2:8803:4793","2:8810:2005","2:8811:5414","2:8816:3021","2:8819:2559","2:8822:5415","2:8823:3463","2:8825:5416","2:8827:415","2:8830:5417","2:8833:997","2:8836:5418","2:8839:604","2:8842:5419","2:8845:907","2:8847:826","2:8849:792","2:8851:713","2:8853:696","2:8855:5420","2:8856:5421","2:8864:5422"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:3346:4837":{"id":"2:3346:4837","crate_id":2,"name":"Mul","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3348:181","2:3349:892"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:8":{"id":"0:8","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[629,0],"end":[629,34]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_set::unicode","name":"unicode","id":"0:2713:1557","glob":true}},"0:2018:1984":{"id":"0:2018:1984","crate_id":0,"name":"Syntax","span":{"filename":"src/error.rs","begin":[8,4],"end":[8,18]},"visibility":"default","docs":"A syntax error.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}]}},"0:2032:1623":{"id":"0:2032:1623","crate_id":0,"name":"Exec","span":{"filename":"src/exec.rs","begin":[35,0],"end":[47,1]},"visibility":"public","docs":"`Exec` manages the execution of a regular expression.\n\nIn particular, this manages the various compiled forms of a single regular\nexpression and the choice of which matching engine to use to execute a\nregular expression.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:1370:3824":{"id":"0:1370:3824","crate_id":0,"name":"locations","span":{"filename":"src/re_trait.rs","begin":[113,4],"end":[115,5]},"visibility":"default","docs":"Allocates fresh space for all capturing groups in this regex.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"Locations","id":"0:2917:1591","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:3388:4849":{"id":"2:3388:4849","crate_id":2,"name":"Not","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3389:181","2:3390:952"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2447:1830":{"id":"0:2447:1830","crate_id":0,"name":"InstBytes","span":{"filename":"src/prog.rs","begin":[419,0],"end":[427,1]},"visibility":"public","docs":"Representation of the Bytes instruction.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":false,"fields":["0:2448:1808","0:2449:1323","0:2450:599"],"impls":[]}},"2:13493:1754":{"id":"2:13493:1754","crate_id":2,"name":"matches","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within the given string\nslice.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rmatches`] method can be used.\n\n[`rmatches`]: str::matches\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\nassert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n\nlet v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\nassert_eq!(v, [\"1\", \"2\", \"3\"]);\n```","links":{"self::pattern":"2:13053:1578","`DoubleEndedIterator`":"2:8447:120","str::matches":"1:16011:4444","prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"str_matches\", since = \"1.2.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Matches","id":"2:49663:1593","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:10304:5346":{"id":"2:10304:5346","crate_id":2,"name":"LowerHex","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10305:660"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2364:1540":{"id":"0:2364:1540","crate_id":0,"name":"0","span":{"filename":"src/prog.rs","begin":[279,9],"end":[279,17]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"InstSave","id":"0:2384:1833","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}},"2:3103:6349":{"id":"2:3103:6349","crate_id":2,"name":"FloatToInt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[{"name":"Int","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"2:3102:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"1:6865:5995":{"id":"1:6865:5995","crate_id":1,"name":"FromRawFd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6866:57410"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13542:2585":{"id":"2:13542:2585","crate_id":2,"name":"escape_default","span":null,"visibility":"public","docs":"Return an iterator that escapes each char in `self` with [`char::escape_default`].\n\n# Examples\n\nAs an iterator:\n\n```\nfor c in \"❤\\n!\".escape_default() {\n    print!(\"{c}\");\n}\nprintln!();\n```\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"❤\\n!\".escape_default());\n```\n\n\nBoth are equivalent to:\n\n```\nprintln!(\"\\\\u{{2764}}\\\\n!\");\n```\n\nUsing `to_string`:\n\n```\nassert_eq!(\"❤\\n!\".escape_default().to_string(), \"\\\\u{2764}\\\\n!\");\n```","links":{"`char::escape_default`":"1:16005:4439"},"attrs":["#[must_use =\n\"this returns the escaped string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"str_escape\", since = \"1.34.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"EscapeDefault","id":"2:49767:4708","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2978:1595":{"id":"0:2978:1595","crate_id":0,"name":"Regex","span":{"filename":"src/re_unicode.rs","begin":[136,0],"end":[136,23]},"visibility":"public","docs":"A compiled regular expression for matching Unicode strings.\n\nIt is represented as either a sequence of bytecode instructions (dynamic)\nor as a specialized Rust function (native). It can be used to search, split\nor replace text. All searching is done with an implicit `.*?` at the\nbeginning and end of an expression. To force an expression to match the\nwhole string (or a prefix or a suffix), you must use an anchor like `^` or\n`$` (or `\\A` and `\\z`).\n\nWhile this crate will handle Unicode strings (whether in the regular\nexpression or in the search text), all positions returned are **byte\nindices**. Every byte index is guaranteed to be at a Unicode code point\nboundary.\n\nThe lifetimes `'r` and `'t` in this crate correspond to the lifetime of a\ncompiled regular expression and text to search, respectively.\n\nThe only methods that allocate new strings are the string replacement\nmethods. All other methods (searching and splitting) return borrowed\npointers into the string given.\n\n# Examples\n\nFind the location of a US phone number:\n\n```rust\n# use regex::Regex;\nlet re = Regex::new(\"[0-9]{3}-[0-9]{3}-[0-9]{4}\").unwrap();\nlet mat = re.find(\"phone: 111-222-3333\").unwrap();\nassert_eq!((mat.start(), mat.end()), (7, 19));\n```\n\n# Using the `std::str::pattern` methods with `Regex`\n\n> **Note**: This section requires that this crate is compiled with the\n> `pattern` Cargo feature enabled, which **requires nightly Rust**.\n\nSince `Regex` implements `Pattern`, you can use regexes with methods\ndefined on `&str`. For example, `is_match`, `find`, `find_iter`\nand `split` can be replaced with `str::contains`, `str::find`,\n`str::match_indices` and `str::split`.\n\nHere are some examples:\n\n```rust,ignore\n# use regex::Regex;\nlet re = Regex::new(r\"\\d+\").unwrap();\nlet haystack = \"a111b222c\";\n\nassert!(haystack.contains(&re));\nassert_eq!(haystack.find(&re), Some(1));\nassert_eq!(haystack.match_indices(&re).collect::<Vec<_>>(),\n           vec![(1, \"111\"), (5, \"222\")]);\nassert_eq!(haystack.split(&re).collect::<Vec<_>>(), vec![\"a\", \"b\", \"c\"]);\n```","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:7":{"id":"0:7","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[627,0],"end":[627,38]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_builder::unicode","name":"unicode","id":"0:2502:1557","glob":true}},"0:2456:2730":{"id":"0:2456:2730","crate_id":0,"name":"pats","span":{"filename":"src/re_builder.rs","begin":[5,4],"end":[5,25]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"Vec","id":"5:7780:234","args":{"angle_bracketed":{"args":[{"type":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}}},"2:3367:4841":{"id":"2:3367:4841","crate_id":2,"name":"AddAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3369:266"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:59":{"id":"0:59","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[729,4],"end":[729,36]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::re_set::bytes","name":"bytes","id":"0:2815:1602","glob":true}},"2:3728:224":{"id":"2:3728:224","crate_id":2,"name":"Try","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3729:181","2:3730:4861","2:3731:686","2:3732:369"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"FromResidual","id":"2:3733:137","args":{"angle_bracketed":{"args":[{"type":{"kind":"qualified_path","inner":{"name":"Residual","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"Self"},"trait":{"kind":"resolved_path","inner":{"name":"Try","id":"2:3728:224","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:13449:2415":{"id":"2:13449:2415","crate_id":2,"name":"contains","span":null,"visibility":"public","docs":"Returns `true` if the given pattern matches a sub-slice of\nthis string slice.\n\nReturns `false` if it does not.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nBasic usage:\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.contains(\"nana\"));\nassert!(!bananas.contains(\"apples\"));\n```","links":{"self::pattern":"2:13053:1578","prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"1:6689:6005":{"id":"1:6689:6005","crate_id":1,"name":"MetadataExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6690:58688","1:6691:10428","1:6692:10429","1:6693:10431","1:6694:10430","1:6695:10432","1:6696:10433","1:6697:10435","1:6698:8313","1:6699:10438","1:6700:10439","1:6701:10440","1:6702:10441","1:6703:10442","1:6704:10443","1:6705:10436","1:6706:10437"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:14239:5443":{"id":"2:14239:5443","crate_id":2,"name":"Allocator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":["2:14240:61036","2:14241:61037","2:14242:61038","2:14243:61039","2:14244:61040","2:14245:61041","2:14246:3966"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2348:1872":{"id":"0:2348:1872","crate_id":0,"name":"is_bytes","span":{"filename":"src/prog.rs","begin":[43,4],"end":[43,22]},"visibility":"public","docs":"When true, this program uses byte range instructions instead of Unicode\nrange instructions.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"0:1371:2794":{"id":"0:1371:2794","crate_id":0,"name":"next_after_empty","span":{"filename":"src/re_trait.rs","begin":[122,4],"end":[122,69]},"visibility":"default","docs":"Returns the position of the next character after `i`.\n\nFor example, a haystack with type `&[u8]` probably returns `i+1`,\nwhereas a haystack with type `&str` probably returns `i` plus the\nlength of the next UTF-8 sequence.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["text",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"qualified_path","inner":{"name":"Text","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"Self"},"trait":{"kind":"resolved_path","inner":{"name":"","id":"0:1367:2655","args":null,"param_names":[]}}}}}}],["i",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"primitive","inner":"usize"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"0:438:1581":{"id":"0:438:1581","crate_id":0,"name":"error","span":{"filename":"src/error.rs","begin":[1,0],"end":[71,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2017:127"],"is_stripped":true}},"0:2416:1990":{"id":"0:2416:1990","crate_id":0,"name":"NotWordBoundary","span":{"filename":"src/prog.rs","begin":[353,4],"end":[353,19]},"visibility":"default","docs":"Word character on both sides or non-word character on both sides.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"plain"}},"0:2466:2764":{"id":"0:2466:2764","crate_id":0,"name":"octal","span":{"filename":"src/re_builder.rs","begin":[15,4],"end":[15,19]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"0:2020:1540":{"id":"0:2020:1540","crate_id":0,"name":"0","span":{"filename":"src/error.rs","begin":[8,11],"end":[8,17]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}},"1:5745:6005":{"id":"1:5745:6005","crate_id":1,"name":"MetadataExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5746:10085","1:5747:60721","1:5748:8272","1:5749:60722","1:5750:6295","1:5751:6296","1:5752:60723","1:5753:1302","1:5754:60724","1:5755:60725","1:5756:60726","1:5757:60727","1:5758:60728","1:5759:60729","1:5760:60730","1:5761:60731"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1745":{"id":"0:1745","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[763,51],"end":[763,58]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::input::InputAt","name":"InputAt","id":"0:2172:1627","glob":false}},"0:2455:2654":{"id":"0:2455:2654","crate_id":0,"name":"RegexOptions","span":{"filename":"src/re_builder.rs","begin":[4,0],"end":[16,1]},"visibility":"public","docs":"The set of user configurable options for compiling zero or more regexes.","links":{},"attrs":["#[allow(missing_docs)]"],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":false,"fields":["0:2456:2730","0:2457:1847","0:2458:2153","0:2459:2771","0:2460:2765","0:2461:2766","0:2462:2767","0:2463:2768","0:2464:2769","0:2465:1557","0:2466:2764"],"impls":[]}},"0:2368:1629":{"id":"0:2368:1629","crate_id":0,"name":"EmptyLook","span":{"filename":"src/prog.rs","begin":[285,4],"end":[285,28]},"visibility":"default","docs":"EmptyLook represents a zero-width assertion in a regex program. A\nzero-width assertion does not consume any of the input text.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"resolved_path","inner":{"name":"InstEmptyLook","id":"0:2398:1832","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}]}},"5:6091:63849":{"id":"5:6091:63849","crate_id":5,"name":"to_lowercase","span":null,"visibility":"public","docs":"Returns the lowercase equivalent of this string slice, as a new [`String`].\n\n'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n`Lowercase`.\n\nSince some characters can expand into multiple characters when changing\nthe case, this function returns a [`String`] instead of modifying the\nparameter in-place.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"HELLO\";\n\nassert_eq!(\"hello\", s.to_lowercase());\n```\n\nA tricky example, with sigma:\n\n```\nlet sigma = \"Σ\";\n\nassert_eq!(\"σ\", sigma.to_lowercase());\n\n// but at the end of a word, it's ς, not σ:\nlet odysseus = \"ὈΔΥΣΣΕΎΣ\";\n\nassert_eq!(\"ὀδυσσεύς\", odysseus.to_lowercase());\n```\n\nLanguages without case are not changed:\n\n```\nlet new_year = \"农历新年\";\n\nassert_eq!(new_year, new_year.to_lowercase());\n```","links":{"`String`":"5:8368:216"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n\"this returns the lowercase string as a new String, \\\n                  without modifying the original\"]","#[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2681:1600":{"id":"0:2681:1600","crate_id":0,"name":"SubCaptureMatches","span":{"filename":"src/re_bytes.rs","begin":[1087,0],"end":[1090,1]},"visibility":"public","docs":"An iterator that yields all capturing matches in the order in which they\nappear in the regex.\n\nIf a particular capture group didn't participate in the match, then `None`\nis yielded for that capture. The first match always corresponds to the\noverall match of the regex.\n\nThe lifetime `'c` corresponds to the lifetime of the `Captures` value, and\nthe lifetime `'t` corresponds to the originally matched text.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'c","kind":{"lifetime":{"outlives":[]}}},{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"1:5723:6002":{"id":"1:5723:6002","crate_id":1,"name":"FileExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5724:61366","1:5725:61368","1:5726:61367","1:5727:61369"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1302:3780":{"id":"0:1302:3780","crate_id":0,"name":"replace_append","span":{"filename":"src/re_bytes.rs","begin":[1119,4],"end":[1119,73]},"visibility":"default","docs":"Appends text to `dst` to replace the current match.\n\nThe current match is represented by `caps`, which is guaranteed to\nhave a match at capture group `0`.\n\nFor example, a no-op replacement would be\n`dst.extend(&caps[0])`.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}],["caps",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"resolved_path","inner":{"name":"Captures","id":"0:1243:1590","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}}}}],["dst",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"resolved_path","inner":{"name":"Vec","id":"5:7780:234","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"u8"}}],"bindings":[]}},"param_names":[]}}}}]],"output":null,"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"0:2346:1851":{"id":"0:2346:1851","crate_id":0,"name":"byte_classes","span":{"filename":"src/prog.rs","begin":[38,4],"end":[38,29]},"visibility":"public","docs":"A set of equivalence classes for discriminating bytes in the compiled\nprogram.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"Vec","id":"5:7780:234","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"u8"}}],"bindings":[]}},"param_names":[]}}},"0:2637:1588":{"id":"0:2637:1588","crate_id":0,"name":"CaptureMatches","span":{"filename":"src/re_bytes.rs","begin":[716,0],"end":[718,2]},"visibility":"public","docs":"An iterator that yields all non-overlapping capture groups matching a\nparticular regular expression.\n\nThe iterator stops when no more matches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched byte string.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}},{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:742:3096":{"id":"0:742:3096","crate_id":0,"name":"next_char","span":{"filename":"src/input.rs","begin":[74,4],"end":[74,45]},"visibility":"default","docs":"Return the Unicode character occurring next to `at`.\n\nIf no such character could be decoded, then `Char` is absent.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["at",{"kind":"resolved_path","inner":{"name":"InputAt","id":"0:2172:1627","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}]],"output":{"kind":"resolved_path","inner":{"name":"Char","id":"0:2206:1625","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"0:2434:1808":{"id":"0:2434:1808","crate_id":0,"name":"goto","span":{"filename":"src/prog.rs","begin":[365,4],"end":[365,21]},"visibility":"public","docs":"The next location to execute in the program if this instruction\nsucceeds.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"0:2365:1598":{"id":"0:2365:1598","crate_id":0,"name":"Split","span":{"filename":"src/prog.rs","begin":[282,4],"end":[282,20]},"visibility":"default","docs":"Split causes the program to diverge to one of two paths in the\nprogram, preferring goto1 in InstSplit.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"resolved_path","inner":{"name":"InstSplit","id":"0:2391:1834","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}]}},"0:1243:1590":{"id":"0:1243:1590","crate_id":0,"name":"Captures","span":{"filename":"src/re_bytes.rs","begin":[912,0],"end":[916,1]},"visibility":"public","docs":"Captures represents a group of captured byte strings for a single match.\n\nThe 0th capture always corresponds to the entire match. Each subsequent\nindex corresponds to the next capture group in the regex. If a capture\ngroup is named, then the matched byte string is *also* available via the\n`name` method. (Note that the 0th capture is always unnamed and so must be\naccessed with the `get` method.)\n\nPositions returned from a capture group are always byte indices.\n\n`'t` is the lifetime of the matched text.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:13531:63223":{"id":"2:13531:63223","crate_id":2,"name":"trim_right_matches","span":null,"visibility":"public","docs":"Returns a string slice with all suffixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. 'Right' in this context means the last\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _left_ side, not the right.\n\n# Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n```\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n```","links":{"self::pattern":"2:13053:1578","prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[deprecated(since = \"1.33.0\", note = \"superseded by `trim_end_matches`\",\nsuggestion = \"trim_end_matches\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_end_matches`"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:10300:5344":{"id":"2:10300:5344","crate_id":2,"name":"Octal","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10301:660"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2457:1847":{"id":"0:2457:1847","crate_id":0,"name":"size_limit","span":{"filename":"src/re_builder.rs","begin":[6,4],"end":[6,25]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"0:2993:1598":{"id":"0:2993:1598","crate_id":0,"name":"Split","span":{"filename":"src/re_unicode.rs","begin":[781,0],"end":[784,1]},"visibility":"public","docs":"Yields all substrings delimited by a regular expression match.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the string being split.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}},{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:3002:1599":{"id":"0:3002:1599","crate_id":0,"name":"SplitN","span":{"filename":"src/re_unicode.rs","begin":[819,0],"end":[822,1]},"visibility":"public","docs":"Yields at most `N` substrings delimited by a regular expression match.\n\nThe last substring will be whatever remains after splitting.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the string being split.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}},{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:2374:1813":{"id":"0:2374:1813","crate_id":0,"name":"Ranges","span":{"filename":"src/prog.rs","begin":[291,4],"end":[291,22]},"visibility":"default","docs":"Ranges requires the regex program to match the character at the current\nposition in the input with one of the ranges specified in InstRanges.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"resolved_path","inner":{"name":"InstRanges","id":"0:2440:1631","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}]}},"0:3058:1594":{"id":"0:3058:1594","crate_id":0,"name":"NoExpand","span":{"filename":"src/re_unicode.rs","begin":[1301,0],"end":[1301,37]},"visibility":"public","docs":"`NoExpand` indicates literal string replacement.\n\nIt can be used with `replace` and `replace_all` to do a literal string\nreplacement without expanding `$name` to their corresponding capture\ngroups. This can be both convenient (to avoid escaping `$`, for example)\nand performant (since capture groups don't need to be found).\n\n`'t` is the lifetime of the literal text.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":false,"fields":["0:3061:1540"],"impls":[]}},"2:3426:4853":{"id":"2:3426:4853","crate_id":2,"name":"BitOrAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3428:354"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2342:1754":{"id":"0:2342:1754","crate_id":0,"name":"matches","span":{"filename":"src/prog.rs","begin":[24,4],"end":[24,29]},"visibility":"public","docs":"Pointers to each Match instruction in the sequence.\n\nThis is always length 1 unless this program represents a regex set.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"Vec","id":"5:7780:234","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"usize"}}],"bindings":[]}},"param_names":[]}}},"0:57":{"id":"0:57","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[727,4],"end":[727,44]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::re_builder::set_bytes","name":"set_bytes","id":"0:2533:1603","glob":true}},"0:2599:1592":{"id":"0:2599:1592","crate_id":0,"name":"Match","span":{"filename":"src/re_bytes.rs","begin":[21,0],"end":[25,1]},"visibility":"public","docs":"Match represents a single match of a regex in a haystack.\n\nThe lifetime parameter `'t` refers to the lifetime of the matched text.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:13427:304":{"id":"2:13427:304","crate_id":2,"name":"as_ptr","span":null,"visibility":"public","docs":"Converts a string slice to a raw pointer.\n\nAs string slices are a slice of bytes, the raw pointer points to a\n[`u8`]. This pointer will be pointing to the first byte of the string\nslice.\n\nThe caller must ensure that the returned pointer is never written to.\nIf you need to mutate the contents of the string slice, use [`as_mut_ptr`].\n\n[`as_mut_ptr`]: str::as_mut_ptr\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"Hello\";\nlet ptr = s.as_ptr();\n```","links":{"`u8`":"1:16022:4453","str::as_mut_ptr":"1:16011:4444"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_const_stable(feature = \"rustc_str_as_ptr\", since = \"1.32.0\")]","#[must_use]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"raw_pointer","inner":{"mutable":false,"type":{"kind":"primitive","inner":"u8"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":true,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:13525:63221":{"id":"2:13525:63221","crate_id":2,"name":"trim_end_matches","span":null,"visibility":"public","docs":"Returns a string slice with all suffixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. `end` in this context means the last\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be right side, and for right-to-left languages like\nArabic or Hebrew, this will be the left side.\n\n# Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_end_matches('1'), \"11foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_end_matches(char::is_numeric), \"123foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_end_matches(x), \"12foo1bar\");\n```\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1fooX\".trim_end_matches(|c| c == '1' || c == 'X'), \"1foo\");\n```","links":{"prim@char":"1:16005:4439","self::pattern":"2:13053:1578"},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"trim_direction\", since = \"1.30.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2405:1629":{"id":"0:2405:1629","crate_id":0,"name":"EmptyLook","span":{"filename":"src/prog.rs","begin":[341,0],"end":[358,1]},"visibility":"public","docs":"The set of zero-width match instructions.","links":{},"attrs":[],"deprecation":null,"kind":"enum","inner":{"generics":{"params":[],"where_predicates":[]},"variants_stripped":false,"variants":["0:2406:1976","0:2408:1980","0:2410:1981","0:2412:1982","0:2414:1983","0:2416:1990","0:2418:1992","0:2420:1994"],"impls":[]}},"2:8879:3563":{"id":"2:8879:3563","crate_id":2,"name":"FusedIterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Iterator","id":"2:8601:157","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:1732":{"id":"0:1732","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[762,32],"end":[762,43]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::exec::ExecBuilder","name":"ExecBuilder","id":"0:543:1624","glob":false}},"2:3181:227":{"id":"2:3181:227","crate_id":2,"name":"TryFrom","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3183:127","2:3184:1414"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2399:1808":{"id":"0:2399:1808","crate_id":0,"name":"goto","span":{"filename":"src/prog.rs","begin":[334,4],"end":[334,21]},"visibility":"public","docs":"The next location to execute in the program if this instruction\nsucceeds.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"5:6104:63851":{"id":"5:6104:63851","crate_id":5,"name":"into_string","span":null,"visibility":"public","docs":"Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n\n# Examples\n\nBasic usage:\n\n```\nlet string = String::from(\"birthday gift\");\nlet boxed_str = string.clone().into_boxed_str();\n\nassert_eq!(boxed_str.into_string(), string);\n```","links":{"`Box<str>`":"5:432:2019","`String`":"5:8368:216"},"attrs":["#[stable(feature = \"box_str\", since = \"1.4.0\")]","#[must_use = \"`self` will be dropped if the result is not used\"]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"resolved_path","inner":{"name":"Box","id":"5:432:2019","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}},{"type":{"kind":"resolved_path","inner":{"name":"Global","id":"5:8106:5444","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:740:148":{"id":"0:740:148","crate_id":0,"name":"Input","span":{"filename":"src/input.rs","begin":[67,0],"end":[102,1]},"visibility":"public","docs":"An abstraction over input used in the matching engines.","links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["0:741:1771","0:742:3096","0:743:3098","0:744:1811","0:745:1797","0:746:793","0:747:1796","0:748:2795"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"fmt::Debug","id":"2:10291:109","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:13078:4877":{"id":"2:13078:4877","crate_id":2,"name":"ReverseSearcher","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":["2:13080:4130","2:13081:62592","2:13082:62593"],"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Searcher","id":"2:13072:3152","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:1404:1585":{"id":"0:1404:1585","crate_id":0,"name":"re_unicode","span":{"filename":"src/re_unicode.rs","begin":[1,0],"end":[1311,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:1459:1586","0:2954:1592","0:2978:1595","0:2983:1589","0:2993:1598","0:3002:1599","0:3011:1587","0:1565:1590","0:3018:1600","0:3031:1588","0:3040:1593","0:1641:1596","0:3049:1597","0:3058:1594"],"is_stripped":true}},"1:4670:6018":{"id":"1:4670:6018","crate_id":1,"name":"Read","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:4671:6234","1:4672:57071","1:4674:57072","1:4675:57073","1:4676:6037","1:4677:12640","1:4678:12639","1:4680:57074","1:4681:3966","1:4682:1602","1:4683:5387","1:4685:2054"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1752":{"id":"0:1752","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[765,26],"end":[765,35]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::prog::EmptyLook","name":"EmptyLook","id":"0:2405:1629","glob":false}},"2:10312:5349":{"id":"2:10312:5349","crate_id":2,"name":"UpperExp","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10313:660"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"5:6084:63848":{"id":"5:6084:63848","crate_id":5,"name":"into_boxed_bytes","span":null,"visibility":"public","docs":"Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"this is a string\";\nlet boxed_str = s.to_owned().into_boxed_str();\nlet boxed_bytes = boxed_str.into_boxed_bytes();\nassert_eq!(*boxed_bytes, *s.as_bytes());\n```","links":{},"attrs":["#[stable(feature = \"str_box_extras\", since = \"1.20.0\")]","#[must_use = \"`self` will be dropped if the result is not used\"]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"resolved_path","inner":{"name":"Box","id":"5:432:2019","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}},{"type":{"kind":"resolved_path","inner":{"name":"Global","id":"5:8106:5444","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}}]],"output":{"kind":"resolved_path","inner":{"name":"Box","id":"5:432:2019","args":{"angle_bracketed":{"args":[{"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}},{"type":{"kind":"resolved_path","inner":{"name":"Global","id":"5:8106:5444","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2021:2068":{"id":"0:2021:2068","crate_id":0,"name":"CompiledTooBig","span":{"filename":"src/error.rs","begin":[11,4],"end":[11,25]},"visibility":"default","docs":"The compiled program exceeded the set size limit.\nThe argument is the size limit imposed.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"primitive","inner":"usize"}]}},"0:822:2898":{"id":"0:822:2898","crate_id":0,"name":"imp","span":{"filename":"src/literal/imp.rs","begin":[1,0],"end":[402,1]},"visibility":{"restricted":{"parent":"0:820:813","path":"::literal"}},"docs":null,"links":{},"attrs":["#[cfg(feature = \"perf-literal\")]"],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2226:1628","0:2254:3169","0:2282:3137"],"is_stripped":true}},"0:2377:1814":{"id":"0:2377:1814","crate_id":0,"name":"Bytes","span":{"filename":"src/prog.rs","begin":[295,4],"end":[295,20]},"visibility":"default","docs":"Bytes is like Ranges, except it expresses a single byte range. It is\nused in conjunction with Split instructions to implement multi-byte\ncharacter classes.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"resolved_path","inner":{"name":"InstBytes","id":"0:2447:1830","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}]}},"0:2471:1602":{"id":"0:2471:1602","crate_id":0,"name":"bytes","span":{"filename":"src/re_builder.rs","begin":[231,0],"end":[231,39]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2497:3477"],"is_stripped":false}},"2:13538:56935":{"id":"2:13538:56935","crate_id":2,"name":"make_ascii_uppercase","span":null,"visibility":"public","docs":"Converts this string to its ASCII upper case equivalent in-place.\n\nASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\nbut non-ASCII letters are unchanged.\n\nTo return a new uppercased value without modifying the existing one, use\n[`to_ascii_uppercase()`].\n\n[`to_ascii_uppercase()`]: #method.to_ascii_uppercase\n\n# Examples\n\n```\nlet mut s = String::from(\"Grüße, Jürgen ❤\");\n\ns.make_ascii_uppercase();\n\nassert_eq!(\"GRüßE, JüRGEN ❤\", s);\n```","links":{},"attrs":["#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":null,"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2373:1540":{"id":"0:2373:1540","crate_id":0,"name":"0","span":{"filename":"src/prog.rs","begin":[288,9],"end":[288,17]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"InstChar","id":"0:2433:1831","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}},"0:3":{"id":"0:3","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[623,0],"end":[623,28]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::error::Error","name":"Error","id":"0:2017:127","glob":false}},"0:2350:1887":{"id":"0:2350:1887","crate_id":0,"name":"is_reverse","span":{"filename":"src/prog.rs","begin":[50,4],"end":[50,24]},"visibility":"public","docs":"When true, the program matches text in reverse (for use only in the\nDFA).","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"0:2258:1814":{"id":"0:2258:1814","crate_id":0,"name":"Bytes","span":{"filename":"src/literal/imp.rs","begin":[224,4],"end":[224,19]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}}}]}},"0:2355:2153":{"id":"0:2355:2153","crate_id":0,"name":"dfa_size_limit","span":{"filename":"src/prog.rs","begin":[74,4],"end":[74,29]},"visibility":"public","docs":"A limit on the size of the cache that the DFA is allowed to use while\nmatching.\n\nThe cache limit specifies approximately how much space we're willing to\ngive to the state cache. Once the state cache exceeds the size, it is\nwiped and all states must be re-computed.\n\nNote that this value does not impact correctness. It can be set to 0\nand the DFA will run just fine. (It will only ever store exactly one\nstate in the cache, and will likely run very slowly, but it will work.)\n\nAlso note that this limit is *per thread of execution*. That is,\nif the same regex is used to search text across multiple threads\nsimultaneously, then the DFA cache is not shared. Instead, copies are\nmade.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"0:13":{"id":"0:13","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[632,12],"end":[632,28]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::CaptureLocations","name":"CaptureLocations","id":"0:3011:1587","glob":false}},"2:13469:13287":{"id":"2:13469:13287","crate_id":2,"name":"split_inclusive","span":null,"visibility":"public","docs":"An iterator over substrings of this string slice, separated by\ncharacters matched by a pattern. Differs from the iterator produced by\n`split` in that `split_inclusive` leaves the matched part as the\nterminator of the substring.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\"\n    .split_inclusive('\\n').collect();\nassert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\"]);\n```\n\nIf the last element of the string is matched,\nthat element will be considered the terminator of the preceding substring.\nThat substring will be the last item returned by the iterator.\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\\n\"\n    .split_inclusive('\\n').collect();\nassert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\\n\"]);\n```","links":{"self::pattern":"2:13053:1578","prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"SplitInclusive","id":"2:12845:4882","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2460:2765":{"id":"0:2460:2765","crate_id":0,"name":"case_insensitive","span":{"filename":"src/re_builder.rs","begin":[9,4],"end":[9,30]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"2:13458:2518":{"id":"2:13458:2518","crate_id":2,"name":"find","span":null,"visibility":"public","docs":"Returns the byte index of the first character of this string slice that\nmatches the pattern.\n\nReturns [`None`] if the pattern doesn't match.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nSimple patterns:\n\n```\nlet s = \"Löwe 老虎 Léopard Gepardi\";\n\nassert_eq!(s.find('L'), Some(0));\nassert_eq!(s.find('é'), Some(14));\nassert_eq!(s.find(\"pard\"), Some(17));\n```\n\nMore complex patterns using point-free style and closures:\n\n```\nlet s = \"Löwe 老虎 Léopard\";\n\nassert_eq!(s.find(char::is_whitespace), Some(5));\nassert_eq!(s.find(char::is_lowercase), Some(1));\nassert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\nassert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));\n```\n\nNot finding the pattern:\n\n```\nlet s = \"Löwe 老虎 Léopard\";\nlet x: &[_] = &['1', '2'];\n\nassert_eq!(s.find(x), None);\n```","links":{"`None`":"2:47492:176","prim@char":"1:16005:4439","self::pattern":"2:13053:1578"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"usize"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"1:4727:5339":{"id":"1:4727:5339","crate_id":1,"name":"Write","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:4728:2634","1:4729:60604","1:4731:60605","1:4732:6923","1:4733:60603","1:4734:12728","1:4735:5222","1:4744:3966"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"5:6106:56932":{"id":"5:6106:56932","crate_id":5,"name":"to_ascii_uppercase","span":null,"visibility":"public","docs":"Returns a copy of this string where each character is mapped to its\nASCII upper case equivalent.\n\nASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\nbut non-ASCII letters are unchanged.\n\nTo uppercase the value in-place, use [`make_ascii_uppercase`].\n\nTo uppercase ASCII characters in addition to non-ASCII characters, use\n[`to_uppercase`].\n\n# Examples\n\n```\nlet s = \"Grüße, Jürgen ❤\";\n\nassert_eq!(\"GRüßE, JüRGEN ❤\", s.to_ascii_uppercase());\n```\n\n[`make_ascii_uppercase`]: str::make_ascii_uppercase\n[`to_uppercase`]: #method.to_uppercase","links":{"str::make_ascii_uppercase":"1:16011:4444"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use = \"to uppercase the value in-place, use `make_ascii_uppercase()`\"]","#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2376:1540":{"id":"0:2376:1540","crate_id":0,"name":"0","span":{"filename":"src/prog.rs","begin":[291,11],"end":[291,21]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"InstRanges","id":"0:2440:1631","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}},"0:2393:1809":{"id":"0:2393:1809","crate_id":0,"name":"goto2","span":{"filename":"src/prog.rs","begin":[326,4],"end":[326,22]},"visibility":"public","docs":"The second instruction to try. A match resulting from following goto1\nhas precedence over a match resulting from following goto2.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"0:2561:3557":{"id":"0:2561:3557","crate_id":0,"name":"RegexSetBuilder","span":{"filename":"src/re_builder.rs","begin":[420,0],"end":[420,44]},"visibility":"public","docs":"A configurable builder for a set of regular expressions.\n\nA builder can be used to configure how the regexes are built, for example,\nby setting the default flags (which can be overridden in the expression\nitself) or setting various limits.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:3363:4838":{"id":"2:3363:4838","crate_id":2,"name":"Neg","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3364:181","2:3365:913"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1642:3780":{"id":"0:1642:3780","crate_id":0,"name":"replace_append","span":{"filename":"src/re_unicode.rs","begin":[1170,4],"end":[1170,72]},"visibility":"default","docs":"Appends text to `dst` to replace the current match.\n\nThe current match is represented by `caps`, which is guaranteed to\nhave a match at capture group `0`.\n\nFor example, a no-op replacement would be\n`dst.push_str(caps.get(0).unwrap().as_str())`.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}],["caps",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"resolved_path","inner":{"name":"Captures","id":"0:1565:1590","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}}}}],["dst",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}]],"output":null,"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"0:2391:1834":{"id":"0:2391:1834","crate_id":0,"name":"InstSplit","span":{"filename":"src/prog.rs","begin":[320,0],"end":[327,1]},"visibility":"public","docs":"Representation of the Split instruction.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":false,"fields":["0:2392:1810","0:2393:1809"],"impls":[]}},"2:2887:104":{"id":"2:2887:104","crate_id":2,"name":"Clone","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2888:408","2:2889:410"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:31":{"id":"0:31","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[633,22],"end":[633,29]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::Matches","name":"Matches","id":"0:3040:1593","glob":false}},"2:10291:109":{"id":"2:10291:109","crate_id":2,"name":"Debug","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10292:660"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2347:1876":{"id":"0:2347:1876","crate_id":0,"name":"only_utf8","span":{"filename":"src/prog.rs","begin":[40,4],"end":[40,23]},"visibility":"public","docs":"When true, this program can only match valid UTF-8.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"1:9347:6073":{"id":"1:9347:6073","crate_id":1,"name":"StdFloat","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:9348:59080","1:9349:59081","1:9350:59082","1:9351:59083","1:9352:59084","1:9353:42407","1:9354:59079"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10569:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:2254:3169":{"id":"0:2254:3169","crate_id":0,"name":"LiteralIter","span":{"filename":"src/literal/imp.rs","begin":[222,0],"end":[228,1]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"enum","inner":{"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"variants_stripped":false,"variants":["0:2256:1958","0:2258:1814","0:2261:3170","0:2264:3145","0:2267:3151"],"impls":[]}},"0:2370:1540":{"id":"0:2370:1540","crate_id":0,"name":"0","span":{"filename":"src/prog.rs","begin":[285,14],"end":[285,27]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"InstEmptyLook","id":"0:2398:1832","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}},"2:8886:4659":{"id":"2:8886:4659","crate_id":2,"name":"TrustedStep","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Step","id":"2:7927:4647","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:1367:2655":{"id":"0:1367:2655","crate_id":0,"name":"RegularExpression","span":{"filename":"src/re_trait.rs","begin":[104,0],"end":[161,1]},"visibility":"public","docs":"`RegularExpression` describes types that can implement regex searching.\n\nThis trait is my attempt at reducing code duplication and to standardize\nthe internal API. Specific duplication that is avoided are the `find`\nand `capture` iterators, which are slightly tricky.\n\nIt's not clear whether this trait is worth it, and it also isn't\nclear whether it's useful as a public trait or not. Methods like\n`next_after_empty` reak of bad design, but the rest of the methods seem\nsomewhat reasonable. One particular thing this trait would expose would be\nthe ability to start the search of a regex anywhere in a haystack, which\nisn't possible in the current public API.","links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["0:1368:2792","0:1369:2793","0:1370:3824","0:1371:2794","0:1372:2796","0:1373:2797","0:1374:2798","0:1375:2799","0:1376:3625","0:1377:3682"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"fmt::Debug","id":"2:10291:109","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:37":{"id":"0:37","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[633,41],"end":[633,46]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::Regex","name":"Regex","id":"0:2978:1595","glob":false}},"0:2805:4123":{"id":"0:2805:4123","crate_id":0,"name":"SetMatchesIter","span":{"filename":"src/re_set.rs","begin":[451,0],"end":[478,1]},"visibility":"public","docs":"A borrowed iterator over the set of matches from a regex set.\n\nThe lifetime `'a` refers to the lifetime of a `SetMatches` value.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"21:1184:4758":{"id":"21:1184:4758","crate_id":21,"name":"StateID","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["21:1185:689","21:1186:64752","21:1187:64753"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"21:1178:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Clone","id":"2:2887:104","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Copy","id":"2:3278:106","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Debug","id":"2:10291:109","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Eq","id":"2:2925:124","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Hash","id":"2:10529:142","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"PartialEq","id":"2:2920:183","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"PartialOrd","id":"2:2966:184","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Ord","id":"2:2956:177","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:2646:1598":{"id":"0:2646:1598","crate_id":0,"name":"Split","span":{"filename":"src/re_bytes.rs","begin":[739,0],"end":[742,1]},"visibility":"public","docs":"Yields all substrings delimited by a regular expression match.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the byte string being split.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}},{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:1376:3625":{"id":"0:1376:3625","crate_id":0,"name":"find_iter","span":{"filename":"src/re_trait.rs","begin":[152,4],"end":[154,5]},"visibility":"default","docs":"Returns an iterator over all non-overlapping successive leftmost-first\nmatches.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"generic","inner":"Self"}],["text",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"qualified_path","inner":{"name":"Text","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"Self"},"trait":{"kind":"resolved_path","inner":{"name":"","id":"0:1367:2655","args":null,"param_names":[]}}}}}}]],"output":{"kind":"resolved_path","inner":{"name":"Matches","id":"0:2934:1593","args":{"angle_bracketed":{"args":[{"lifetime":"'_"},{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:6":{"id":"0:6","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[625,0],"end":[625,42]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_builder::set_unicode","name":"set_unicode","id":"0:2566:1583","glob":true}},"2:3395:4846":{"id":"2:3395:4846","crate_id":2,"name":"BitAnd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3397:181","2:3398:351"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2461:2766":{"id":"0:2461:2766","crate_id":0,"name":"multi_line","span":{"filename":"src/re_builder.rs","begin":[10,4],"end":[10,24]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"2:13534:2760":{"id":"2:13534:2760","crate_id":2,"name":"parse","span":null,"visibility":"public","docs":"Parses this string slice into another type.\n\nBecause `parse` is so general, it can cause problems with type\ninference. As such, `parse` is one of the few times you'll see\nthe syntax affectionately known as the 'turbofish': `::<>`. This\nhelps the inference algorithm understand specifically which type\nyou're trying to parse into.\n\n`parse` can parse into any type that implements the [`FromStr`] trait.\n\n# Errors\n\nWill return [`Err`] if it's not possible to parse this string slice into\nthe desired type.\n\n[`Err`]: FromStr::Err\n\n# Examples\n\nBasic usage\n\n```\nlet four: u32 = \"4\".parse().unwrap();\n\nassert_eq!(4, four);\n```\n\nUsing the 'turbofish' instead of annotating `four`:\n\n```\nlet four = \"4\".parse::<u32>();\n\nassert_eq!(Ok(4), four);\n```\n\nFailing to parse:\n\n```\nlet nope = \"j\".parse::<u32>();\n\nassert!(nope.is_err());\n```","links":{"`FromStr`":"2:12992:3565","FromStr::Err":"2:12992:3565"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"Result","id":"2:47619:205","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"F"}},{"type":{"kind":"qualified_path","inner":{"name":"Err","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"F"},"trait":{"kind":"resolved_path","inner":{"name":"FromStr","id":"2:12992:3565","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"F","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"F"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"FromStr","id":"2:12992:3565","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:3040:1593":{"id":"0:3040:1593","crate_id":0,"name":"Matches","span":{"filename":"src/re_unicode.rs","begin":[1143,0],"end":[1143,69]},"visibility":"public","docs":"An iterator over all non-overlapping matches for a particular string.\n\nThe iterator yields a `Match` value. The iterator stops when no more\nmatches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched string.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}},{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:2384:1833":{"id":"0:2384:1833","crate_id":0,"name":"InstSave","span":{"filename":"src/prog.rs","begin":[310,0],"end":[316,1]},"visibility":"public","docs":"Representation of the Save instruction.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":false,"fields":["0:2385:1808","0:2386:1773"],"impls":[]}},"2:3379:4842":{"id":"2:3379:4842","crate_id":2,"name":"DivAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3381:559"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13452:59302":{"id":"2:13452:59302","crate_id":2,"name":"starts_with","span":null,"visibility":"public","docs":"Returns `true` if the given pattern matches a prefix of this\nstring slice.\n\nReturns `false` if it does not.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nBasic usage:\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.starts_with(\"bana\"));\nassert!(!bananas.starts_with(\"nana\"));\n```","links":{"self::pattern":"2:13053:1578","prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:13439:59287":{"id":"2:13439:59287","crate_id":2,"name":"split_at","span":null,"visibility":"public","docs":"Divide one string slice into two at an index.\n\nThe argument, `mid`, should be a byte offset from the start of the\nstring. It must also be on the boundary of a UTF-8 code point.\n\nThe two slices returned go from the start of the string slice to `mid`,\nand from `mid` to the end of the string slice.\n\nTo get mutable string slices instead, see the [`split_at_mut`]\nmethod.\n\n[`split_at_mut`]: str::split_at_mut\n\n# Panics\n\nPanics if `mid` is not on a UTF-8 code point boundary, or if it is\npast the end of the last code point of the string slice.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"Per Martin-Löf\";\n\nlet (first, last) = s.split_at(3);\n\nassert_eq!(\"Per\", first);\nassert_eq!(\" Martin-Löf\", last);\n```","links":{"str::split_at_mut":"1:16011:4444"},"attrs":["#[must_use]","#[stable(feature = \"str_split_at\", since = \"1.4.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["mid",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"tuple","inner":[{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}}]},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:8472:3846":{"id":"2:8472:3846","crate_id":2,"name":"ExactSizeIterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:8473:793","2:8474:1796"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Iterator","id":"2:8601:157","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:10":{"id":"0:10","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[632,4],"end":[632,10]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::escape","name":"escape","id":"0:1459:1586","glob":false}},"2:7927:4647":{"id":"2:7927:4647","crate_id":2,"name":"Step","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:7928:62482","2:7929:62483","2:7930:2369","2:7931:62479","2:7932:62484","2:7933:62481","2:7934:62480"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Clone","id":"2:2887:104","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"PartialOrd","id":"2:2966:184","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:22937:6076":{"id":"2:22937:6076","crate_id":2,"name":"SupportedLaneCount","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"2:22927:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"1:1079:4706":{"id":"1:1079:4706","crate_id":1,"name":"AsciiExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:1080:3779","1:1081:2020","1:1082:56932","1:1083:56933","1:1084:56934","1:1085:56935","1:1086:56936"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13505:63214":{"id":"2:13505:63214","crate_id":2,"name":"trim","span":null,"visibility":"public","docs":"Returns a string slice with leading and trailing whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`, which includes newlines.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"\\n Hello\\tworld\\t\\n\";\n\nassert_eq!(\"Hello\\tworld\", s.trim());\n```","links":{},"attrs":["#[must_use =\n\"this returns the trimmed string as a slice, \\\n                  without modifying the original\"]","#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_diagnostic_item = \"str_trim\"]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:13445:13286":{"id":"2:13445:13286","crate_id":2,"name":"split_ascii_whitespace","span":null,"visibility":"public","docs":"Splits a string slice by ASCII whitespace.\n\nThe iterator returned will return string slices that are sub-slices of\nthe original string slice, separated by any amount of ASCII whitespace.\n\nTo split by Unicode `Whitespace` instead, use [`split_whitespace`].\n\n[`split_whitespace`]: str::split_whitespace\n\n# Examples\n\nBasic usage:\n\n```\nlet mut iter = \"A few words\".split_ascii_whitespace();\n\nassert_eq!(Some(\"A\"), iter.next());\nassert_eq!(Some(\"few\"), iter.next());\nassert_eq!(Some(\"words\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\nAll kinds of ASCII whitespace are considered:\n\n```\nlet mut iter = \" Mary   had\\ta little  \\n\\t lamb\".split_ascii_whitespace();\nassert_eq!(Some(\"Mary\"), iter.next());\nassert_eq!(Some(\"had\"), iter.next());\nassert_eq!(Some(\"a\"), iter.next());\nassert_eq!(Some(\"little\"), iter.next());\nassert_eq!(Some(\"lamb\"), iter.next());\n\nassert_eq!(None, iter.next());\n```","links":{"str::split_whitespace":"1:16011:4444"},"attrs":["#[must_use =\n\"this returns the split string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"SplitAsciiWhitespace","id":"2:49742:4881","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:451:1608":{"id":"0:451:1608","crate_id":0,"name":"exec","span":{"filename":"src/exec.rs","begin":[1,0],"end":[1655,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2032:1623","0:2037:2674","0:2044:2678","0:543:1624"],"is_stripped":true}},"0:1372:2796":{"id":"0:1372:2796","crate_id":0,"name":"shortest_match_at","span":{"filename":"src/re_trait.rs","begin":[125,4],"end":[129,23]},"visibility":"default","docs":"Returns the location of the shortest match.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["text",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"qualified_path","inner":{"name":"Text","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"Self"},"trait":{"kind":"resolved_path","inner":{"name":"","id":"0:1367:2655","args":null,"param_names":[]}}}}}}],["start",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"usize"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"2:3716:4859":{"id":"2:3716:4859","crate_id":2,"name":"OneSidedRange","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"T"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"RangeBounds","id":"2:3647:4858","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"T"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:2895:4090":{"id":"0:2895:4090","crate_id":0,"name":"SetMatches","span":{"filename":"src/re_set.rs","begin":[480,0],"end":[507,1]},"visibility":"public","docs":"A set of matches returned by a regex set.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"1:6791:6099":{"id":"1:6791:6099","crate_id":1,"name":"ChildExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6792:57049","1:6793:57050"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10569:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:1739":{"id":"0:1739","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[763,33],"end":[763,42]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::input::CharInput","name":"CharInput","id":"0:2182:1626","glob":false}},"2:13511:63217":{"id":"2:13511:63217","crate_id":2,"name":"trim_left","span":null,"visibility":"public","docs":"Returns a string slice with leading whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`.\n\n# Text directionality\n\nA string is a sequence of bytes. 'Left' in this context means the first\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _right_ side, not the left.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \" Hello\\tworld\\t\";\n\nassert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n```\n\nDirectionality:\n\n```\nlet s = \"  English\";\nassert!(Some('E') == s.trim_left().chars().next());\n\nlet s = \"  עברית\";\nassert!(Some('ע') == s.trim_left().chars().next());\n```","links":{},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[deprecated(since = \"1.33.0\", note = \"superseded by `trim_start`\", suggestion\n= \"trim_start\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_start`"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2037:2674":{"id":"0:2037:2674","crate_id":0,"name":"ExecNoSync","span":{"filename":"src/exec.rs","begin":[53,0],"end":[58,1]},"visibility":"public","docs":"`ExecNoSync` is like `Exec`, except it embeds a reference to a cache. This\nmeans it is no longer Sync, but we can now avoid the overhead of\nsynchronization to fetch the cache.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'c","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:2260:1540":{"id":"0:2260:1540","crate_id":0,"name":"0","span":{"filename":"src/literal/imp.rs","begin":[224,10],"end":[224,18]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}}}},"2:3168:74":{"id":"2:3168:74","crate_id":2,"name":"AsMut","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3170:5375"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"T"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[],"implementations":[]}},"2:3410:4850":{"id":"2:3410:4850","crate_id":2,"name":"Shl","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3412:181","2:3413:1231"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2793:4090":{"id":"0:2793:4090","crate_id":0,"name":"SetMatches","span":{"filename":"src/re_set.rs","begin":[451,0],"end":[478,1]},"visibility":"public","docs":"A set of matches returned by a regex set.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:2800:4124":{"id":"0:2800:4124","crate_id":0,"name":"SetMatchesIntoIter","span":{"filename":"src/re_set.rs","begin":[451,0],"end":[478,1]},"visibility":"public","docs":"An owned iterator over the set of matches from a regex set.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:2623:1595":{"id":"0:2623:1595","crate_id":0,"name":"Regex","span":{"filename":"src/re_bytes.rs","begin":[78,0],"end":[78,23]},"visibility":"public","docs":"A compiled regular expression for matching arbitrary bytes.\n\nIt can be used to search, split or replace text. All searching is done with\nan implicit `.*?` at the beginning and end of an expression. To force an\nexpression to match the whole string (or a prefix or a suffix), you must\nuse an anchor like `^` or `$` (or `\\A` and `\\z`).\n\nLike the `Regex` type in the parent module, matches with this regex return\nbyte offsets into the search text. **Unlike** the parent `Regex` type,\nthese byte offsets may not correspond to UTF-8 sequence boundaries since\nthe regexes in this module can match arbitrary bytes.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:13426:63204":{"id":"2:13426:63204","crate_id":2,"name":"as_bytes_mut","span":null,"visibility":"public","docs":"Converts a mutable string slice to a mutable byte slice.\n\n# Safety\n\nThe caller must ensure that the content of the slice is valid UTF-8\nbefore the borrow ends and the underlying `str` is used.\n\nUse of a `str` whose contents are not valid UTF-8 is undefined behavior.\n\n# Examples\n\nBasic usage:\n\n```\nlet mut s = String::from(\"Hello\");\nlet bytes = unsafe { s.as_bytes_mut() };\n\nassert_eq!(b\"Hello\", bytes);\n```\n\nMutability:\n\n```\nlet mut s = String::from(\"🗻∈🌏\");\n\nunsafe {\n    let bytes = s.as_bytes_mut();\n\n    bytes[0] = 0xF0;\n    bytes[1] = 0x9F;\n    bytes[2] = 0x8D;\n    bytes[3] = 0x94;\n}\n\nassert_eq!(\"🍔∈🌏\", s);\n```","links":{},"attrs":["#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]","#[must_use]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":true,"async":false,"abi":"Rust"},"has_body":true}},"1:6867:5996":{"id":"1:6867:5996","crate_id":1,"name":"IntoRawFd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6868:60796"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2713:1557":{"id":"0:2713:1557","crate_id":0,"name":"unicode","span":{"filename":"src/re_set.rs","begin":[451,0],"end":[478,1]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2788:2908","0:2793:4090","0:2800:4124","0:2805:4123"],"is_stripped":false}},"2:10529:142":{"id":"2:10529:142","crate_id":2,"name":"Hash","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10530:715","2:10532:5531"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:748:2795":{"id":"0:748:2795","crate_id":0,"name":"as_bytes","span":{"filename":"src/input.rs","begin":[101,4],"end":[101,32]},"visibility":"default","docs":"Return the given input as a sequence of bytes.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"0:2410:1981":{"id":"0:2410:1981","crate_id":0,"name":"StartText","span":{"filename":"src/prog.rs","begin":[347,4],"end":[347,13]},"visibility":"default","docs":"Start of input.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"plain"}},"2:13422:63203":{"id":"2:13422:63203","crate_id":2,"name":"ceil_char_boundary","span":null,"visibility":"public","docs":"Finds the closest `x` not below `index` where `is_char_boundary(x)` is `true`.\n\nThis method is the natural complement to [`floor_char_boundary`]. See that method\nfor more details.\n\n[`floor_char_boundary`]: str::floor_char_boundary\n\n# Panics\n\nPanics if `index > self.len()`.\n\n# Examples\n\n```\n#![feature(round_char_boundary)]\nlet s = \"❤️🧡💛💚💙💜\";\nassert_eq!(s.len(), 26);\nassert!(!s.is_char_boundary(13));\n\nlet closest = s.ceil_char_boundary(13);\nassert_eq!(closest, 14);\nassert_eq!(&s[..closest], \"❤️🧡💛\");\n```","links":{"str::floor_char_boundary":"1:16011:4444"},"attrs":["#[unstable(feature = \"round_char_boundary\", issue = \"93743\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["index",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"primitive","inner":"usize"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2703:1594":{"id":"0:2703:1594","crate_id":0,"name":"NoExpand","span":{"filename":"src/re_bytes.rs","begin":[1250,0],"end":[1250,38]},"visibility":"public","docs":"`NoExpand` indicates literal byte string replacement.\n\nIt can be used with `replace` and `replace_all` to do a literal byte string\nreplacement without expanding `$name` to their corresponding capture\ngroups. This can be both convenient (to avoid escaping `$`, for example)\nand performant (since capture groups don't need to be found).\n\n`'t` is the lifetime of the literal text.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":false,"fields":["0:2706:1540"],"impls":[]}},"0:1374:2798":{"id":"0:1374:2798","crate_id":0,"name":"find_at","span":{"filename":"src/re_trait.rs","begin":[135,4],"end":[139,32]},"visibility":"default","docs":"Returns the leftmost-first match location if one exists.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["text",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"qualified_path","inner":{"name":"Text","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"Self"},"trait":{"kind":"resolved_path","inner":{"name":"","id":"0:1367:2655","args":null,"param_names":[]}}}}}}],["start",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"tuple","inner":[{"kind":"primitive","inner":"usize"},{"kind":"primitive","inner":"usize"}]}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"0:43":{"id":"0:43","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[633,58],"end":[633,69]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::ReplacerRef","name":"ReplacerRef","id":"0:3049:1597","glob":false}},"2:13420:63202":{"id":"2:13420:63202","crate_id":2,"name":"floor_char_boundary","span":null,"visibility":"public","docs":"Finds the closest `x` not exceeding `index` where `is_char_boundary(x)` is `true`.\n\nThis method can help you truncate a string so that it's still valid UTF-8, but doesn't\nexceed a given number of bytes. Note that this is done purely at the character level\nand can still visually split graphemes, even though the underlying characters aren't\nsplit. For example, the emoji 🧑‍🔬 (scientist) could be split so that the string only\nincludes 🧑 (person) instead.\n\n# Examples\n\n```\n#![feature(round_char_boundary)]\nlet s = \"❤️🧡💛💚💙💜\";\nassert_eq!(s.len(), 26);\nassert!(!s.is_char_boundary(13));\n\nlet closest = s.floor_char_boundary(13);\nassert_eq!(closest, 10);\nassert_eq!(&s[..closest], \"❤️🧡\");\n```","links":{},"attrs":["#[unstable(feature = \"round_char_boundary\", issue = \"93743\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["index",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"primitive","inner":"usize"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:3351:4836":{"id":"2:3351:4836","crate_id":2,"name":"Div","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3353:181","2:3354:558"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2528:3477":{"id":"0:2528:3477","crate_id":0,"name":"RegexBuilder","span":{"filename":"src/re_builder.rs","begin":[232,0],"end":[232,42]},"visibility":"public","docs":"A configurable builder for a regular expression.\n\nA builder can be used to configure how the regex is built, for example, by\nsetting the default flags (which can be overridden in the expression\nitself) or setting various limits.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:3524:132":{"id":"2:3524:132","crate_id":2,"name":"FnOnce","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3526:181","2:3527:378"],"generics":{"params":[{"name":"Args","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"1:6441:6019":{"id":"1:6441:6019","crate_id":1,"name":"CommandExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6442:6295","1:6443:6296","1:6444:9554","1:6445:61092","1:6447:61095","1:6449:1608","1:6450:61093","1:6452:61094"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10569:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:1377:3682":{"id":"0:1377:3682","crate_id":0,"name":"captures_iter","span":{"filename":"src/re_trait.rs","begin":[158,4],"end":[160,5]},"visibility":"default","docs":"Returns an iterator over all non-overlapping successive leftmost-first\nmatches with captures.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"generic","inner":"Self"}],["text",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"qualified_path","inner":{"name":"Text","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"Self"},"trait":{"kind":"resolved_path","inner":{"name":"","id":"0:1367:2655","args":null,"param_names":[]}}}}}}]],"output":{"kind":"resolved_path","inner":{"name":"CaptureMatches","id":"0:2945:1588","args":{"angle_bracketed":{"args":[{"lifetime":"'_"},{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:3268:211":{"id":"2:3268:211","crate_id":2,"name":"Send","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":true,"is_unsafe":true,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2458:2153":{"id":"0:2458:2153","crate_id":0,"name":"dfa_size_limit","span":{"filename":"src/re_builder.rs","begin":[7,4],"end":[7,29]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"0:0:1635":{"id":"0:0:1635","crate_id":0,"name":"regex","span":{"filename":"src/lib.rs","begin":[1,0],"end":[766,1]},"visibility":"public","docs":"This crate provides a library for parsing, compiling, and executing regular\nexpressions. Its syntax is similar to Perl-style regular expressions, but lacks\na few features like look around and backreferences. In exchange, all searches\nexecute in linear time with respect to the size of the regular expression and\nsearch text.\n\nThis crate's documentation provides some simple examples, describes\n[Unicode support](#unicode) and exhaustively lists the\n[supported syntax](#syntax).\n\nFor more specific details on the API for regular expressions, please see the\ndocumentation for the [`Regex`](struct.Regex.html) type.\n\n# Usage\n\nThis crate is [on crates.io](https://crates.io/crates/regex) and can be\nused by adding `regex` to your dependencies in your project's `Cargo.toml`.\n\n```toml\n[dependencies]\nregex = \"1\"\n```\n\n# Example: find a date\n\nGeneral use of regular expressions in this package involves compiling an\nexpression and then using it to search, split or replace text. For example,\nto confirm that some text resembles a date:\n\n```rust\nuse regex::Regex;\nlet re = Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap();\nassert!(re.is_match(\"2014-01-01\"));\n```\n\nNotice the use of the `^` and `$` anchors. In this crate, every expression\nis executed with an implicit `.*?` at the beginning and end, which allows\nit to match anywhere in the text. Anchors can be used to ensure that the\nfull text matches an expression.\n\nThis example also demonstrates the utility of\n[raw strings](https://doc.rust-lang.org/stable/reference/tokens.html#raw-string-literals)\nin Rust, which\nare just like regular strings except they are prefixed with an `r` and do\nnot process any escape sequences. For example, `\"\\\\d\"` is the same\nexpression as `r\"\\d\"`.\n\n# Example: Avoid compiling the same regex in a loop\n\nIt is an anti-pattern to compile the same regular expression in a loop\nsince compilation is typically expensive. (It takes anywhere from a few\nmicroseconds to a few **milliseconds** depending on the size of the\nregex.) Not only is compilation itself expensive, but this also prevents\noptimizations that reuse allocations internally to the matching engines.\n\nIn Rust, it can sometimes be a pain to pass regular expressions around if\nthey're used from inside a helper function. Instead, we recommend using the\n[`lazy_static`](https://crates.io/crates/lazy_static) crate to ensure that\nregular expressions are compiled exactly once.\n\nFor example:\n\n```rust\nuse lazy_static::lazy_static;\nuse regex::Regex;\n\nfn some_helper_function(text: &str) -> bool {\n    lazy_static! {\n        static ref RE: Regex = Regex::new(\"...\").unwrap();\n    }\n    RE.is_match(text)\n}\n\nfn main() {}\n```\n\nSpecifically, in this example, the regex will be compiled when it is used for\nthe first time. On subsequent uses, it will reuse the previous compilation.\n\n# Example: iterating over capture groups\n\nThis crate provides convenient iterators for matching an expression\nrepeatedly against a search string to find successive non-overlapping\nmatches. For example, to find all dates in a string and be able to access\nthem by their component pieces:\n\n```rust\n# use regex::Regex;\n# fn main() {\nlet re = Regex::new(r\"(\\d{4})-(\\d{2})-(\\d{2})\").unwrap();\nlet text = \"2012-03-14, 2013-01-01 and 2014-07-05\";\nfor cap in re.captures_iter(text) {\n    println!(\"Month: {} Day: {} Year: {}\", &cap[2], &cap[3], &cap[1]);\n}\n// Output:\n// Month: 03 Day: 14 Year: 2012\n// Month: 01 Day: 01 Year: 2013\n// Month: 07 Day: 05 Year: 2014\n# }\n```\n\nNotice that the year is in the capture group indexed at `1`. This is\nbecause the *entire match* is stored in the capture group at index `0`.\n\n# Example: replacement with named capture groups\n\nBuilding on the previous example, perhaps we'd like to rearrange the date\nformats. This can be done with text replacement. But to make the code\nclearer, we can *name*  our capture groups and use those names as variables\nin our replacement text:\n\n```rust\n# use regex::Regex;\n# fn main() {\nlet re = Regex::new(r\"(?P<y>\\d{4})-(?P<m>\\d{2})-(?P<d>\\d{2})\").unwrap();\nlet before = \"2012-03-14, 2013-01-01 and 2014-07-05\";\nlet after = re.replace_all(before, \"$m/$d/$y\");\nassert_eq!(after, \"03/14/2012, 01/01/2013 and 07/05/2014\");\n# }\n```\n\nThe `replace` methods are actually polymorphic in the replacement, which\nprovides more flexibility than is seen here. (See the documentation for\n`Regex::replace` for more details.)\n\nNote that if your regex gets complicated, you can use the `x` flag to\nenable insignificant whitespace mode, which also lets you write comments:\n\n```rust\n# use regex::Regex;\n# fn main() {\nlet re = Regex::new(r\"(?x)\n  (?P<y>\\d{4}) # the year\n  -\n  (?P<m>\\d{2}) # the month\n  -\n  (?P<d>\\d{2}) # the day\n\").unwrap();\nlet before = \"2012-03-14, 2013-01-01 and 2014-07-05\";\nlet after = re.replace_all(before, \"$m/$d/$y\");\nassert_eq!(after, \"03/14/2012, 01/01/2013 and 07/05/2014\");\n# }\n```\n\nIf you wish to match against whitespace in this mode, you can still use `\\s`,\n`\\n`, `\\t`, etc. For escaping a single space character, you can escape it\ndirectly with `\\ `, use its hex character code `\\x20` or temporarily disable\nthe `x` flag, e.g., `(?-x: )`.\n\n# Example: match multiple regular expressions simultaneously\n\nThis demonstrates how to use a `RegexSet` to match multiple (possibly\noverlapping) regular expressions in a single scan of the search text:\n\n```rust\nuse regex::RegexSet;\n\nlet set = RegexSet::new(&[\n    r\"\\w+\",\n    r\"\\d+\",\n    r\"\\pL+\",\n    r\"foo\",\n    r\"bar\",\n    r\"barfoo\",\n    r\"foobar\",\n]).unwrap();\n\n// Iterate over and collect all of the matches.\nlet matches: Vec<_> = set.matches(\"foobar\").into_iter().collect();\nassert_eq!(matches, vec![0, 2, 3, 4, 6]);\n\n// You can also test whether a particular regex matched:\nlet matches = set.matches(\"foobar\");\nassert!(!matches.matched(5));\nassert!(matches.matched(6));\n```\n\n# Pay for what you use\n\nWith respect to searching text with a regular expression, there are three\nquestions that can be asked:\n\n1. Does the text match this expression?\n2. If so, where does it match?\n3. Where did the capturing groups match?\n\nGenerally speaking, this crate could provide a function to answer only #3,\nwhich would subsume #1 and #2 automatically. However, it can be significantly\nmore expensive to compute the location of capturing group matches, so it's best\nnot to do it if you don't need to.\n\nTherefore, only use what you need. For example, don't use `find` if you\nonly need to test if an expression matches a string. (Use `is_match`\ninstead.)\n\n# Unicode\n\nThis implementation executes regular expressions **only** on valid UTF-8\nwhile exposing match locations as byte indices into the search string. (To\nrelax this restriction, use the [`bytes`](bytes/index.html) sub-module.)\n\nOnly simple case folding is supported. Namely, when matching\ncase-insensitively, the characters are first mapped using the \"simple\" case\nfolding rules defined by Unicode.\n\nRegular expressions themselves are **only** interpreted as a sequence of\nUnicode scalar values. This means you can use Unicode characters directly\nin your expression:\n\n```rust\n# use regex::Regex;\n# fn main() {\nlet re = Regex::new(r\"(?i)Δ+\").unwrap();\nlet mat = re.find(\"ΔδΔ\").unwrap();\nassert_eq!((mat.start(), mat.end()), (0, 6));\n# }\n```\n\nMost features of the regular expressions in this crate are Unicode aware. Here\nare some examples:\n\n* `.` will match any valid UTF-8 encoded Unicode scalar value except for `\\n`.\n  (To also match `\\n`, enable the `s` flag, e.g., `(?s:.)`.)\n* `\\w`, `\\d` and `\\s` are Unicode aware. For example, `\\s` will match all forms\n  of whitespace categorized by Unicode.\n* `\\b` matches a Unicode word boundary.\n* Negated character classes like `[^a]` match all Unicode scalar values except\n  for `a`.\n* `^` and `$` are **not** Unicode aware in multi-line mode. Namely, they only\n  recognize `\\n` and not any of the other forms of line terminators defined\n  by Unicode.\n\nUnicode general categories, scripts, script extensions, ages and a smattering\nof boolean properties are available as character classes. For example, you can\nmatch a sequence of numerals, Greek or Cherokee letters:\n\n```rust\n# use regex::Regex;\n# fn main() {\nlet re = Regex::new(r\"[\\pN\\p{Greek}\\p{Cherokee}]+\").unwrap();\nlet mat = re.find(\"abcΔᎠβⅠᏴγδⅡxyz\").unwrap();\nassert_eq!((mat.start(), mat.end()), (3, 23));\n# }\n```\n\nFor a more detailed breakdown of Unicode support with respect to\n[UTS#18](https://unicode.org/reports/tr18/),\nplease see the\n[UNICODE](https://github.com/rust-lang/regex/blob/master/UNICODE.md)\ndocument in the root of the regex repository.\n\n# Opt out of Unicode support\n\nThe `bytes` sub-module provides a `Regex` type that can be used to match\non `&[u8]`. By default, text is interpreted as UTF-8 just like it is with\nthe main `Regex` type. However, this behavior can be disabled by turning\noff the `u` flag, even if doing so could result in matching invalid UTF-8.\nFor example, when the `u` flag is disabled, `.` will match any byte instead\nof any Unicode scalar value.\n\nDisabling the `u` flag is also possible with the standard `&str`-based `Regex`\ntype, but it is only allowed where the UTF-8 invariant is maintained. For\nexample, `(?-u:\\w)` is an ASCII-only `\\w` character class and is legal in an\n`&str`-based `Regex`, but `(?-u:\\xFF)` will attempt to match the raw byte\n`\\xFF`, which is invalid UTF-8 and therefore is illegal in `&str`-based\nregexes.\n\nFinally, since Unicode support requires bundling large Unicode data\ntables, this crate exposes knobs to disable the compilation of those\ndata tables, which can be useful for shrinking binary size and reducing\ncompilation times. For details on how to do that, see the section on [crate\nfeatures](#crate-features).\n\n# Syntax\n\nThe syntax supported in this crate is documented below.\n\nNote that the regular expression parser and abstract syntax are exposed in\na separate crate, [`regex-syntax`](https://docs.rs/regex-syntax).\n\n## Matching one character\n\n<pre class=\"rust\">\n.             any character except new line (includes new line with s flag)\n\\d            digit (\\p{Nd})\n\\D            not digit\n\\pN           One-letter name Unicode character class\n\\p{Greek}     Unicode character class (general category or script)\n\\PN           Negated one-letter name Unicode character class\n\\P{Greek}     negated Unicode character class (general category or script)\n</pre>\n\n### Character classes\n\n<pre class=\"rust\">\n[xyz]         A character class matching either x, y or z (union).\n[^xyz]        A character class matching any character except x, y and z.\n[a-z]         A character class matching any character in range a-z.\n[[:alpha:]]   ASCII character class ([A-Za-z])\n[[:^alpha:]]  Negated ASCII character class ([^A-Za-z])\n[x[^xyz]]     Nested/grouping character class (matching any character except y and z)\n[a-y&&xyz]    Intersection (matching x or y)\n[0-9&&[^4]]   Subtraction using intersection and negation (matching 0-9 except 4)\n[0-9--4]      Direct subtraction (matching 0-9 except 4)\n[a-g~~b-h]    Symmetric difference (matching `a` and `h` only)\n[\\[\\]]        Escaping in character classes (matching [ or ])\n</pre>\n\nAny named character class may appear inside a bracketed `[...]` character\nclass. For example, `[\\p{Greek}[:digit:]]` matches any Greek or ASCII\ndigit. `[\\p{Greek}&&\\pL]` matches Greek letters.\n\nPrecedence in character classes, from most binding to least:\n\n1. Ranges: `a-cd` == `[a-c]d`\n2. Union: `ab&&bc` == `[ab]&&[bc]`\n3. Intersection: `^a-z&&b` == `^[a-z&&b]`\n4. Negation\n\n## Composites\n\n<pre class=\"rust\">\nxy    concatenation (x followed by y)\nx|y   alternation (x or y, prefer x)\n</pre>\n\n## Repetitions\n\n<pre class=\"rust\">\nx*        zero or more of x (greedy)\nx+        one or more of x (greedy)\nx?        zero or one of x (greedy)\nx*?       zero or more of x (ungreedy/lazy)\nx+?       one or more of x (ungreedy/lazy)\nx??       zero or one of x (ungreedy/lazy)\nx{n,m}    at least n x and at most m x (greedy)\nx{n,}     at least n x (greedy)\nx{n}      exactly n x\nx{n,m}?   at least n x and at most m x (ungreedy/lazy)\nx{n,}?    at least n x (ungreedy/lazy)\nx{n}?     exactly n x\n</pre>\n\n## Empty matches\n\n<pre class=\"rust\">\n^     the beginning of text (or start-of-line with multi-line mode)\n$     the end of text (or end-of-line with multi-line mode)\n\\A    only the beginning of text (even with multi-line mode enabled)\n\\z    only the end of text (even with multi-line mode enabled)\n\\b    a Unicode word boundary (\\w on one side and \\W, \\A, or \\z on other)\n\\B    not a Unicode word boundary\n</pre>\n\n## Grouping and flags\n\n<pre class=\"rust\">\n(exp)          numbered capture group (indexed by opening parenthesis)\n(?P&lt;name&gt;exp)  named (also numbered) capture group (allowed chars: [_0-9a-zA-Z.\\[\\]])\n(?:exp)        non-capturing group\n(?flags)       set flags within current group\n(?flags:exp)   set flags for exp (non-capturing)\n</pre>\n\nFlags are each a single character. For example, `(?x)` sets the flag `x`\nand `(?-x)` clears the flag `x`. Multiple flags can be set or cleared at\nthe same time: `(?xy)` sets both the `x` and `y` flags and `(?x-y)` sets\nthe `x` flag and clears the `y` flag.\n\nAll flags are by default disabled unless stated otherwise. They are:\n\n<pre class=\"rust\">\ni     case-insensitive: letters match both upper and lower case\nm     multi-line mode: ^ and $ match begin/end of line\ns     allow . to match \\n\nU     swap the meaning of x* and x*?\nu     Unicode support (enabled by default)\nx     ignore whitespace and allow line comments (starting with `#`)\n</pre>\n\nFlags can be toggled within a pattern. Here's an example that matches\ncase-insensitively for the first part but case-sensitively for the second part:\n\n```rust\n# use regex::Regex;\n# fn main() {\nlet re = Regex::new(r\"(?i)a+(?-i)b+\").unwrap();\nlet cap = re.captures(\"AaAaAbbBBBb\").unwrap();\nassert_eq!(&cap[0], \"AaAaAbb\");\n# }\n```\n\nNotice that the `a+` matches either `a` or `A`, but the `b+` only matches\n`b`.\n\nMulti-line mode means `^` and `$` no longer match just at the beginning/end of\nthe input, but at the beginning/end of lines:\n\n```\n# use regex::Regex;\nlet re = Regex::new(r\"(?m)^line \\d+\").unwrap();\nlet m = re.find(\"line one\\nline 2\\n\").unwrap();\nassert_eq!(m.as_str(), \"line 2\");\n```\n\nNote that `^` matches after new lines, even at the end of input:\n\n```\n# use regex::Regex;\nlet re = Regex::new(r\"(?m)^\").unwrap();\nlet m = re.find_iter(\"test\\n\").last().unwrap();\nassert_eq!((m.start(), m.end()), (5, 5));\n```\n\nHere is an example that uses an ASCII word boundary instead of a Unicode\nword boundary:\n\n```rust\n# use regex::Regex;\n# fn main() {\nlet re = Regex::new(r\"(?-u:\\b).+(?-u:\\b)\").unwrap();\nlet cap = re.captures(\"$$abc$$\").unwrap();\nassert_eq!(&cap[0], \"abc\");\n# }\n```\n\n## Escape sequences\n\n<pre class=\"rust\">\n\\*          literal *, works for any punctuation character: \\.+*?()|[]{}^$\n\\a          bell (\\x07)\n\\f          form feed (\\x0C)\n\\t          horizontal tab\n\\n          new line\n\\r          carriage return\n\\v          vertical tab (\\x0B)\n\\123        octal character code (up to three digits) (when enabled)\n\\x7F        hex character code (exactly two digits)\n\\x{10FFFF}  any hex character code corresponding to a Unicode code point\n\\u007F      hex character code (exactly four digits)\n\\u{7F}      any hex character code corresponding to a Unicode code point\n\\U0000007F  hex character code (exactly eight digits)\n\\U{7F}      any hex character code corresponding to a Unicode code point\n</pre>\n\n## Perl character classes (Unicode friendly)\n\nThese classes are based on the definitions provided in\n[UTS#18](https://www.unicode.org/reports/tr18/#Compatibility_Properties):\n\n<pre class=\"rust\">\n\\d     digit (\\p{Nd})\n\\D     not digit\n\\s     whitespace (\\p{White_Space})\n\\S     not whitespace\n\\w     word character (\\p{Alphabetic} + \\p{M} + \\d + \\p{Pc} + \\p{Join_Control})\n\\W     not word character\n</pre>\n\n## ASCII character classes\n\n<pre class=\"rust\">\n[[:alnum:]]    alphanumeric ([0-9A-Za-z])\n[[:alpha:]]    alphabetic ([A-Za-z])\n[[:ascii:]]    ASCII ([\\x00-\\x7F])\n[[:blank:]]    blank ([\\t ])\n[[:cntrl:]]    control ([\\x00-\\x1F\\x7F])\n[[:digit:]]    digits ([0-9])\n[[:graph:]]    graphical ([!-~])\n[[:lower:]]    lower case ([a-z])\n[[:print:]]    printable ([ -~])\n[[:punct:]]    punctuation ([!-/:-@\\[-`{-~])\n[[:space:]]    whitespace ([\\t\\n\\v\\f\\r ])\n[[:upper:]]    upper case ([A-Z])\n[[:word:]]     word characters ([0-9A-Za-z_])\n[[:xdigit:]]   hex digit ([0-9A-Fa-f])\n</pre>\n\n# Crate features\n\nBy default, this crate tries pretty hard to make regex matching both as fast\nas possible and as correct as it can be, within reason. This means that there\nis a lot of code dedicated to performance, the handling of Unicode data and the\nUnicode data itself. Overall, this leads to more dependencies, larger binaries\nand longer compile times.  This trade off may not be appropriate in all cases,\nand indeed, even when all Unicode and performance features are disabled, one\nis still left with a perfectly serviceable regex engine that will work well\nin many cases.\n\nThis crate exposes a number of features for controlling that trade off. Some\nof these features are strictly performance oriented, such that disabling them\nwon't result in a loss of functionality, but may result in worse performance.\nOther features, such as the ones controlling the presence or absence of Unicode\ndata, can result in a loss of functionality. For example, if one disables the\n`unicode-case` feature (described below), then compiling the regex `(?i)a`\nwill fail since Unicode case insensitivity is enabled by default. Instead,\ncallers must use `(?i-u)a` instead to disable Unicode case folding. Stated\ndifferently, enabling or disabling any of the features below can only add or\nsubtract from the total set of valid regular expressions. Enabling or disabling\na feature will never modify the match semantics of a regular expression.\n\nAll features below are enabled by default.\n\n### Ecosystem features\n\n* **std** -\n  When enabled, this will cause `regex` to use the standard library. Currently,\n  disabling this feature will always result in a compilation error. It is\n  intended to add `alloc`-only support to regex in the future.\n\n### Performance features\n\n* **perf** -\n  Enables all performance related features. This feature is enabled by default\n  and will always cover all features that improve performance, even if more\n  are added in the future.\n* **perf-dfa** -\n  Enables the use of a lazy DFA for matching. The lazy DFA is used to compile\n  portions of a regex to a very fast DFA on an as-needed basis. This can\n  result in substantial speedups, usually by an order of magnitude on large\n  haystacks. The lazy DFA does not bring in any new dependencies, but it can\n  make compile times longer.\n* **perf-inline** -\n  Enables the use of aggressive inlining inside match routines. This reduces\n  the overhead of each match. The aggressive inlining, however, increases\n  compile times and binary size.\n* **perf-literal** -\n  Enables the use of literal optimizations for speeding up matches. In some\n  cases, literal optimizations can result in speedups of _several_ orders of\n  magnitude. Disabling this drops the `aho-corasick` and `memchr` dependencies.\n* **perf-cache** -\n  This feature used to enable a faster internal cache at the cost of using\n  additional dependencies, but this is no longer an option. A fast internal\n  cache is now used unconditionally with no additional dependencies. This may\n  change in the future.\n\n### Unicode features\n\n* **unicode** -\n  Enables all Unicode features. This feature is enabled by default, and will\n  always cover all Unicode features, even if more are added in the future.\n* **unicode-age** -\n  Provide the data for the\n  [Unicode `Age` property](https://www.unicode.org/reports/tr44/tr44-24.html#Character_Age).\n  This makes it possible to use classes like `\\p{Age:6.0}` to refer to all\n  codepoints first introduced in Unicode 6.0\n* **unicode-bool** -\n  Provide the data for numerous Unicode boolean properties. The full list\n  is not included here, but contains properties like `Alphabetic`, `Emoji`,\n  `Lowercase`, `Math`, `Uppercase` and `White_Space`.\n* **unicode-case** -\n  Provide the data for case insensitive matching using\n  [Unicode's \"simple loose matches\" specification](https://www.unicode.org/reports/tr18/#Simple_Loose_Matches).\n* **unicode-gencat** -\n  Provide the data for\n  [Unicode general categories](https://www.unicode.org/reports/tr44/tr44-24.html#General_Category_Values).\n  This includes, but is not limited to, `Decimal_Number`, `Letter`,\n  `Math_Symbol`, `Number` and `Punctuation`.\n* **unicode-perl** -\n  Provide the data for supporting the Unicode-aware Perl character classes,\n  corresponding to `\\w`, `\\s` and `\\d`. This is also necessary for using\n  Unicode-aware word boundary assertions. Note that if this feature is\n  disabled, the `\\s` and `\\d` character classes are still available if the\n  `unicode-bool` and `unicode-gencat` features are enabled, respectively.\n* **unicode-script** -\n  Provide the data for\n  [Unicode scripts and script extensions](https://www.unicode.org/reports/tr24/).\n  This includes, but is not limited to, `Arabic`, `Cyrillic`, `Hebrew`,\n  `Latin` and `Thai`.\n* **unicode-segment** -\n  Provide the data necessary to provide the properties used to implement the\n  [Unicode text segmentation algorithms](https://www.unicode.org/reports/tr29/).\n  This enables using classes like `\\p{gcb=Extend}`, `\\p{wb=Katakana}` and\n  `\\p{sb=ATerm}`.\n\n\n# Untrusted input\n\nThis crate can handle both untrusted regular expressions and untrusted\nsearch text.\n\nUntrusted regular expressions are handled by capping the size of a compiled\nregular expression.\n(See [`RegexBuilder::size_limit`](struct.RegexBuilder.html#method.size_limit).)\nWithout this, it would be trivial for an attacker to exhaust your system's\nmemory with expressions like `a{100}{100}{100}`.\n\nUntrusted search text is allowed because the matching engine(s) in this\ncrate have time complexity `O(mn)` (with `m ~ regex` and `n ~ search\ntext`), which means there's no way to cause exponential blow-up like with\nsome other regular expression engines. (We pay for this by disallowing\nfeatures like arbitrary look-ahead and backreferences.)\n\nWhen a DFA is used, pathological cases with exponential state blow-up are\navoided by constructing the DFA lazily or in an \"online\" manner. Therefore,\nat most one new state can be created for each byte of input. This satisfies\nour time complexity guarantees, but can lead to memory growth\nproportional to the size of the input. As a stopgap, the DFA is only\nallowed to store a fixed number of states. When the limit is reached, its\nstates are wiped and continues on, possibly duplicating previous work. If\nthe limit is reached too frequently, it gives up and hands control off to\nanother matching engine with fixed memory requirements.\n(The DFA size limit can also be tweaked. See\n[`RegexBuilder::dfa_size_limit`](struct.RegexBuilder.html#method.dfa_size_limit).)","links":{},"attrs":["#![deny(missing_docs)]","#![warn(missing_debug_implementations)]"],"deprecation":null,"kind":"module","inner":{"is_crate":true,"items":["0:55:1602","0:3","0:6","0:7","0:8","0:10","0:13","0:16","0:19","0:22","0:25","0:28","0:31","0:34","0:37","0:40","0:43","0:46","0:49","0:52"],"is_stripped":false}},"1:5779:6006":{"id":"1:5779:6006","crate_id":1,"name":"FileTypeExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5780:57018","1:5781:57019","1:5782:57020","1:5783:57021"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2385:1808":{"id":"0:2385:1808","crate_id":0,"name":"goto","span":{"filename":"src/prog.rs","begin":[312,4],"end":[312,21]},"visibility":"public","docs":"The next location to execute in the program.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"2:3405:4848":{"id":"2:3405:4848","crate_id":2,"name":"BitXor","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3407:181","2:3408:356"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2674:1587":{"id":"0:2674:1587","crate_id":0,"name":"CaptureLocations","span":{"filename":"src/re_bytes.rs","begin":[860,0],"end":[860,49]},"visibility":"public","docs":"CaptureLocations is a low level representation of the raw offsets of each\nsubmatch.\n\nYou can think of this as a lower level\n[`Captures`](struct.Captures.html), where this type does not support\nnamed capturing groups directly and it does not borrow the text that these\noffsets were matched on.\n\nPrimarily, this type is useful when using the lower level `Regex` APIs\nsuch as `read_captures`, which permits amortizing the allocation in which\ncapture match locations are stored.\n\nIn order to build a value of this type, you'll need to call the\n`capture_locations` method on the `Regex` being used to execute the search.\nThe value returned can then be reused in subsequent searches.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:13440:59288":{"id":"2:13440:59288","crate_id":2,"name":"split_at_mut","span":null,"visibility":"public","docs":"Divide one mutable string slice into two at an index.\n\nThe argument, `mid`, should be a byte offset from the start of the\nstring. It must also be on the boundary of a UTF-8 code point.\n\nThe two slices returned go from the start of the string slice to `mid`,\nand from `mid` to the end of the string slice.\n\nTo get immutable string slices instead, see the [`split_at`] method.\n\n[`split_at`]: str::split_at\n\n# Panics\n\nPanics if `mid` is not on a UTF-8 code point boundary, or if it is\npast the end of the last code point of the string slice.\n\n# Examples\n\nBasic usage:\n\n```\nlet mut s = \"Per Martin-Löf\".to_string();\n{\n    let (first, last) = s.split_at_mut(3);\n    first.make_ascii_uppercase();\n    assert_eq!(\"PER\", first);\n    assert_eq!(\" Martin-Löf\", last);\n}\nassert_eq!(\"PER Martin-Löf\", s);\n```","links":{"str::split_at":"1:16011:4444"},"attrs":["#[must_use]","#[stable(feature = \"str_split_at\", since = \"1.4.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}],["mid",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"tuple","inner":[{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"primitive","inner":"str"}}},{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"primitive","inner":"str"}}}]},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:12992:3565":{"id":"2:12992:3565","crate_id":2,"name":"FromStr","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:12993:126","2:12994:3588"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:22":{"id":"0:22","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[632,60],"end":[632,68]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::Captures","name":"Captures","id":"0:1565:1590","glob":false}},"0:2362:1805":{"id":"0:2362:1805","crate_id":0,"name":"Save","span":{"filename":"src/prog.rs","begin":[279,4],"end":[279,18]},"visibility":"default","docs":"Save causes the program to save the current location of the input in\nthe slot indicated by InstSave.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"resolved_path","inner":{"name":"InstSave","id":"0:2384:1833","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}]}},"2:3177:228":{"id":"2:3177:228","crate_id":2,"name":"TryInto","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3179:127","2:3180:1415"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:8399:136":{"id":"2:8399:136","crate_id":2,"name":"FromIterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:8401:684"],"generics":{"params":[{"name":"A","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1459:1586":{"id":"0:1459:1586","crate_id":0,"name":"escape","span":{"filename":"src/re_unicode.rs","begin":[21,0],"end":[23,1]},"visibility":"public","docs":"Escapes all regular expression meta characters in `text`.\n\nThe string returned may be safely used as a literal in a regular\nexpression.","links":{},"attrs":[],"deprecation":null,"kind":"function","inner":{"decl":{"inputs":[["text",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"}}},"2:3357:4839":{"id":"2:3357:4839","crate_id":2,"name":"Rem","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3359:181","2:3360:1102"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:3491:116":{"id":"2:3491:116","crate_id":2,"name":"Deref","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3492:221","2:3493:543"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13475:63207":{"id":"2:13475:63207","crate_id":2,"name":"split_terminator","span":null,"visibility":"public","docs":"An iterator over substrings of the given string slice, separated by\ncharacters matched by a pattern.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\nEquivalent to [`split`], except that the trailing substring\nis skipped if empty.\n\n[`split`]: str::split\n\nThis method can be used for string data that is _terminated_,\nrather than _separated_ by a pattern.\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rsplit_terminator`] method can be used.\n\n[`rsplit_terminator`]: str::rsplit_terminator\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\nassert_eq!(v, [\"A\", \"B\"]);\n\nlet v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\nassert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n\nlet v: Vec<&str> = \"A.B:C.D\".split_terminator(&['.', ':'][..]).collect();\nassert_eq!(v, [\"A\", \"B\", \"C\", \"D\"]);\n```","links":{"prim@char":"1:16005:4439","str::rsplit_terminator":"1:16011:4444","`DoubleEndedIterator`":"2:8447:120","str::split":"1:16011:4444","self::pattern":"2:13053:1578"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"SplitTerminator","id":"2:49509:4901","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2463:2768":{"id":"0:2463:2768","crate_id":0,"name":"swap_greed","span":{"filename":"src/re_builder.rs","begin":[12,4],"end":[12,24]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"2:3580:4857":{"id":"2:3580:4857","crate_id":2,"name":"IndexMut","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3582:754"],"generics":{"params":[{"name":"Idx","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"Idx"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Index","id":"2:3576:3564","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Idx"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:2256:1958":{"id":"0:2256:1958","crate_id":0,"name":"Empty","span":{"filename":"src/literal/imp.rs","begin":[223,4],"end":[223,9]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"plain"}},"0:2353:1986":{"id":"0:2353:1986","crate_id":0,"name":"has_unicode_word_boundary","span":{"filename":"src/prog.rs","begin":[56,4],"end":[56,39]},"visibility":"public","docs":"Whether this program contains a Unicode word boundary instruction.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"0:2282:3137":{"id":"0:2282:3137","crate_id":0,"name":"Memmem","span":{"filename":"src/literal/imp.rs","begin":[361,0],"end":[364,1]},"visibility":"public","docs":"A simple wrapper around the memchr crate's memmem implementation.\n\nThe API this exposes mirrors the API of previous substring searchers that\nthis supplanted.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:3576:3564":{"id":"2:3576:3564","crate_id":2,"name":"Index","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3578:181","2:3579:753"],"generics":{"params":[{"name":"Idx","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"Idx"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[],"implementations":[]}},"2:3739:4861":{"id":"2:3739:4861","crate_id":2,"name":"Residual","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3741:58125"],"generics":{"params":[{"name":"O","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:8447:120":{"id":"2:8447:120","crate_id":2,"name":"DoubleEndedIterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:8448:4130","2:8449:5376","2:8450:5377","2:8451:5378","2:8455:5379","2:8458:5380"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Iterator","id":"2:8601:157","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:23771:6421":{"id":"2:23771:6421","crate_id":2,"name":"SimdElement","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":["2:23772:6424"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"2:23767:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Copy","id":"2:3278:106","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:13540:63224":{"id":"2:13540:63224","crate_id":2,"name":"escape_debug","span":null,"visibility":"public","docs":"Return an iterator that escapes each char in `self` with [`char::escape_debug`].\n\nNote: only extended grapheme codepoints that begin the string will be\nescaped.\n\n# Examples\n\nAs an iterator:\n\n```\nfor c in \"❤\\n!\".escape_debug() {\n    print!(\"{c}\");\n}\nprintln!();\n```\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"❤\\n!\".escape_debug());\n```\n\n\nBoth are equivalent to:\n\n```\nprintln!(\"❤\\\\n!\");\n```\n\nUsing `to_string`:\n\n```\nassert_eq!(\"❤\\n!\".escape_debug().to_string(), \"❤\\\\n!\");\n```","links":{"`char::escape_debug`":"1:16005:4439"},"attrs":["#[must_use =\n\"this returns the escaped string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"str_escape\", since = \"1.34.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"EscapeDebug","id":"2:49758:4890","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:1565:1590":{"id":"0:1565:1590","crate_id":0,"name":"Captures","span":{"filename":"src/re_unicode.rs","begin":[922,0],"end":[926,1]},"visibility":"public","docs":"Captures represents a group of captured strings for a single match.\n\nThe 0th capture always corresponds to the entire match. Each subsequent\nindex corresponds to the next capture group in the regex. If a capture\ngroup is named, then the matched string is *also* available via the `name`\nmethod. (Note that the 0th capture is always unnamed and so must be\naccessed with the `get` method.)\n\nPositions returned from a capture group are always byte indices.\n\n`'t` is the lifetime of the matched text.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:13466:1910":{"id":"2:13466:1910","crate_id":2,"name":"split","span":null,"visibility":"public","docs":"An iterator over substrings of this string slice, separated by\ncharacters matched by a pattern.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rsplit`] method can be used.\n\n[`rsplit`]: str::rsplit\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\nassert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n\nlet v: Vec<&str> = \"\".split('X').collect();\nassert_eq!(v, [\"\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\nassert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\nassert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n\nlet v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\nassert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n\nlet v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\nassert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n```\n\nIf the pattern is a slice of chars, split on each occurrence of any of the characters:\n\n```\nlet v: Vec<&str> = \"2020-11-03 23:59\".split(&['-', ' ', ':', '@'][..]).collect();\nassert_eq!(v, [\"2020\", \"11\", \"03\", \"23\", \"59\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n```\n\nIf a string contains multiple contiguous separators, you will end up\nwith empty strings in the output:\n\n```\nlet x = \"||||a||b|c\".to_string();\nlet d: Vec<_> = x.split('|').collect();\n\nassert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n```\n\nContiguous separators are separated by the empty string.\n\n```\nlet x = \"(///)\".to_string();\nlet d: Vec<_> = x.split('/').collect();\n\nassert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n```\n\nSeparators at the start or end of a string are neighbored\nby empty strings.\n\n```\nlet d: Vec<_> = \"010\".split(\"0\").collect();\nassert_eq!(d, &[\"\", \"1\", \"\"]);\n```\n\nWhen the empty string is used as a separator, it separates\nevery character in the string, along with the beginning\nand end of the string.\n\n```\nlet f: Vec<_> = \"rust\".split(\"\").collect();\nassert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n```\n\nContiguous separators can lead to possibly surprising behavior\nwhen whitespace is used as the separator. This code is correct:\n\n```\nlet x = \"    a  b c\".to_string();\nlet d: Vec<_> = x.split(' ').collect();\n\nassert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n```\n\nIt does _not_ give you:\n\n```,ignore\nassert_eq!(d, &[\"a\", \"b\", \"c\"]);\n```\n\nUse [`split_whitespace`] for this behavior.\n\n[`split_whitespace`]: str::split_whitespace","links":{"str::split_whitespace":"1:16011:4444","prim@char":"1:16005:4439","self::pattern":"2:13053:1578","`DoubleEndedIterator`":"2:8447:120","str::rsplit":"1:16011:4444"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Split","id":"2:49459:1598","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:2920:183":{"id":"2:2920:183","crate_id":2,"name":"PartialEq","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2922:604","2:2923:907"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"Rhs"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[],"implementations":[]}},"0:2815:1602":{"id":"0:2815:1602","crate_id":0,"name":"bytes","span":{"filename":"src/re_set.rs","begin":[480,0],"end":[507,1]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2890:2908","0:2895:4090","0:2902:4124","0:2907:4123"],"is_stripped":false}},"0:2398:1832":{"id":"0:2398:1832","crate_id":0,"name":"InstEmptyLook","span":{"filename":"src/prog.rs","begin":[331,0],"end":[337,1]},"visibility":"public","docs":"Representation of the `EmptyLook` instruction.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":false,"fields":["0:2399:1808","0:2400:2026"],"impls":[]}},"2:13425:2795":{"id":"2:13425:2795","crate_id":2,"name":"as_bytes","span":null,"visibility":"public","docs":"Converts a string slice to a byte slice. To convert the byte slice back\ninto a string slice, use the [`from_utf8`] function.\n\n# Examples\n\nBasic usage:\n\n```\nlet bytes = \"bors\".as_bytes();\nassert_eq!(b\"bors\", bytes);\n```","links":{"`from_utf8`":"2:12524:3023"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_const_stable(feature = \"str_as_bytes\", since = \"1.39.0\")]","#[must_use]","#[allow(unused_attributes)]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":true,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:745:1797":{"id":"0:745:1797","crate_id":0,"name":"prefix_at","span":{"filename":"src/input.rs","begin":[86,4],"end":[90,25]},"visibility":"default","docs":"Scan the input for a matching prefix.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["prefixes",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"resolved_path","inner":{"name":"LiteralSearcher","id":"0:2226:1628","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}],["at",{"kind":"resolved_path","inner":{"name":"InputAt","id":"0:2172:1627","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"resolved_path","inner":{"name":"InputAt","id":"0:2172:1627","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"0:3011:1587":{"id":"0:3011:1587","crate_id":0,"name":"CaptureLocations","span":{"filename":"src/re_unicode.rs","begin":[870,0],"end":[870,49]},"visibility":"public","docs":"CaptureLocations is a low level representation of the raw offsets of each\nsubmatch.\n\nYou can think of this as a lower level\n[`Captures`](struct.Captures.html), where this type does not support\nnamed capturing groups directly and it does not borrow the text that these\noffsets were matched on.\n\nPrimarily, this type is useful when using the lower level `Regex` APIs\nsuch as `read_captures`, which permits amortizing the allocation in which\ncapture match locations are stored.\n\nIn order to build a value of this type, you'll need to call the\n`capture_locations` method on the `Regex` being used to execute the search.\nThe value returned can then be reused in subsequent searches.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:3434:4855":{"id":"2:3434:4855","crate_id":2,"name":"ShlAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3436:1232"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1724:1621":{"id":"0:1724:1621","crate_id":0,"name":"internal","span":{"filename":"src/lib.rs","begin":[760,0],"end":[760,16]},"visibility":"public","docs":"The `internal` module exists to support suspicious activity, such as\ntesting different matching engines and supporting the `regex-debug` CLI\nutility.","links":{},"attrs":["#[doc(hidden)]","#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:1725","0:1729","0:1732","0:1736","0:1739","0:1742","0:1745","0:1748","0:1752","0:1755","0:1758","0:1761"],"is_stripped":true}},"1:6863:5994":{"id":"1:6863:5994","crate_id":1,"name":"AsRawFd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6864:61408"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2442:1969":{"id":"0:2442:1969","crate_id":0,"name":"ranges","span":{"filename":"src/prog.rs","begin":[377,4],"end":[377,35]},"visibility":"public","docs":"The set of Unicode scalar value ranges to test.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"Box","id":"5:432:2019","args":{"angle_bracketed":{"args":[{"type":{"kind":"slice","inner":{"kind":"tuple","inner":[{"kind":"primitive","inner":"char"},{"kind":"primitive","inner":"char"}]}}}],"bindings":[]}},"param_names":[]}}},"0:2983:1589":{"id":"0:2983:1589","crate_id":0,"name":"CaptureNames","span":{"filename":"src/re_unicode.rs","begin":[751,0],"end":[751,68]},"visibility":"public","docs":"An iterator over the names of all possible captures.\n\n`None` indicates an unnamed capture; the first element (capture 0, the\nwhole matched region) is always unnamed.\n\n`'r` is the lifetime of the compiled regular expression.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:3276:218":{"id":"2:3276:218","crate_id":2,"name":"StructuralPartialEq","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2351:1792":{"id":"0:2351:1792","crate_id":0,"name":"is_anchored_start","span":{"filename":"src/prog.rs","begin":[52,4],"end":[52,31]},"visibility":"public","docs":"Whether the regex must match from the start of the input.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"2:8403:151":{"id":"2:8403:151","crate_id":2,"name":"IntoIterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:8404:2027","2:8405:3395","2:8406:768"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2361:1540":{"id":"0:2361:1540","crate_id":0,"name":"0","span":{"filename":"src/prog.rs","begin":[276,10],"end":[276,15]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"2:13536:2020":{"id":"2:13536:2020","crate_id":2,"name":"is_ascii","span":null,"visibility":"public","docs":"Checks if all characters in this string are within the ASCII range.\n\n# Examples\n\n```\nlet ascii = \"hello!\\n\";\nlet non_ascii = \"Grüße, Jürgen ❤\";\n\nassert!(ascii.is_ascii());\nassert!(!non_ascii.is_ascii());\n```","links":{},"attrs":["#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]","#[must_use]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:13472:59297":{"id":"2:13472:59297","crate_id":2,"name":"rsplit","span":null,"visibility":"public","docs":"An iterator over substrings of the given string slice, separated by\ncharacters matched by a pattern and yielded in reverse order.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse\nsearch, and it will be a [`DoubleEndedIterator`] if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`split`] method can be used.\n\n[`split`]: str::split\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\nassert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n\nlet v: Vec<&str> = \"\".rsplit('X').collect();\nassert_eq!(v, [\"\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n```","links":{"self::pattern":"2:13053:1578","str::split":"1:16011:4444","`DoubleEndedIterator`":"2:8447:120","prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"RSplit","id":"2:49477:4898","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:3439:4856":{"id":"2:3439:4856","crate_id":2,"name":"ShrAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3441:1235"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2664:1589":{"id":"0:2664:1589","crate_id":0,"name":"CaptureNames","span":{"filename":"src/re_bytes.rs","begin":[819,0],"end":[819,68]},"visibility":"public","docs":"An iterator over the names of all possible captures.\n\n`None` indicates an unnamed capture; the first element (capture 0, the\nwhole matched region) is always unnamed.\n\n`'r` is the lifetime of the compiled regular expression.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:741:1771":{"id":"0:741:1771","crate_id":0,"name":"at","span":{"filename":"src/input.rs","begin":[69,4],"end":[69,38]},"visibility":"default","docs":"Return an encoding of the position at byte offset `i`.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["i",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"resolved_path","inner":{"name":"InputAt","id":"0:2172:1627","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"2:3400:4847":{"id":"2:3400:4847","crate_id":2,"name":"BitOr","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3402:181","2:3403:353"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:3733:137":{"id":"2:3733:137","crate_id":2,"name":"FromResidual","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3735:687"],"generics":{"params":[{"name":"R","kind":{"type":{"bounds":[],"default":{"kind":"qualified_path","inner":{"name":"Residual","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"Self"},"trait":{"kind":"resolved_path","inner":{"name":"Try","id":"2:3728:224","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13537:56934":{"id":"2:13537:56934","crate_id":2,"name":"eq_ignore_ascii_case","span":null,"visibility":"public","docs":"Checks that two strings are an ASCII case-insensitive match.\n\nSame as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\nbut without allocating and copying temporaries.\n\n# Examples\n\n```\nassert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\nassert!(\"Ferrös\".eq_ignore_ascii_case(\"FERRöS\"));\nassert!(!\"Ferrös\".eq_ignore_ascii_case(\"FERRÖS\"));\n```","links":{},"attrs":["#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]","#[must_use]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["other",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2349:1883":{"id":"0:2349:1883","crate_id":0,"name":"is_dfa","span":{"filename":"src/prog.rs","begin":[47,4],"end":[47,20]},"visibility":"public","docs":"When true, the program is compiled for DFA matching. For example, this\nimplies `is_bytes` and also inserts a preceding `.*?` for unanchored\nregexes.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"0:28":{"id":"0:28","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[633,15],"end":[633,20]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::Match","name":"Match","id":"0:2954:1592","glob":false}},"1:5012:6079":{"id":"1:5012:6079","crate_id":1,"name":"ToSocketAddrs","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5013:3396","1:5014:57403"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2017:127":{"id":"0:2017:127","crate_id":0,"name":"Error","span":{"filename":"src/error.rs","begin":[6,0],"end":[19,1]},"visibility":"public","docs":"An error that occurred during parsing or compiling a regular expression.","links":{},"attrs":[],"deprecation":null,"kind":"enum","inner":{"generics":{"params":[],"where_predicates":[]},"variants_stripped":true,"variants":["0:2018:1984","0:2021:2068"],"impls":[]}},"2:10933:214":{"id":"2:10933:214","crate_id":2,"name":"SliceIndex","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":["2:10935:181","2:10936:1807","2:10937:11313","2:10938:2395","2:10939:59268","2:10940:753","2:10941:754"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"T"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"2:10924:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:3999:68":{"id":"2:3999:68","crate_id":2,"name":"Any","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:4000:1427"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"outlives":"'static"}],"implementations":[]}},"2:13513:63219":{"id":"2:13513:63219","crate_id":2,"name":"trim_matches","span":null,"visibility":"public","docs":"Returns a string slice with all prefixes and suffixes that match a\npattern repeatedly removed.\n\nThe [pattern] can be a [`char`], a slice of [`char`]s, or a function\nor closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n```\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n```","links":{"prim@char":"1:16005:4439","self::pattern":"2:13053:1578"},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"DoubleEndedSearcher","id":"2:13083:4875","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"1:6463:6022":{"id":"1:6463:6022","crate_id":1,"name":"ExitStatusExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6464:57438","1:6465:10503","1:6466:57439","1:6467:57440","1:6468:57441","1:6469:57442"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10569:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:1643:3777":{"id":"0:1643:3777","crate_id":0,"name":"no_expansion","span":{"filename":"src/re_unicode.rs","begin":[1179,4],"end":[1181,5]},"visibility":"default","docs":"Return a fixed unchanging replacement string.\n\nWhen doing replacements, if access to `Captures` is not needed (e.g.,\nthe replacement byte string does not need `$` expansion), then it can\nbe beneficial to avoid finding sub-captures.\n\nIn general, this is called once for every call to `replacen`.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'r","mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"resolved_path","inner":{"name":"Cow","id":"5:792:108","args":{"angle_bracketed":{"args":[{"lifetime":"'r"},{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"1:5801:6009":{"id":"1:5801:6009","crate_id":1,"name":"DirBuilderExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5802:8272"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13455:59303":{"id":"2:13455:59303","crate_id":2,"name":"ends_with","span":null,"visibility":"public","docs":"Returns `true` if the given pattern matches a suffix of this\nstring slice.\n\nReturns `false` if it does not.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nBasic usage:\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.ends_with(\"anas\"));\nassert!(!bananas.ends_with(\"nana\"));\n```","links":{"prim@char":"1:16005:4439","self::pattern":"2:13053:1578"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:3061:1540":{"id":"0:3061:1540","crate_id":0,"name":"0","span":{"filename":"src/re_unicode.rs","begin":[1301,24],"end":[1301,35]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"borrowed_ref","inner":{"lifetime":"'t","mutable":false,"type":{"kind":"primitive","inner":"str"}}}},"2:23086:20161":{"id":"2:23086:20161","crate_id":2,"name":"ToBitMask","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:23087:9660","2:23088:62587","2:23089:62588"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"2:23079:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:3518:130":{"id":"2:3518:130","crate_id":2,"name":"Fn","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3520:376"],"generics":{"params":[{"name":"Args","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"FnMut","id":"2:3521:131","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Args"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:1681:1616":{"id":"0:1681:1616","crate_id":0,"name":"sparse","span":{"filename":"src/sparse.rs","begin":[1,0],"end":[84,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:3068:2145"],"is_stripped":true}},"0:2497:3477":{"id":"0:2497:3477","crate_id":0,"name":"RegexBuilder","span":{"filename":"src/re_builder.rs","begin":[231,0],"end":[231,39]},"visibility":"public","docs":"A configurable builder for a regular expression.\n\nA builder can be used to configure how the regex is built, for example, by\nsetting the default flags (which can be overridden in the expression\nitself) or setting various limits.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:8412:4660":{"id":"2:8412:4660","crate_id":2,"name":"Extend","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:8414:2566","2:8416:5381","2:8417:5382"],"generics":{"params":[{"name":"A","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:821":{"id":"0:821","crate_id":0,"name":null,"span":{"filename":"src/literal/mod.rs","begin":[1,0],"end":[1,21]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"self::imp","name":"imp","id":"0:822:2898","glob":true}},"0:3018:1600":{"id":"0:3018:1600","crate_id":0,"name":"SubCaptureMatches","span":{"filename":"src/re_unicode.rs","begin":[1082,0],"end":[1085,1]},"visibility":"public","docs":"An iterator that yields all capturing matches in the order in which they\nappear in the regex.\n\nIf a particular capture group didn't participate in the match, then `None`\nis yielded for that capture. The first match always corresponds to the\noverall match of the regex.\n\nThe lifetime `'c` corresponds to the lifetime of the `Captures` value, and\nthe lifetime `'t` corresponds to the originally matched text.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'c","kind":{"lifetime":{"outlives":[]}}},{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"5:6085:2466":{"id":"5:6085:2466","crate_id":5,"name":"replace","span":null,"visibility":"public","docs":"Replaces all matches of a pattern with another string.\n\n`replace` creates a new [`String`], and copies the data from this string slice into it.\nWhile doing so, it attempts to find matches of a pattern. If it finds any, it\nreplaces them with the replacement string slice.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"this is old\";\n\nassert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\nassert_eq!(\"than an old\", s.replace(\"is\", \"an\"));\n```\n\nWhen the pattern doesn't match:\n\n```\nlet s = \"this is old\";\nassert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n```","links":{"`String`":"5:8368:216"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n\"this returns the replaced string as a new allocation, \\\n                  without modifying the original\"]","#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["from",{"kind":"generic","inner":"P"}],["to",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:3165:75":{"id":"2:3165:75","crate_id":2,"name":"AsRef","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3167:305"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"T"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[],"implementations":[]}},"2:13447:63206":{"id":"2:13447:63206","crate_id":2,"name":"lines_any","span":null,"visibility":"public","docs":"An iterator over the lines of a string.","links":{},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[deprecated(since = \"1.4.0\", note = \"use lines() instead now\")]","#[allow(deprecated)]"],"deprecation":{"since":"1.4.0","note":"use lines() instead now"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"LinesAny","id":"2:49723:4894","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:3273:3969":{"id":"2:3273:3969","crate_id":2,"name":"Sized","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13484:59300":{"id":"2:13484:59300","crate_id":2,"name":"rsplitn","span":null,"visibility":"public","docs":"An iterator over substrings of this string slice, separated by a\npattern, starting from the end of the string, restricted to returning\nat most `n` items.\n\nIf `n` substrings are returned, the last substring (the `n`th substring)\nwill contain the remainder of the string.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will not be double ended, because it is not\nefficient to support.\n\nFor splitting from the front, the [`splitn`] method can be used.\n\n[`splitn`]: str::splitn\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\nassert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\nassert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"ghi\", \"abc1def\"]);\n```","links":{"str::splitn":"1:16011:4444","self::pattern":"2:13053:1578","prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["n",{"kind":"primitive","inner":"usize"}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"RSplitN","id":"2:49581:4899","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"5:6088:3767":{"id":"5:6088:3767","crate_id":5,"name":"replacen","span":null,"visibility":"public","docs":"Replaces first N matches of a pattern with another string.\n\n`replacen` creates a new [`String`], and copies the data from this string slice into it.\nWhile doing so, it attempts to find matches of a pattern. If it finds any, it\nreplaces them with the replacement string slice at most `count` times.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"foo foo 123 foo\";\nassert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\nassert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\nassert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n```\n\nWhen the pattern doesn't match:\n\n```\nlet s = \"this is old\";\nassert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n```","links":{"`String`":"5:8368:216"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n\"this returns the replaced string as a new allocation, \\\n                  without modifying the original\"]","#[stable(feature = \"str_replacen\", since = \"1.16.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}],["to",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}}],["count",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:8366:4661":{"id":"2:8366:4661","crate_id":2,"name":"Product","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:8368:5416"],"generics":{"params":[{"name":"A","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:14165:141":{"id":"2:14165:141","crate_id":2,"name":"GlobalAlloc","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":["2:14166:277","2:14167:518","2:14168:280","2:14169:1079"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:23462:6426":{"id":"2:23462:6426","crate_id":2,"name":"SimdPartialOrd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:23463:1268","2:23464:1267","2:23465:1265","2:23466:1264"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"SimdPartialEq","id":"2:22874:6512","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:13438:63205":{"id":"2:13438:63205","crate_id":2,"name":"slice_mut_unchecked","span":null,"visibility":"public","docs":"Creates a string slice from another string slice, bypassing safety\nchecks.\nThis is generally not recommended, use with caution! For a safe\nalternative see [`str`] and [`IndexMut`].\n\n[`IndexMut`]: crate::ops::IndexMut\n\nThis new slice goes from `begin` to `end`, including `begin` but\nexcluding `end`.\n\nTo get an immutable string slice instead, see the\n[`slice_unchecked`] method.\n\n[`slice_unchecked`]: str::slice_unchecked\n\n# Safety\n\nCallers of this function are responsible that three preconditions are\nsatisfied:\n\n* `begin` must not exceed `end`.\n* `begin` and `end` must be byte positions within the string slice.\n* `begin` and `end` must lie on UTF-8 sequence boundaries.","links":{"str::slice_unchecked":"1:16011:4444","`str`":"1:16011:4444","crate::ops::IndexMut":"2:3580:4857"},"attrs":["#[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]","#[deprecated(since = \"1.29.0\", note =\n\"use `get_unchecked_mut(begin..end)` instead\")]"],"deprecation":{"since":"1.29.0","note":"use `get_unchecked_mut(begin..end)` instead"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}],["begin",{"kind":"primitive","inner":"usize"}],["end",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":true,"async":false,"abi":"Rust"},"has_body":true}},"1:5657:6094":{"id":"1:5657:6094","crate_id":1,"name":"OsStrExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5658:7440","1:5659:2795"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10569:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"1:5793:6001":{"id":"1:5793:6001","crate_id":1,"name":"DirEntryExt2","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5794:58680"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10569:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:3430:4854":{"id":"2:3430:4854","crate_id":2,"name":"BitXorAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3432:357"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:4050:5747":{"id":"2:4050:5747","crate_id":2,"name":"Provider","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:4051:5755"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1344:1615":{"id":"0:1344:1615","crate_id":0,"name":"re_trait","span":{"filename":"src/re_trait.rs","begin":[1,0],"end":[294,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2924:3566","0:1367:2655","0:2934:1593","0:2945:1588"],"is_stripped":true}},"0:2406:1976":{"id":"0:2406:1976","crate_id":0,"name":"StartLine","span":{"filename":"src/prog.rs","begin":[343,4],"end":[343,13]},"visibility":"default","docs":"Start of line or input.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"plain"}},"0:2420:1994":{"id":"0:2420:1994","crate_id":0,"name":"NotWordBoundaryAscii","span":{"filename":"src/prog.rs","begin":[357,4],"end":[357,24]},"visibility":"default","docs":"Not ASCII word boundary.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"plain"}},"0:2206:1625":{"id":"0:2206:1625","crate_id":0,"name":"Char","span":{"filename":"src/input.rs","begin":[346,0],"end":[346,21]},"visibility":"public","docs":"An inline representation of `Option<char>`.\n\nThis eliminates the need to do case analysis on `Option<char>` to determine\nordinality with other characters.\n\n(The `Option<char>` is not related to encoding. Instead, it is used in the\nmatching engines to represent the beginning and ending boundaries of the\nsearch text.)","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:10302:5345":{"id":"2:10302:5345","crate_id":2,"name":"Binary","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10303:660"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:49":{"id":"0:49","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[634,4],"end":[634,10]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::SplitN","name":"SplitN","id":"0:3002:1599","glob":false}},"5:6411:223":{"id":"5:6411:223","crate_id":5,"name":"ToString","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["5:6412:1395"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2706:1540":{"id":"0:2706:1540","crate_id":0,"name":"0","span":{"filename":"src/re_bytes.rs","begin":[1250,24],"end":[1250,36]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"borrowed_ref","inner":{"lifetime":"'t","mutable":false,"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}}}},"0:101:1606":{"id":"0:101:1606","crate_id":0,"name":"compile","span":{"filename":"src/compile.rs","begin":[1,0],"end":[1264,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:173:1622"],"is_stripped":true}},"0:2044:2678":{"id":"0:2044:2678","crate_id":0,"name":"ExecNoSyncStr","span":{"filename":"src/exec.rs","begin":[62,0],"end":[62,45]},"visibility":"public","docs":"`ExecNoSyncStr` is like `ExecNoSync`, but matches on &str instead of &[u8].","links":{"u8":"1:16022:4453"},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'c","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:25":{"id":"0:25","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[633,4],"end":[633,13]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::Locations","name":"Locations","id":"0:1560:1591","glob":false}},"2:13072:3152":{"id":"2:13072:3152","crate_id":2,"name":"Searcher","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":["2:13074:3076","2:13075:922","2:13076:61832","2:13077:61833"],"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13509:63216":{"id":"2:13509:63216","crate_id":2,"name":"trim_end","span":null,"visibility":"public","docs":"Returns a string slice with trailing whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`, which includes newlines.\n\n# Text directionality\n\nA string is a sequence of bytes. `end` in this context means the last\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be right side, and for right-to-left languages like\nArabic or Hebrew, this will be the left side.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"\\n Hello\\tworld\\t\\n\";\nassert_eq!(\"\\n Hello\\tworld\", s.trim_end());\n```\n\nDirectionality:\n\n```\nlet s = \"  English  \";\nassert!(Some('h') == s.trim_end().chars().rev().next());\n\nlet s = \"  עברית  \";\nassert!(Some('ת') == s.trim_end().chars().rev().next());\n```","links":{},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"trim_direction\", since = \"1.30.0\")]","#[rustc_diagnostic_item = \"str_trim_end\"]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:13781:150":{"id":"2:13781:150","crate_id":2,"name":"IntoFuture","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:13782:181","2:13783:150","2:13784:767"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2226:1628":{"id":"0:2226:1628","crate_id":0,"name":"LiteralSearcher","span":{"filename":"src/literal/imp.rs","begin":[13,0],"end":[18,1]},"visibility":"public","docs":"A prefix extracted from a compiled regular expression.\n\nA regex prefix is a set of literal strings that *must* be matched at the\nbeginning of a regex in order for the entire regex to match. Similarly\nfor a regex suffix.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"1:7799:6170":{"id":"1:7799:6170","crate_id":1,"name":"Termination","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:7800:60718"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:8882:4658":{"id":"2:8882:4658","crate_id":2,"name":"TrustedLen","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Iterator","id":"2:8601:157","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:13416":{"id":"2:13416","crate_id":2,"name":null,"span":null,"visibility":{"restricted":{"parent":"2:12513:1338","path":"::str"}},"docs":null,"links":{},"attrs":["#[cfg(not(test))]"],"deprecation":null,"kind":"impl","inner":{"is_unsafe":false,"generics":{"params":[],"where_predicates":[]},"provided_trait_methods":[],"trait":null,"for":{"kind":"primitive","inner":"str"},"items":["2:13417:793","2:13418:1796","2:13419:13077","2:13420:63202","2:13422:63203","2:13425:2795","2:13426:63204","2:13427:304","2:13428:11324","2:13429:1807","2:13431:11313","2:13433:2395","2:13435:59268","2:13437:6120","2:13438:63205","2:13439:59287","2:13440:59288","2:13441:3197","2:13442:6403","2:13443:1602","2:13444:13288","2:13445:13286","2:13446:7000","2:13447:63206","2:13448:13028","2:13449:2415","2:13452:59302","2:13455:59303","2:13458:2518","2:13462:5380","2:13466:1910","2:13469:13287","2:13472:59297","2:13475:63207","2:13478:63208","2:13481:3703","2:13484:59300","2:13487:63209","2:13490:63210","2:13493:1754","2:13496:63211","2:13499:63212","2:13502:63213","2:13505:63214","2:13507:63215","2:13509:63216","2:13511:63217","2:13512:63218","2:13513:63219","2:13516:63220","2:13519:12683","2:13522:59304","2:13525:63221","2:13528:63222","2:13531:63223","2:13534:2760","2:13536:2020","2:13537:56934","2:13538:56935","2:13539:56936","2:13540:63224","2:13542:2585","2:13543:4770"],"negative":false,"synthetic":false,"blanket_impl":null}},"0:1758":{"id":"0:1758","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[765,43],"end":[765,53]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::prog::InstRanges","name":"InstRanges","id":"0:2440:1631","glob":false}},"0:1303:3777":{"id":"0:1303:3777","crate_id":0,"name":"no_expansion","span":{"filename":"src/re_bytes.rs","begin":[1128,4],"end":[1130,5]},"visibility":"default","docs":"Return a fixed unchanging replacement byte string.\n\nWhen doing replacements, if access to `Captures` is not needed (e.g.,\nthe replacement byte string does not need `$` expansion), then it can\nbe beneficial to avoid finding sub-captures.\n\nIn general, this is called once for every call to `replacen`.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'r","mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"resolved_path","inner":{"name":"Cow","id":"5:792:108","args":{"angle_bracketed":{"args":[{"lifetime":"'r"},{"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}}],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2269:1540":{"id":"0:2269:1540","crate_id":0,"name":"0","span":{"filename":"src/literal/imp.rs","begin":[227,11],"end":[227,24]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"slice","inner":{"kind":"resolved_path","inner":{"name":"Literal","id":"20:2951:1960","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}}},"0:46":{"id":"0:46","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[633,71],"end":[633,76]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::Split","name":"Split","id":"0:2993:1598","glob":false}},"0:2459:2771":{"id":"0:2459:2771","crate_id":0,"name":"nest_limit","span":{"filename":"src/re_builder.rs","begin":[8,4],"end":[8,23]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"u32"}},"0:2628:1593":{"id":"0:2628:1593","crate_id":0,"name":"Matches","span":{"filename":"src/re_bytes.rs","begin":[695,0],"end":[695,66]},"visibility":"public","docs":"An iterator over all non-overlapping matches for a particular string.\n\nThe iterator yields a tuple of integers corresponding to the start and end\nof the match. The indices are byte offsets. The iterator stops when no more\nmatches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched byte string.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}},{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:13496:63211":{"id":"2:13496:63211","crate_id":2,"name":"rmatches","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within this string slice,\nyielded in reverse order.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse\nsearch, and it will be a [`DoubleEndedIterator`] if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`matches`] method can be used.\n\n[`matches`]: str::matches\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\nassert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n\nlet v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\nassert_eq!(v, [\"3\", \"2\", \"1\"]);\n```","links":{"self::pattern":"2:13053:1578","`DoubleEndedIterator`":"2:8447:120","prim@char":"1:16005:4439","str::matches":"1:16011:4444"},"attrs":["#[stable(feature = \"str_matches\", since = \"1.2.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"RMatches","id":"2:49681:4897","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:744:1811":{"id":"0:744:1811","crate_id":0,"name":"is_empty_match","span":{"filename":"src/input.rs","begin":[83,4],"end":[83,73]},"visibility":"default","docs":"Return true if the given empty width instruction matches at the\ninput position given.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["at",{"kind":"resolved_path","inner":{"name":"InputAt","id":"0:2172:1627","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}],["empty",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"resolved_path","inner":{"name":"InstEmptyLook","id":"0:2398:1832","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"2:10539:146":{"id":"2:10539:146","crate_id":2,"name":"Hasher","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10540:652","2:10541:2634","2:10542:57230","2:10543:57231","2:10544:57232","2:10545:57233","2:10546:57234","2:10547:57235","2:10548:57236","2:10549:57237","2:10550:57238","2:10551:57239","2:10552:57240","2:10553:57241","2:10554:57242","2:10555:1531"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1068:1604":{"id":"0:1068:1604","crate_id":0,"name":"re_bytes","span":{"filename":"src/re_bytes.rs","begin":[1,0],"end":[1260,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2599:1592","0:2623:1595","0:2628:1593","0:2637:1588","0:2646:1598","0:2655:1599","0:2664:1589","0:2674:1587","0:1243:1590","0:2681:1600","0:1301:1596","0:2694:1597","0:2703:1594"],"is_stripped":true}},"0:702:1611":{"id":"0:702:1611","crate_id":0,"name":"input","span":{"filename":"src/input.rs","begin":[1,0],"end":[432,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2172:1627","0:740:148","0:2182:1626","0:2206:1625"],"is_stripped":true}},"2:13481:3703":{"id":"2:13481:3703","crate_id":2,"name":"splitn","span":null,"visibility":"public","docs":"An iterator over substrings of the given string slice, separated by a\npattern, restricted to returning at most `n` items.\n\nIf `n` substrings are returned, the last substring (the `n`th substring)\nwill contain the remainder of the string.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will not be double ended, because it is\nnot efficient to support.\n\nIf the pattern allows a reverse search, the [`rsplitn`] method can be\nused.\n\n[`rsplitn`]: str::rsplitn\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\nassert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\nassert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n\nlet v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\nassert_eq!(v, [\"abcXdef\"]);\n\nlet v: Vec<&str> = \"\".splitn(1, 'X').collect();\nassert_eq!(v, [\"\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"abc\", \"defXghi\"]);\n```","links":{"str::rsplitn":"1:16011:4444","self::pattern":"2:13053:1578","prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["n",{"kind":"primitive","inner":"usize"}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"SplitN","id":"2:49563:1599","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:13431:11313":{"id":"2:13431:11313","crate_id":2,"name":"get_mut","span":null,"visibility":"public","docs":"Returns a mutable subslice of `str`.\n\nThis is the non-panicking alternative to indexing the `str`. Returns\n[`None`] whenever equivalent indexing operation would panic.\n\n# Examples\n\n```\nlet mut v = String::from(\"hello\");\n// correct length\nassert!(v.get_mut(0..5).is_some());\n// out of bounds\nassert!(v.get_mut(..42).is_none());\nassert_eq!(Some(\"he\"), v.get_mut(0..2).map(|v| &*v));\n\nassert_eq!(\"hello\", v);\n{\n    let s = v.get_mut(0..2);\n    let s = s.map(|s| {\n        s.make_ascii_uppercase();\n        &*s\n    });\n    assert_eq!(Some(\"HE\"), s);\n}\nassert_eq!(\"HEllo\", v);\n```","links":{"`None`":"2:47492:176"},"attrs":["#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]","#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}],["i",{"kind":"generic","inner":"I"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"qualified_path","inner":{"name":"Output","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"I"},"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:10933:214","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}}}}}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"I"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:10933:214","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2182:1626":{"id":"0:2182:1626","crate_id":0,"name":"CharInput","span":{"filename":"src/input.rs","begin":[140,0],"end":[140,35]},"visibility":"public","docs":"An input reader over characters.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:13499:63212":{"id":"2:13499:63212","crate_id":2,"name":"match_indices","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within this string\nslice as well as the index that the match starts at.\n\nFor matches of `pat` within `self` that overlap, only the indices\ncorresponding to the first match are returned.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rmatch_indices`] method can be used.\n\n[`rmatch_indices`]: str::rmatch_indices\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\nassert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n\nlet v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\nassert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n\nlet v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\nassert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n```","links":{"prim@char":"1:16005:4439","self::pattern":"2:13053:1578","str::rmatch_indices":"1:16011:4444","`DoubleEndedIterator`":"2:8447:120"},"attrs":["#[stable(feature = \"str_match_indices\", since = \"1.5.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"MatchIndices","id":"2:49609:4895","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:3647:4858":{"id":"2:3647:4858","crate_id":2,"name":"RangeBounds","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3649:62434","2:3650:62435","2:3651:2415"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"T"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[],"implementations":[]}},"0:2367:1540":{"id":"0:2367:1540","crate_id":0,"name":"0","span":{"filename":"src/prog.rs","begin":[282,10],"end":[282,19]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"InstSplit","id":"0:2391:1834","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}},"2:13543:4770":{"id":"2:13543:4770","crate_id":2,"name":"escape_unicode","span":null,"visibility":"public","docs":"Return an iterator that escapes each char in `self` with [`char::escape_unicode`].\n\n# Examples\n\nAs an iterator:\n\n```\nfor c in \"❤\\n!\".escape_unicode() {\n    print!(\"{c}\");\n}\nprintln!();\n```\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"❤\\n!\".escape_unicode());\n```\n\n\nBoth are equivalent to:\n\n```\nprintln!(\"\\\\u{{2764}}\\\\u{{a}}\\\\u{{21}}\");\n```\n\nUsing `to_string`:\n\n```\nassert_eq!(\"❤\\n!\".escape_unicode().to_string(), \"\\\\u{2764}\\\\u{a}\\\\u{21}\");\n```","links":{"`char::escape_unicode`":"1:16005:4439"},"attrs":["#[must_use =\n\"this returns the escaped string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"str_escape\", since = \"1.34.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"EscapeUnicode","id":"2:49776:4891","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:23467:20180":{"id":"2:23467:20180","crate_id":2,"name":"SimdOrd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:23468:61549","2:23469:61548","2:23470:61550"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"SimdPartialOrd","id":"2:23462:6426","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"5:6103:63850":{"id":"5:6103:63850","crate_id":5,"name":"to_uppercase","span":null,"visibility":"public","docs":"Returns the uppercase equivalent of this string slice, as a new [`String`].\n\n'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n`Uppercase`.\n\nSince some characters can expand into multiple characters when changing\nthe case, this function returns a [`String`] instead of modifying the\nparameter in-place.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"hello\";\n\nassert_eq!(\"HELLO\", s.to_uppercase());\n```\n\nScripts without case are not changed:\n\n```\nlet new_year = \"农历新年\";\n\nassert_eq!(new_year, new_year.to_uppercase());\n```\n\nOne character can become multiple:\n```\nlet s = \"tschüß\";\n\nassert_eq!(\"TSCHÜSS\", s.to_uppercase());\n```","links":{"`String`":"5:8368:216"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n\"this returns the uppercase string as a new String, \\\n                  without modifying the original\"]","#[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2594:3557":{"id":"0:2594:3557","crate_id":0,"name":"RegexSetBuilder","span":{"filename":"src/re_builder.rs","begin":[421,0],"end":[421,47]},"visibility":"public","docs":"A configurable builder for a set of regular expressions.\n\nA builder can be used to configure how the regexes are built, for example,\nby setting the default flags (which can be overridden in the expression\nitself) or setting various limits.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"1:2576:127":{"id":"1:2576:127","crate_id":1,"name":"Error","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:2577:5753","1:2579:2630","1:2580:5754","1:2581:5755"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Debug","id":"2:10291:109","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Display","id":"2:10298:119","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:3341:4840":{"id":"2:3341:4840","crate_id":2,"name":"Sub","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3343:181","2:3344:1353"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:10310:5348":{"id":"2:10310:5348","crate_id":2,"name":"LowerExp","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10311:660"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2907:4123":{"id":"0:2907:4123","crate_id":0,"name":"SetMatchesIter","span":{"filename":"src/re_set.rs","begin":[480,0],"end":[507,1]},"visibility":"public","docs":"A borrowed iterator over the set of matches from a regex set.\n\nThe lifetime `'a` refers to the lifetime of a `SetMatches` value.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:22801:6526":{"id":"2:22801:6526","crate_id":2,"name":"SimdInt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:22802:6424","2:22803:61535","2:22804:1225","2:22805:1226","2:22806:45768","2:22807:62742","2:22808:13245","2:22809:62743","2:22810:62744","2:22811:61547","2:22812:61551","2:22813:61552","2:22814:61553","2:22815:61554","2:22816:62668","2:22817:62669","2:22818:62670"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Copy","id":"2:3278:106","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"2:22850:6017","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:2956:177":{"id":"2:2956:177","crate_id":2,"name":"Ord","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2957:415","2:2958:2045","2:2959:2043","2:2960:5374"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Eq","id":"2:2925:124","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"PartialOrd","id":"2:2966:184","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:2433:1831":{"id":"0:2433:1831","crate_id":0,"name":"InstChar","span":{"filename":"src/prog.rs","begin":[362,0],"end":[368,1]},"visibility":"public","docs":"Representation of the Char instruction.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":false,"fields":["0:2434:1808","0:2435:1812"],"impls":[]}},"2:3416:4851":{"id":"2:3416:4851","crate_id":2,"name":"Shr","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3418:181","2:3419:1234"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:10574:5526":{"id":"2:10574:5526","crate_id":2,"name":"BuildHasher","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10575:146","2:10576:12780","2:10577:58743"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2954:1592":{"id":"0:2954:1592","crate_id":0,"name":"Match","span":{"filename":"src/re_unicode.rs","begin":[29,0],"end":[33,1]},"visibility":"public","docs":"Match represents a single match of a regex in a haystack.\n\nThe lifetime parameter `'t` refers to the lifetime of the matched text.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:52":{"id":"0:52","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[634,12],"end":[634,29]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::SubCaptureMatches","name":"SubCaptureMatches","id":"0:3018:1600","glob":false}},"2:10308:189":{"id":"2:10308:189","crate_id":2,"name":"Pointer","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10309:660"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:3031:1588":{"id":"0:3031:1588","crate_id":0,"name":"CaptureMatches","span":{"filename":"src/re_unicode.rs","begin":[1117,0],"end":[1119,2]},"visibility":"public","docs":"An iterator that yields all non-overlapping capture groups matching a\nparticular regular expression.\n\nThe iterator stops when no more matches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched string.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}},{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:3336:4835":{"id":"2:3336:4835","crate_id":2,"name":"Add","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3338:181","2:3339:265"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2386:1773":{"id":"0:2386:1773","crate_id":0,"name":"slot","span":{"filename":"src/prog.rs","begin":[315,4],"end":[315,19]},"visibility":"public","docs":"The capture slot (there are two slots for every capture in a regex,\nincluding the zeroth capture for the entire match).","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"0:2261:3170":{"id":"0:2261:3170","crate_id":0,"name":"Single","span":{"filename":"src/literal/imp.rs","begin":[225,4],"end":[225,20]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}}}]}},"0:2655:1599":{"id":"0:2655:1599","crate_id":0,"name":"SplitN","span":{"filename":"src/re_bytes.rs","begin":[777,0],"end":[780,1]},"visibility":"public","docs":"Yields at most `N` substrings delimited by a regular expression match.\n\nThe last substring will be whatever remains after splitting.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the byte string being split.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}},{"name":"'t","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:2418:1992":{"id":"0:2418:1992","crate_id":0,"name":"WordBoundaryAscii","span":{"filename":"src/prog.rs","begin":[355,4],"end":[355,21]},"visibility":"default","docs":"ASCII word boundary.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"plain"}},"0:747:1796":{"id":"0:747:1796","crate_id":0,"name":"is_empty","span":{"filename":"src/input.rs","begin":[96,4],"end":[98,5]},"visibility":"default","docs":"Whether the input is empty.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:13507:63215":{"id":"2:13507:63215","crate_id":2,"name":"trim_start","span":null,"visibility":"public","docs":"Returns a string slice with leading whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`, which includes newlines.\n\n# Text directionality\n\nA string is a sequence of bytes. `start` in this context means the first\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be left side, and for right-to-left languages like\nArabic or Hebrew, this will be the right side.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"\\n Hello\\tworld\\t\\n\";\nassert_eq!(\"Hello\\tworld\\t\\n\", s.trim_start());\n```\n\nDirectionality:\n\n```\nlet s = \"  English  \";\nassert!(Some('E') == s.trim_start().chars().next());\n\nlet s = \"  עברית  \";\nassert!(Some('ע') == s.trim_start().chars().next());\n```","links":{},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"trim_direction\", since = \"1.30.0\")]","#[rustc_diagnostic_item = \"str_trim_start\"]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:3277:217":{"id":"2:3277:217","crate_id":2,"name":"StructuralEq","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1641:1596":{"id":"0:1641:1596","crate_id":0,"name":"Replacer","span":{"filename":"src/re_unicode.rs","begin":[1162,0],"end":[1207,1]},"visibility":"public","docs":"Replacer describes types that can be used to replace matches in a string.\n\nIn general, users of this crate shouldn't need to implement this trait,\nsince implementations are already provided for `&str` along with other\nvariants of string types and `FnMut(&Captures) -> String` (or any\n`FnMut(&Captures) -> T` where `T: AsRef<str>`), which covers most use cases.","links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["0:1642:3780","0:1643:3777","0:1645:3966"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:3383:4844":{"id":"2:3383:4844","crate_id":2,"name":"RemAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3385:1103"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13417:793":{"id":"2:13417:793","crate_id":2,"name":"len","span":null,"visibility":"public","docs":"Returns the length of `self`.\n\nThis length is in bytes, not [`char`]s or graphemes. In other words,\nit might not be what a human considers the length of the string.\n\n[`char`]: prim@char\n\n# Examples\n\nBasic usage:\n\n```\nlet len = \"foo\".len();\nassert_eq!(3, len);\n\nassert_eq!(\"ƒoo\".len(), 4); // fancy f!\nassert_eq!(\"ƒoo\".chars().count(), 3);\n```","links":{"prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_const_stable(feature = \"const_str_len\", since = \"1.39.0\")]","#[must_use]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"primitive","inner":"usize"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":true,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2343:1900":{"id":"0:2343:1900","crate_id":0,"name":"captures","span":{"filename":"src/prog.rs","begin":[27,4],"end":[27,37]},"visibility":"public","docs":"The ordered sequence of all capture groups extracted from the AST.\nUnnamed groups are `None`.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"Vec","id":"5:7780:234","args":{"angle_bracketed":{"args":[{"type":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}}},"0:2412:1982":{"id":"0:2412:1982","crate_id":0,"name":"EndText","span":{"filename":"src/prog.rs","begin":[349,4],"end":[349,11]},"visibility":"default","docs":"End of input.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"plain"}},"0:3068:2145":{"id":"0:3068:2145","crate_id":0,"name":"SparseSet","span":{"filename":"src/sparse.rs","begin":[16,0],"end":[25,1]},"visibility":"public","docs":"A sparse set used for representing ordered NFA states.\n\nThis supports constant time addition and membership testing. Clearing an\nentire set can also be done in constant time. Iteration yields elements\nin the order in which they were inserted.\n\nThe data structure is based on: https://research.swtch.com/sparse\nNote though that we don't actually use uninitialized memory. We generally\nreuse allocations, so the initial allocation cost is bareable. However,\nits other properties listed above are extremely useful.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:2341:1842":{"id":"0:2341:1842","crate_id":0,"name":"insts","span":{"filename":"src/prog.rs","begin":[20,4],"end":[20,24]},"visibility":"public","docs":"A sequence of instructions that represents an NFA.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"Vec","id":"5:7780:234","args":{"angle_bracketed":{"args":[{"type":{"kind":"resolved_path","inner":{"name":"Inst","id":"0:2358:1630","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}}},"0:2354:1795":{"id":"0:2354:1795","crate_id":0,"name":"prefixes","span":{"filename":"src/prog.rs","begin":[58,4],"end":[58,33]},"visibility":"public","docs":"A possibly empty machine for very quickly matching prefix literals.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"LiteralSearcher","id":"0:2226:1628","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}},"0:1755":{"id":"0:1755","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[765,37],"end":[765,41]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::prog::Inst","name":"Inst","id":"0:2358:1630","glob":false}},"0:2788:2908":{"id":"0:2788:2908","crate_id":0,"name":"RegexSet","span":{"filename":"src/re_set.rs","begin":[451,0],"end":[478,1]},"visibility":"public","docs":"Match multiple (possibly overlapping) regular expressions in a single scan.\n\nA regex set corresponds to the union of two or more regular expressions.\nThat is, a regex set will match text where at least one of its\nconstituent regular expressions matches. A regex set as its formulated here\nprovides a touch more power: it will also report *which* regular\nexpressions in the set match. Indeed, this is the key difference between\nregex sets and a single `Regex` with many alternates, since only one\nalternate can match at a time.\n\nFor example, consider regular expressions to match email addresses and\ndomains: `[a-z]+@[a-z]+\\.(com|org|net)` and `[a-z]+\\.(com|org|net)`. If a\nregex set is constructed from those regexes, then searching the text\n`foo@example.com` will report both regexes as matching. Of course, one\ncould accomplish this by compiling each regex on its own and doing two\nsearches over the text. The key advantage of using a regex set is that it\nwill report the matching regexes using a *single pass through the text*.\nIf one has hundreds or thousands of regexes to match repeatedly (like a URL\nrouter for a complex web application or a user agent matcher), then a regex\nset can realize huge performance gains.\n\n# Example\n\nThis shows how the above two regexes (for matching email addresses and\ndomains) might work:\n\n ```rust\n # use regex::RegexSet;\n let set = RegexSet::new(&[\n     r\"[a-z]+@[a-z]+\\.(com|org|net)\",\n     r\"[a-z]+\\.(com|org|net)\",\n ]).unwrap();\n\n // Ask whether any regexes in the set match.\n assert!(set.is_match(\"foo@example.com\"));\n\n // Identify which regexes in the set match.\n let matches: Vec<_> = set.matches(\"foo@example.com\").into_iter().collect();\n assert_eq!(vec![0, 1], matches);\n\n // Try again, but with text that only matches one of the regexes.\n let matches: Vec<_> = set.matches(\"example.com\").into_iter().collect();\n assert_eq!(vec![1], matches);\n\n // Try again, but with text that doesn't match any regex in the set.\n let matches: Vec<_> = set.matches(\"example\").into_iter().collect();\n assert!(matches.is_empty());\n ```\n\nNote that it would be possible to adapt the above example to using `Regex`\nwith an expression like:\n\n```text\n(?P<email>[a-z]+@(?P<email_domain>[a-z]+[.](com|org|net)))|(?P<domain>[a-z]+[.](com|org|net))\n```\n\nAfter a match, one could then inspect the capture groups to figure out\nwhich alternates matched. The problem is that it is hard to make this\napproach scale when there are many regexes since the overlap between each\nalternate isn't always obvious to reason about.\n\n# Limitations\n\nRegex sets are limited to answering the following two questions:\n\n1. Does any regex in the set match?\n2. If so, which regexes in the set match?\n\nAs with the main [`Regex`][crate::Regex] type, it is cheaper to ask (1)\ninstead of (2) since the matching engines can stop after the first match\nis found.\n\nYou cannot directly extract [`Match`][crate::Match] or\n[`Captures`][crate::Captures] objects from a regex set. If you need these\noperations, the recommended approach is to compile each pattern in the set\nindependently and scan the exact same input a second time with those\nindependently compiled patterns:\n\n```rust\nuse regex::{Regex, RegexSet};\n\nlet patterns = [\"foo\", \"bar\"];\n// Both patterns will match different ranges of this string.\nlet text = \"barfoo\";\n\n// Compile a set matching any of our patterns.\nlet set = RegexSet::new(&patterns).unwrap();\n// Compile each pattern independently.\nlet regexes: Vec<_> = set.patterns().iter()\n    .map(|pat| Regex::new(pat).unwrap())\n    .collect();\n\n// Match against the whole set first and identify the individual\n// matching patterns.\nlet matches: Vec<&str> = set.matches(text).into_iter()\n    // Dereference the match index to get the corresponding\n    // compiled pattern.\n    .map(|match_idx| &regexes[match_idx])\n    // To get match locations or any other info, we then have to search\n    // the exact same text again, using our separately-compiled pattern.\n    .map(|pat| pat.find(text).unwrap().as_str())\n    .collect();\n\n// Matches arrive in the order the constituent patterns were declared,\n// not the order they appear in the input.\nassert_eq!(vec![\"foo\", \"bar\"], matches);\n```\n\n# Performance\n\nA `RegexSet` has the same performance characteristics as `Regex`. Namely,\nsearch takes `O(mn)` time, where `m` is proportional to the size of the\nregex set and `n` is proportional to the length of the search text.","links":{"crate::Match":"0:2954:1592","crate::Captures":"0:1565:1590","crate::Regex":"0:2978:1595"},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:2352:1897":{"id":"0:2352:1897","crate_id":0,"name":"is_anchored_end","span":{"filename":"src/prog.rs","begin":[54,4],"end":[54,29]},"visibility":"public","docs":"Whether the regex must match at the end of the input.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"2:13519:12683":{"id":"2:13519:12683","crate_id":2,"name":"strip_prefix","span":null,"visibility":"public","docs":"Returns a string slice with the prefix removed.\n\nIf the string starts with the pattern `prefix`, returns substring after the prefix, wrapped\nin `Some`.  Unlike `trim_start_matches`, this method removes the prefix exactly once.\n\nIf the string does not start with `prefix`, returns `None`.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\n```\nassert_eq!(\"foo:bar\".strip_prefix(\"foo:\"), Some(\"bar\"));\nassert_eq!(\"foo:bar\".strip_prefix(\"bar\"), None);\nassert_eq!(\"foofoo\".strip_prefix(\"foo\"), Some(\"foo\"));\n```","links":{"self::pattern":"2:13053:1578","prim@char":"1:16005:4439"},"attrs":["#[must_use =\n\"this returns the remaining substring as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"str_strip\", since = \"1.45.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["prefix",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2694:1597":{"id":"0:2694:1597","crate_id":0,"name":"ReplacerRef","span":{"filename":"src/re_bytes.rs","begin":[1162,0],"end":[1162,49]},"visibility":"public","docs":"By-reference adaptor for a `Replacer`\n\nReturned by [`Replacer::by_ref`](trait.Replacer.html#method.by_ref).","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"R","kind":{"type":{"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"default":null,"synthetic":false}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:1373:2797":{"id":"0:1373:2797","crate_id":0,"name":"is_match_at","span":{"filename":"src/re_trait.rs","begin":[132,4],"end":[132,67]},"visibility":"default","docs":"Returns whether the regex matches the text given.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["text",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"qualified_path","inner":{"name":"Text","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"Self"},"trait":{"kind":"resolved_path","inner":{"name":"","id":"0:1367:2655","args":null,"param_names":[]}}}}}}],["start",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"0:1305:3966":{"id":"0:1305:3966","crate_id":0,"name":"by_ref","span":{"filename":"src/re_bytes.rs","begin":[1153,4],"end":[1155,5]},"visibility":"default","docs":"Return a `Replacer` that borrows and wraps this `Replacer`.\n\nThis is useful when you want to take a generic `Replacer` (which might\nnot be cloneable) and use it without consuming it, so it can be used\nmore than once.\n\n# Example\n\n```\nuse regex::bytes::{Regex, Replacer};\n\nfn replace_all_twice<R: Replacer>(\n    re: Regex,\n    src: &[u8],\n    mut rep: R,\n) -> Vec<u8> {\n    let dst = re.replace_all(src, rep.by_ref());\n    let dst = re.replace_all(&dst, rep.by_ref());\n    dst.into_owned()\n}\n```","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'r","mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"ReplacerRef","id":"0:2694:1597","args":{"angle_bracketed":{"args":[{"lifetime":"'r"},{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:13490:63210":{"id":"2:13490:63210","crate_id":2,"name":"rsplit_once","span":null,"visibility":"public","docs":"Splits the string on the last occurrence of the specified delimiter and\nreturns prefix before delimiter and suffix after delimiter.\n\n# Examples\n\n```\nassert_eq!(\"cfg\".rsplit_once('='), None);\nassert_eq!(\"cfg=foo\".rsplit_once('='), Some((\"cfg\", \"foo\")));\nassert_eq!(\"cfg=foo=bar\".rsplit_once('='), Some((\"cfg=foo\", \"bar\")));\n```","links":{},"attrs":["#[stable(feature = \"str_split_once\", since = \"1.52.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["delimiter",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"tuple","inner":[{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}}]}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"kind":"qualified_path","inner":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:13063:4876","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2533:1603":{"id":"0:2533:1603","crate_id":0,"name":"set_bytes","span":{"filename":"src/re_builder.rs","begin":[420,0],"end":[420,44]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2561:3557"],"is_stripped":false}},"5:6107:56933":{"id":"5:6107:56933","crate_id":5,"name":"to_ascii_lowercase","span":null,"visibility":"public","docs":"Returns a copy of this string where each character is mapped to its\nASCII lower case equivalent.\n\nASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\nbut non-ASCII letters are unchanged.\n\nTo lowercase the value in-place, use [`make_ascii_lowercase`].\n\nTo lowercase ASCII characters in addition to non-ASCII characters, use\n[`to_lowercase`].\n\n# Examples\n\n```\nlet s = \"Grüße, Jürgen ❤\";\n\nassert_eq!(\"grüße, jürgen ❤\", s.to_ascii_lowercase());\n```\n\n[`make_ascii_lowercase`]: str::make_ascii_lowercase\n[`to_lowercase`]: #method.to_lowercase","links":{"str::make_ascii_lowercase":"1:16011:4444"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use = \"to lowercase the value in-place, use `make_ascii_lowercase()`\"]","#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:2462:2767":{"id":"0:2462:2767","crate_id":0,"name":"dot_matches_new_line","span":{"filename":"src/re_builder.rs","begin":[11,4],"end":[11,34]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"0:2359:1592":{"id":"0:2359:1592","crate_id":0,"name":"Match","span":{"filename":"src/prog.rs","begin":[276,4],"end":[276,16]},"visibility":"default","docs":"Match indicates that the program has reached a match state.\n\nThe number in the match corresponds to the Nth logical regular\nexpression in this program. This index is always 0 for normal regex\nprograms. Values greater than 0 appear when compiling regex sets, and\neach match instruction gets its own unique value. The value corresponds\nto the Nth regex in the set.","links":{},"attrs":[],"deprecation":null,"kind":"variant","inner":{"variant_kind":"tuple","variant_inner":[{"kind":"primitive","inner":"usize"}]}},"2:13083:4875":{"id":"2:13083:4875","crate_id":2,"name":"DoubleEndedSearcher","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:13078:4877","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:2379:1540":{"id":"0:2379:1540","crate_id":0,"name":"0","span":{"filename":"src/prog.rs","begin":[295,10],"end":[295,19]},"visibility":"default","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"InstBytes","id":"0:2447:1830","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}},"0:1301:1596":{"id":"0:1301:1596","crate_id":0,"name":"Replacer","span":{"filename":"src/re_bytes.rs","begin":[1111,0],"end":[1156,1]},"visibility":"public","docs":"Replacer describes types that can be used to replace matches in a byte\nstring.\n\nIn general, users of this crate shouldn't need to implement this trait,\nsince implementations are already provided for `&[u8]` along with other\nvariants of bytes types and `FnMut(&Captures) -> Vec<u8>` (or any\n`FnMut(&Captures) -> T` where `T: AsRef<[u8]>`), which covers most use cases.","links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["0:1302:3780","0:1303:3777","0:1305:3966"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2902:4124":{"id":"0:2902:4124","crate_id":0,"name":"SetMatchesIntoIter","span":{"filename":"src/re_set.rs","begin":[480,0],"end":[507,1]},"visibility":"public","docs":"An owned iterator over the set of matches from a regex set.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:1742":{"id":"0:1742","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[763,44],"end":[763,49]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::input::Input","name":"Input","id":"0:740:148","glob":false}},"0:58":{"id":"0:58","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[728,4],"end":[728,31]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::re_bytes","name":"re_bytes","id":"0:1068:1604","glob":true}},"0:1375:2799":{"id":"0:1375:2799","crate_id":0,"name":"captures_read_at","span":{"filename":"src/re_trait.rs","begin":[143,4],"end":[148,32]},"visibility":"default","docs":"Returns the leftmost-first match location if one exists, and also\nfills in any matching capture slot locations.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["locs",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"resolved_path","inner":{"name":"Locations","id":"0:2917:1591","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}],["text",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"qualified_path","inner":{"name":"Text","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"Self"},"trait":{"kind":"resolved_path","inner":{"name":"","id":"0:1367:2655","args":null,"param_names":[]}}}}}}],["start",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:47492:176","args":{"angle_bracketed":{"args":[{"type":{"kind":"tuple","inner":[{"kind":"primitive","inner":"usize"},{"kind":"primitive","inner":"usize"}]}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"0:2924:3566":{"id":"0:2924:3566","crate_id":0,"name":"SubCapturesPosIter","span":{"filename":"src/re_trait.rs","begin":[58,0],"end":[61,1]},"visibility":"public","docs":"An iterator over capture group positions for a particular match of a\nregular expression.\n\nPositions are byte indices in terms of the original string matched.\n\n`'c` is the lifetime of the captures.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[{"name":"'c","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:1725":{"id":"0:1725","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[761,4],"end":[761,37]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::compile::Compiler","name":"Compiler","id":"0:173:1622","glob":false}},"0:2344:1845":{"id":"0:2344:1845","crate_id":0,"name":"capture_name_idx","span":{"filename":"src/prog.rs","begin":[29,4],"end":[29,53]},"visibility":"public","docs":"Pointers to all named capture groups into `captures`.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"resolved_path","inner":{"name":"Arc","id":"5:6652:69","args":{"angle_bracketed":{"args":[{"type":{"kind":"resolved_path","inner":{"name":"HashMap","id":"1:1306:143","args":{"angle_bracketed":{"args":[{"type":{"kind":"resolved_path","inner":{"name":"String","id":"5:8368:216","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}},{"type":{"kind":"primitive","inner":"usize"}}],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}}},"0:2502:1557":{"id":"0:2502:1557","crate_id":0,"name":"unicode","span":{"filename":"src/re_builder.rs","begin":[232,0],"end":[232,42]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2528:3477"],"is_stripped":false}},"0:2890:2908":{"id":"0:2890:2908","crate_id":0,"name":"RegexSet","span":{"filename":"src/re_set.rs","begin":[480,0],"end":[507,1]},"visibility":"public","docs":"Match multiple (possibly overlapping) regular expressions in a single scan.\n\nA regex set corresponds to the union of two or more regular expressions.\nThat is, a regex set will match text where at least one of its\nconstituent regular expressions matches. A regex set as its formulated here\nprovides a touch more power: it will also report *which* regular\nexpressions in the set match. Indeed, this is the key difference between\nregex sets and a single `Regex` with many alternates, since only one\nalternate can match at a time.\n\nFor example, consider regular expressions to match email addresses and\ndomains: `[a-z]+@[a-z]+\\.(com|org|net)` and `[a-z]+\\.(com|org|net)`. If a\nregex set is constructed from those regexes, then searching the text\n`foo@example.com` will report both regexes as matching. Of course, one\ncould accomplish this by compiling each regex on its own and doing two\nsearches over the text. The key advantage of using a regex set is that it\nwill report the matching regexes using a *single pass through the text*.\nIf one has hundreds or thousands of regexes to match repeatedly (like a URL\nrouter for a complex web application or a user agent matcher), then a regex\nset can realize huge performance gains.\n\n# Example\n\nThis shows how the above two regexes (for matching email addresses and\ndomains) might work:\n\n ```rust\n # use regex::bytes::RegexSet;\n let set = RegexSet::new(&[\n     r\"[a-z]+@[a-z]+\\.(com|org|net)\",\n     r\"[a-z]+\\.(com|org|net)\",\n ]).unwrap();\n\n // Ask whether any regexes in the set match.\n assert!(set.is_match(b\"foo@example.com\"));\n\n // Identify which regexes in the set match.\n let matches: Vec<_> = set.matches(b\"foo@example.com\").into_iter().collect();\n assert_eq!(vec![0, 1], matches);\n\n // Try again, but with text that only matches one of the regexes.\n let matches: Vec<_> = set.matches(b\"example.com\").into_iter().collect();\n assert_eq!(vec![1], matches);\n\n // Try again, but with text that doesn't match any regex in the set.\n let matches: Vec<_> = set.matches(b\"example\").into_iter().collect();\n assert!(matches.is_empty());\n ```\n\nNote that it would be possible to adapt the above example to using `Regex`\nwith an expression like:\n\n```text\n(?P<email>[a-z]+@(?P<email_domain>[a-z]+[.](com|org|net)))|(?P<domain>[a-z]+[.](com|org|net))\n```\n\nAfter a match, one could then inspect the capture groups to figure out\nwhich alternates matched. The problem is that it is hard to make this\napproach scale when there are many regexes since the overlap between each\nalternate isn't always obvious to reason about.\n\n# Limitations\n\nRegex sets are limited to answering the following two questions:\n\n1. Does any regex in the set match?\n2. If so, which regexes in the set match?\n\nAs with the main [`Regex`][crate::Regex] type, it is cheaper to ask (1)\ninstead of (2) since the matching engines can stop after the first match\nis found.\n\nYou cannot directly extract [`Match`][crate::Match] or\n[`Captures`][crate::Captures] objects from a regex set. If you need these\noperations, the recommended approach is to compile each pattern in the set\nindependently and scan the exact same input a second time with those\nindependently compiled patterns:\n\n```rust\nuse regex::{Regex, RegexSet};\n\nlet patterns = [\"foo\", \"bar\"];\n// Both patterns will match different ranges of this string.\nlet text = \"barfoo\";\n\n// Compile a set matching any of our patterns.\nlet set = RegexSet::new(&patterns).unwrap();\n// Compile each pattern independently.\nlet regexes: Vec<_> = set.patterns().iter()\n    .map(|pat| Regex::new(pat).unwrap())\n    .collect();\n\n// Match against the whole set first and identify the individual\n// matching patterns.\nlet matches: Vec<&str> = set.matches(text).into_iter()\n    // Dereference the match index to get the corresponding\n    // compiled pattern.\n    .map(|match_idx| &regexes[match_idx])\n    // To get match locations or any other info, we then have to search\n    // the exact same text again, using our separately-compiled pattern.\n    .map(|pat| pat.find(text).unwrap().as_str())\n    .collect();\n\n// Matches arrive in the order the constituent patterns were declared,\n// not the order they appear in the input.\nassert_eq!(vec![\"foo\", \"bar\"], matches);\n```\n\n# Performance\n\nA `RegexSet` has the same performance characteristics as `Regex`. Namely,\nsearch takes `O(mn)` time, where `m` is proportional to the size of the\nregex set and `n` is proportional to the length of the search text.","links":{"crate::Regex":"0:2978:1595","crate::Match":"0:2954:1592","crate::Captures":"0:1565:1590"},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"tuple","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"2:3246:115":{"id":"2:3246:115","crate_id":2,"name":"Default","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3247:59"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13418:1796":{"id":"2:13418:1796","crate_id":2,"name":"is_empty","span":null,"visibility":"public","docs":"Returns `true` if `self` has a length of zero bytes.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"\";\nassert!(s.is_empty());\n\nlet s = \"not empty\";\nassert!(!s.is_empty());\n```","links":{},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_const_stable(feature = \"const_str_is_empty\", since = \"1.39.0\")]","#[must_use]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":true,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:1645:3966":{"id":"0:1645:3966","crate_id":0,"name":"by_ref","span":{"filename":"src/re_unicode.rs","begin":[1204,4],"end":[1206,5]},"visibility":"default","docs":"Return a `Replacer` that borrows and wraps this `Replacer`.\n\nThis is useful when you want to take a generic `Replacer` (which might\nnot be cloneable) and use it without consuming it, so it can be used\nmore than once.\n\n# Example\n\n```\nuse regex::{Regex, Replacer};\n\nfn replace_all_twice<R: Replacer>(\n    re: Regex,\n    src: &str,\n    mut rep: R,\n) -> String {\n    let dst = re.replace_all(src, rep.by_ref());\n    let dst = re.replace_all(&dst, rep.by_ref());\n    dst.into_owned()\n}\n```","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'r","mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"ReplacerRef","id":"0:3049:1597","args":{"angle_bracketed":{"args":[{"lifetime":"'r"},{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'r","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"1:4752:6043":{"id":"1:4752:6043","crate_id":1,"name":"BufRead","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:4753:60808","1:4754:60809","1:4755:60810","1:4757:6042","1:4758:60811","1:4760:1910","1:4761:7000"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Read","id":"1:4670:6018","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"2:13433:2395":{"id":"2:13433:2395","crate_id":2,"name":"get_unchecked","span":null,"visibility":"public","docs":"Returns an unchecked subslice of `str`.\n\nThis is the unchecked alternative to indexing the `str`.\n\n# Safety\n\nCallers of this function are responsible that these preconditions are\nsatisfied:\n\n* The starting index must not exceed the ending index;\n* Indexes must be within bounds of the original slice;\n* Indexes must lie on UTF-8 sequence boundaries.\n\nFailing that, the returned string slice may reference invalid memory or\nviolate the invariants communicated by the `str` type.\n\n# Examples\n\n```\nlet v = \"🗻∈🌏\";\nunsafe {\n    assert_eq!(\"🗻\", v.get_unchecked(0..4));\n    assert_eq!(\"∈\", v.get_unchecked(4..7));\n    assert_eq!(\"🌏\", v.get_unchecked(7..11));\n}\n```","links":{},"attrs":["#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]","#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["i",{"kind":"generic","inner":"I"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"qualified_path","inner":{"name":"Output","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"kind":"generic","inner":"I"},"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:10933:214","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}}}}}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"I"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:10933:214","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":true,"async":false,"abi":"Rust"},"has_body":true}},"2:13446:7000":{"id":"2:13446:7000","crate_id":2,"name":"lines","span":null,"visibility":"public","docs":"An iterator over the lines of a string, as string slices.\n\nLines are ended with either a newline (`\\n`) or a carriage return with\na line feed (`\\r\\n`).\n\nThe final line ending is optional. A string that ends with a final line\nending will return the same lines as an otherwise identical string\nwithout a final line ending.\n\n# Examples\n\nBasic usage:\n\n```\nlet text = \"foo\\r\\nbar\\n\\nbaz\\n\";\nlet mut lines = text.lines();\n\nassert_eq!(Some(\"foo\"), lines.next());\nassert_eq!(Some(\"bar\"), lines.next());\nassert_eq!(Some(\"\"), lines.next());\nassert_eq!(Some(\"baz\"), lines.next());\n\nassert_eq!(None, lines.next());\n```\n\nThe final line ending isn't required:\n\n```\nlet text = \"foo\\nbar\\n\\r\\nbaz\";\nlet mut lines = text.lines();\n\nassert_eq!(Some(\"foo\"), lines.next());\nassert_eq!(Some(\"bar\"), lines.next());\nassert_eq!(Some(\"\"), lines.next());\nassert_eq!(Some(\"baz\"), lines.next());\n\nassert_eq!(None, lines.next());\n```","links":{},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"Lines","id":"2:49713:4893","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:22874:6512":{"id":"2:22874:6512","crate_id":2,"name":"SimdPartialEq","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:22875:6424","2:22876:1245","2:22877:1270"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13444:13288":{"id":"2:13444:13288","crate_id":2,"name":"split_whitespace","span":null,"visibility":"public","docs":"Splits a string slice by whitespace.\n\nThe iterator returned will return string slices that are sub-slices of\nthe original string slice, separated by any amount of whitespace.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`. If you only want to split on ASCII whitespace\ninstead, use [`split_ascii_whitespace`].\n\n[`split_ascii_whitespace`]: str::split_ascii_whitespace\n\n# Examples\n\nBasic usage:\n\n```\nlet mut iter = \"A few words\".split_whitespace();\n\nassert_eq!(Some(\"A\"), iter.next());\nassert_eq!(Some(\"few\"), iter.next());\nassert_eq!(Some(\"words\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\nAll kinds of whitespace are considered:\n\n```\nlet mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\nassert_eq!(Some(\"Mary\"), iter.next());\nassert_eq!(Some(\"had\"), iter.next());\nassert_eq!(Some(\"a\"), iter.next());\nassert_eq!(Some(\"little\"), iter.next());\nassert_eq!(Some(\"lamb\"), iter.next());\n\nassert_eq!(None, iter.next());\n```","links":{"str::split_ascii_whitespace":"1:16011:4444"},"attrs":["#[must_use =\n\"this returns the split string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]","#[rustc_diagnostic_item = \"str_split_whitespace\"]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"SplitWhitespace","id":"2:49733:4883","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"0:34":{"id":"0:34","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[633,31],"end":[633,39]},"visibility":"public","docs":null,"links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"import","inner":{"source":"crate::re_unicode::NoExpand","name":"NoExpand","id":"0:3058:1594","glob":false}},"2:4782:5492":{"id":"2:4782:5492","crate_id":2,"name":"AsyncIterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:4783:2027","2:4784:61764","2:4785:3841"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"1:5731:6003":{"id":"1:5731:6003","crate_id":1,"name":"PermissionsExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5732:8272","1:5733:57383","1:5734:57384"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:8362:4662":{"id":"2:8362:4662","crate_id":2,"name":"Sum","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:8364:3463"],"generics":{"params":[{"name":"A","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:2464:2769":{"id":"0:2464:2769","crate_id":0,"name":"ignore_whitespace","span":{"filename":"src/re_builder.rs","begin":[13,4],"end":[13,31]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"bool"}},"0:56":{"id":"0:56","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[726,4],"end":[726,40]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"import","inner":{"source":"crate::re_builder::bytes","name":"bytes","id":"0:2471:1602","glob":true}},"0:55:1602":{"id":"0:55:1602","crate_id":0,"name":"bytes","span":{"filename":"src/lib.rs","begin":[725,0],"end":[725,13]},"visibility":"public","docs":"Match regular expressions on arbitrary bytes.\n\nThis module provides a nearly identical API to the one found in the\ntop-level of this crate. There are two important differences:\n\n1. Matching is done on `&[u8]` instead of `&str`. Additionally, `Vec<u8>`\nis used where `String` would have been used.\n2. Unicode support can be disabled even when disabling it would result in\nmatching invalid UTF-8 bytes.\n\n# Example: match null terminated string\n\nThis shows how to find all null-terminated strings in a slice of bytes:\n\n```rust\n# use regex::bytes::Regex;\nlet re = Regex::new(r\"(?-u)(?P<cstr>[^\\x00]+)\\x00\").unwrap();\nlet text = b\"foo\\x00bar\\x00baz\\x00\";\n\n// Extract all of the strings without the null terminator from each match.\n// The unwrap is OK here since a match requires the `cstr` capture to match.\nlet cstrs: Vec<&[u8]> =\n    re.captures_iter(text)\n      .map(|c| c.name(\"cstr\").unwrap().as_bytes())\n      .collect();\nassert_eq!(vec![&b\"foo\"[..], &b\"bar\"[..], &b\"baz\"[..]], cstrs);\n```\n\n# Example: selectively enable Unicode support\n\nThis shows how to match an arbitrary byte pattern followed by a UTF-8 encoded\nstring (e.g., to extract a title from a Matroska file):\n\n```rust\n# use std::str;\n# use regex::bytes::Regex;\nlet re = Regex::new(\n    r\"(?-u)\\x7b\\xa9(?:[\\x80-\\xfe]|[\\x40-\\xff].)(?u:(.*))\"\n).unwrap();\nlet text = b\"\\x12\\xd0\\x3b\\x5f\\x7b\\xa9\\x85\\xe2\\x98\\x83\\x80\\x98\\x54\\x76\\x68\\x65\";\nlet caps = re.captures(text).unwrap();\n\n// Notice that despite the `.*` at the end, it will only match valid UTF-8\n// because Unicode mode was enabled with the `u` flag. Without the `u` flag,\n// the `.*` would match the rest of the bytes.\nlet mat = caps.get(1).unwrap();\nassert_eq!((7, 10), (mat.start(), mat.end()));\n\n// If there was a match, Unicode mode guarantees that `title` is valid UTF-8.\nlet title = str::from_utf8(&caps[1]).unwrap();\nassert_eq!(\"☃\", title);\n```\n\nIn general, if the Unicode flag is enabled in a capture group and that capture\nis part of the overall match, then the capture is *guaranteed* to be valid\nUTF-8.\n\n# Syntax\n\nThe supported syntax is pretty much the same as the syntax for Unicode\nregular expressions with a few changes that make sense for matching arbitrary\nbytes:\n\n1. The `u` flag can be disabled even when disabling it might cause the regex to\nmatch invalid UTF-8. When the `u` flag is disabled, the regex is said to be in\n\"ASCII compatible\" mode.\n2. In ASCII compatible mode, neither Unicode scalar values nor Unicode\ncharacter classes are allowed.\n3. In ASCII compatible mode, Perl character classes (`\\w`, `\\d` and `\\s`)\nrevert to their typical ASCII definition. `\\w` maps to `[[:word:]]`, `\\d` maps\nto `[[:digit:]]` and `\\s` maps to `[[:space:]]`.\n4. In ASCII compatible mode, word boundaries use the ASCII compatible `\\w` to\ndetermine whether a byte is a word byte or not.\n5. Hexadecimal notation can be used to specify arbitrary bytes instead of\nUnicode codepoints. For example, in ASCII compatible mode, `\\xFF` matches the\nliteral byte `\\xFF`, while in Unicode mode, `\\xFF` is a Unicode codepoint that\nmatches its UTF-8 encoding of `\\xC3\\xBF`. Similarly for octal notation when\nenabled.\n6. In ASCII compatible mode, `.` matches any *byte* except for `\\n`. When the\n`s` flag is additionally enabled, `.` matches any byte.\n\n# Performance\n\nIn general, one should expect performance on `&[u8]` to be roughly similar to\nperformance on `&str`.","links":{},"attrs":["#[cfg(feature = \"std\")]"],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:56","0:57","0:58","0:59"],"is_stripped":false}},"2:13441:3197":{"id":"2:13441:3197","crate_id":2,"name":"chars","span":null,"visibility":"public","docs":"Returns an iterator over the [`char`]s of a string slice.\n\nAs a string slice consists of valid UTF-8, we can iterate through a\nstring slice by [`char`]. This method returns such an iterator.\n\nIt's important to remember that [`char`] represents a Unicode Scalar\nValue, and might not match your idea of what a 'character' is. Iteration\nover grapheme clusters may be what you actually want. This functionality\nis not provided by Rust's standard library, check crates.io instead.\n\n# Examples\n\nBasic usage:\n\n```\nlet word = \"goodbye\";\n\nlet count = word.chars().count();\nassert_eq!(7, count);\n\nlet mut chars = word.chars();\n\nassert_eq!(Some('g'), chars.next());\nassert_eq!(Some('o'), chars.next());\nassert_eq!(Some('o'), chars.next());\nassert_eq!(Some('d'), chars.next());\nassert_eq!(Some('b'), chars.next());\nassert_eq!(Some('y'), chars.next());\nassert_eq!(Some('e'), chars.next());\n\nassert_eq!(None, chars.next());\n```\n\nRemember, [`char`]s might not match your intuition about characters:\n\n[`char`]: prim@char\n\n```\nlet y = \"y̆\";\n\nlet mut chars = y.chars();\n\nassert_eq!(Some('y'), chars.next()); // not 'y̆'\nassert_eq!(Some('\\u{0306}'), chars.next());\n\nassert_eq!(None, chars.next());\n```","links":{"prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"Chars","id":"2:49429:4886","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:2966:184":{"id":"2:2966:184","crate_id":2,"name":"PartialOrd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2968:997","2:2969:826","2:2970:792","2:2971:713","2:2972:696"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"},"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"kind":"generic","inner":"Rhs"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3273:3969","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}],"generic_params":[]}}]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"PartialEq","id":"2:2920:183","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Rhs"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:2441:1808":{"id":"0:2441:1808","crate_id":0,"name":"goto","span":{"filename":"src/prog.rs","begin":[375,4],"end":[375,21]},"visibility":"public","docs":"The next location to execute in the program if this instruction\nsucceeds.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"2:9258:3249":{"id":"2:9258:3249","crate_id":2,"name":"UnwindSafe","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":true,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"2:13437:6120":{"id":"2:13437:6120","crate_id":2,"name":"slice_unchecked","span":null,"visibility":"public","docs":"Creates a string slice from another string slice, bypassing safety\nchecks.\n\nThis is generally not recommended, use with caution! For a safe\nalternative see [`str`] and [`Index`].\n\n[`Index`]: crate::ops::Index\n\nThis new slice goes from `begin` to `end`, including `begin` but\nexcluding `end`.\n\nTo get a mutable string slice instead, see the\n[`slice_mut_unchecked`] method.\n\n[`slice_mut_unchecked`]: str::slice_mut_unchecked\n\n# Safety\n\nCallers of this function are responsible that three preconditions are\nsatisfied:\n\n* `begin` must not exceed `end`.\n* `begin` and `end` must be byte positions within the string slice.\n* `begin` and `end` must lie on UTF-8 sequence boundaries.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"Löwe 老虎 Léopard\";\n\nunsafe {\n    assert_eq!(\"Löwe 老虎 Léopard\", s.slice_unchecked(0, 21));\n}\n\nlet s = \"Hello, world!\";\n\nunsafe {\n    assert_eq!(\"world\", s.slice_unchecked(7, 12));\n}\n```","links":{"crate::ops::Index":"2:3576:3564","str::slice_mut_unchecked":"1:16011:4444","`str`":"1:16011:4444"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[deprecated(since = \"1.29.0\", note =\n\"use `get_unchecked(begin..end)` instead\")]","#[must_use]"],"deprecation":{"since":"1.29.0","note":"use `get_unchecked(begin..end)` instead"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["begin",{"kind":"primitive","inner":"usize"}],["end",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":true,"async":false,"abi":"Rust"},"has_body":true}},"0:746:793":{"id":"0:746:793","crate_id":0,"name":"len","span":{"filename":"src/input.rs","begin":[93,4],"end":[93,27]},"visibility":"default","docs":"The number of bytes in the input.","links":{},"attrs":[],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"primitive","inner":"usize"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":false}},"2:13442:6403":{"id":"2:13442:6403","crate_id":2,"name":"char_indices","span":null,"visibility":"public","docs":"Returns an iterator over the [`char`]s of a string slice, and their\npositions.\n\nAs a string slice consists of valid UTF-8, we can iterate through a\nstring slice by [`char`]. This method returns an iterator of both\nthese [`char`]s, as well as their byte positions.\n\nThe iterator yields tuples. The position is first, the [`char`] is\nsecond.\n\n# Examples\n\nBasic usage:\n\n```\nlet word = \"goodbye\";\n\nlet count = word.char_indices().count();\nassert_eq!(7, count);\n\nlet mut char_indices = word.char_indices();\n\nassert_eq!(Some((0, 'g')), char_indices.next());\nassert_eq!(Some((1, 'o')), char_indices.next());\nassert_eq!(Some((2, 'o')), char_indices.next());\nassert_eq!(Some((3, 'd')), char_indices.next());\nassert_eq!(Some((4, 'b')), char_indices.next());\nassert_eq!(Some((5, 'y')), char_indices.next());\nassert_eq!(Some((6, 'e')), char_indices.next());\n\nassert_eq!(None, char_indices.next());\n```\n\nRemember, [`char`]s might not match your intuition about characters:\n\n[`char`]: prim@char\n\n```\nlet yes = \"y̆es\";\n\nlet mut char_indices = yes.char_indices();\n\nassert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y̆')\nassert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n\n// note the 3 here - the last character took up two bytes\nassert_eq!(Some((3, 'e')), char_indices.next());\nassert_eq!(Some((4, 's')), char_indices.next());\n\nassert_eq!(None, char_indices.next());\n```","links":{"prim@char":"1:16005:4439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"CharIndices","id":"2:49435:4885","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}},"2:2925:124":{"id":"2:2925:124","crate_id":2,"name":"Eq","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"PartialEq","id":"2:2920:183","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementations":[]}},"0:2172:1627":{"id":"0:2172:1627","crate_id":0,"name":"InputAt","span":{"filename":"src/input.rs","begin":[13,0],"end":[18,1]},"visibility":"public","docs":"Represents a location in the input.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":true,"fields":[],"impls":[]}},"0:2340:1632":{"id":"0:2340:1632","crate_id":0,"name":"Program","span":{"filename":"src/prog.rs","begin":[18,0],"end":[75,1]},"visibility":"public","docs":"Program is a sequence of instructions and various facts about thos\ninstructions.","links":{},"attrs":[],"deprecation":null,"kind":"struct","inner":{"struct_type":"plain","generics":{"params":[],"where_predicates":[]},"fields_stripped":false,"fields":["0:2341:1842","0:2342:1754","0:2343:1900","0:2344:1845","0:2345:1323","0:2346:1851","0:2347:1876","0:2348:1872","0:2349:1883","0:2350:1887","0:2351:1792","0:2352:1897","0:2353:1986","0:2354:1795","0:2355:2153"],"impls":[]}},"0:2345:1323":{"id":"0:2345:1323","crate_id":0,"name":"start","span":{"filename":"src/prog.rs","begin":[35,4],"end":[35,22]},"visibility":"public","docs":"A pointer to the start instruction. This can vary depending on how\nthe program was compiled. For example, programs for use with the DFA\nengine have a `.*?` inserted at the beginning of unanchored regular\nexpressions. The actual starting point of the program is after the\n`.*?`.","links":{},"attrs":[],"deprecation":null,"kind":"struct_field","inner":{"kind":"primitive","inner":"usize"}},"5:6083":{"id":"5:6083","crate_id":5,"name":null,"span":null,"visibility":{"restricted":{"parent":"5:5903:1338","path":"::str"}},"docs":"Methods for string slices.","links":{},"attrs":["#[cfg(not(test))]"],"deprecation":null,"kind":"impl","inner":{"is_unsafe":false,"generics":{"params":[],"where_predicates":[]},"provided_trait_methods":[],"trait":null,"for":{"kind":"primitive","inner":"str"},"items":["5:6084:63848","5:6085:2466","5:6088:3767","5:6091:63849","5:6103:63850","5:6104:63851","5:6105:2053","5:6106:56932","5:6107:56933"],"negative":false,"synthetic":false,"blanket_impl":null}},"2:10298:119":{"id":"2:10298:119","crate_id":2,"name":"Display","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:10299:660"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementations":[]}},"0:1063:1582":{"id":"0:1063:1582","crate_id":0,"name":"re_builder","span":{"filename":"src/re_builder.rs","begin":[1,0],"end":[421,48]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:2471:1602","0:2502:1557","0:2533:1603","0:2566:1583","0:2455:2654"],"is_stripped":true}}},"paths":{"17:11970:8392":{"crate_id":17,"path":["object","macho","FatArch32"],"kind":"struct"},"5:1685:194":{"crate_id":5,"path":["alloc","collections","btree","map","Range"],"kind":"struct"},"6:6005:10427":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stat"],"kind":"struct"},"5:8250:4545":{"crate_id":5,"path":["alloc","collections","TryReserveError"],"kind":"struct"},"17:10599:8199":{"crate_id":17,"path":["object","read","macho","file","MachOComdatIterator"],"kind":"struct"},"16:5815:7109":{"crate_id":16,"path":["gimli","read","cfi","RegisterRule"],"kind":"enum"},"22:888:4792":{"crate_id":22,"path":["memchr","memmem","twoway","Reverse"],"kind":"struct"},"1:7736:6165":{"crate_id":1,"path":["std","process","Stdio"],"kind":"struct"},"2:11956:5970":{"crate_id":2,"path":["core","slice","iter","GroupByMut"],"kind":"struct"},"6:543:9691":{"crate_id":6,"path":["libc","unix","rusage"],"kind":"struct"},"2:49402:4892":{"crate_id":2,"path":["core","str","error","Utf8Error"],"kind":"struct"},"17:12771:8266":{"crate_id":17,"path":["object","macho","Relocation"],"kind":"struct"},"1:10800:6231":{"crate_id":1,"path":["std","fs","ReadDir"],"kind":"struct"},"20:3427:127":{"crate_id":20,"path":["regex_syntax","unicode","Error"],"kind":"enum"},"20:3150:1966":{"crate_id":20,"path":["regex_syntax","hir","Class"],"kind":"enum"},"17:11328:8266":{"crate_id":17,"path":["object","read","Relocation"],"kind":"struct"},"2:10574:5526":{"crate_id":2,"path":["core","hash","BuildHasher"],"kind":"trait"},"16:5790:7108":{"crate_id":16,"path":["gimli","read","cfi","CfaRule"],"kind":"enum"},"16:6768:7342":{"crate_id":16,"path":["gimli","read","lookup","PubStuffParser"],"kind":"struct"},"16:7378:7052":{"crate_id":16,"path":["gimli","read","str","DebugStr"],"kind":"struct"},"1:15484:58678":{"crate_id":1,"path":["std","panicking","Hook"],"kind":"enum"},"6:6221:10530":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user_fpregs_struct"],"kind":"struct"},"1:5723:6002":{"crate_id":1,"path":["std","os","unix","fs","FileExt"],"kind":"trait"},"1:15131:6173":{"crate_id":1,"path":["std","sys_common","process","CommandEnvs"],"kind":"struct"},"21:1635:4755":{"crate_id":21,"path":["aho_corasick","packed","api","FindIter"],"kind":"struct"},"18:721:7879":{"crate_id":18,"path":["memchr","memmem","twoway","TwoWay"],"kind":"struct"},"16:7205:7141":{"crate_id":16,"path":["gimli","read","pubtypes","PubTypesEntry"],"kind":"struct"},"21:1925:7956":{"crate_id":21,"path":["aho_corasick","prefilter","StartBytesBuilder"],"kind":"struct"},"17:11588:8315":{"crate_id":17,"path":["object","elf","Sym64"],"kind":"struct"},"20:2805:7523":{"crate_id":20,"path":["regex_syntax","ast","FlagsItemKind"],"kind":"enum"},"5:1607:5483":{"crate_id":5,"path":["alloc","collections","btree","map","IterMut"],"kind":"struct"},"2:50183:6617":{"crate_id":2,"path":["core","str","IsWhitespace"],"kind":"struct"},"16:5505:7097":{"crate_id":16,"path":["gimli","read","cfi","CfiEntriesIter"],"kind":"struct"},"6:1584:9783":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_ll"],"kind":"struct"},"5:4306:5483":{"crate_id":5,"path":["alloc","collections","vec_deque","iter_mut","IterMut"],"kind":"struct"},"20:2971:7972":{"crate_id":20,"path":["regex_syntax","hir","print","Writer"],"kind":"struct"},"16:7392:7053":{"crate_id":16,"path":["gimli","read","str","DebugStrOffsets"],"kind":"struct"},"16:2889:7321":{"crate_id":16,"path":["gimli","common","DebugArangesOffset"],"kind":"struct"},"16:7174:7138":{"crate_id":16,"path":["gimli","read","pubnames","PubNamesEntry"],"kind":"struct"},"16:6518:7126":{"crate_id":16,"path":["gimli","read","line","FileEntry"],"kind":"struct"},"21:1413:7906":{"crate_id":21,"path":["aho_corasick","dfa","PremultipliedByteClass"],"kind":"struct"},"2:2268:6351":{"crate_id":2,"path":["core","ptr","metadata","Pointee"],"kind":"trait"},"17:11640:8323":{"crate_id":17,"path":["object","elf","Rela32"],"kind":"struct"},"1:11126:4685":{"crate_id":1,"path":["std","io","Take"],"kind":"struct"},"17:12287:8442":{"crate_id":17,"path":["object","macho","RoutinesCommand32"],"kind":"struct"},"6:525:9683":{"crate_id":6,"path":["libc","unix","timeval"],"kind":"struct"},"20:3318:2008":{"crate_id":20,"path":["regex_syntax","hir","Repetition"],"kind":"struct"},"20:3265:1983":{"crate_id":20,"path":["regex_syntax","hir","WordBoundary"],"kind":"enum"},"22:698:5902":{"crate_id":22,"path":["memchr","cow","CowBytes"],"kind":"struct"},"2:49723:4894":{"crate_id":2,"path":["core","str","iter","LinesAny"],"kind":"struct"},"1:10370:8078":{"crate_id":1,"path":["std","backtrace_rs","symbolize","Symbol"],"kind":"struct"},"19:0:994":{"crate_id":19,"path":["panic_unwind"],"kind":"module"},"16:3338:7292":{"crate_id":16,"path":["gimli","common","DebugFrameOffset"],"kind":"struct"},"20:3298:1997":{"crate_id":20,"path":["regex_syntax","hir","GroupKind"],"kind":"enum"},"20:1998:7971":{"crate_id":20,"path":["regex_syntax","ast","print","Printer"],"kind":"struct"},"16:3772:8954":{"crate_id":16,"path":["gimli","constants","DwCfa"],"kind":"struct"},"2:12006:5961":{"crate_id":2,"path":["core","slice","raw","from_raw_parts"],"kind":"function"},"18:0:1551":{"crate_id":18,"path":["memchr"],"kind":"module"},"1:12401:7780":{"crate_id":1,"path":["std","sys","unix","args","Args"],"kind":"struct"},"20:2141:7500":{"crate_id":20,"path":["regex_syntax","ast","Comment"],"kind":"struct"},"2:46748:4683":{"crate_id":2,"path":["core","iter","adapters","skip","Skip"],"kind":"struct"},"1:7936:11569":{"crate_id":1,"path":["std","sync","mpsc","blocking","WaitToken"],"kind":"struct"},"2:13053:1578":{"crate_id":2,"path":["core","str","pattern"],"kind":"module"},"1:3204:6037":{"crate_id":1,"path":["std","fs","read_to_string"],"kind":"function"},"6:1736:9879":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_storage"],"kind":"struct"},"17:13348:8747":{"crate_id":17,"path":["object","pe","ImageAuxSymbolWeak"],"kind":"struct"},"17:12568:8505":{"crate_id":17,"path":["object","macho","VersionMinCommand"],"kind":"struct"},"2:3334:963":{"crate_id":2,"path":["core","ops"],"kind":"module"},"2:53252:6430":{"crate_id":2,"path":["core","core_arch","simd","f32x16"],"kind":"struct"},"16:6152:7047":{"crate_id":16,"path":["gimli","read","aranges","DebugAranges"],"kind":"struct"},"6:5548:10376":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","msqid_ds"],"kind":"struct"},"1:11139:1598":{"crate_id":1,"path":["std","io","Split"],"kind":"struct"},"17:12327:8449":{"crate_id":17,"path":["object","macho","SymtabCommand"],"kind":"struct"},"5:5:1500":{"crate_id":5,"path":["alloc","vec"],"kind":"macro"},"1:14610:129":{"crate_id":1,"path":["std","sys","unix","fs","FileType"],"kind":"struct"},"17:13532:8796":{"crate_id":17,"path":["object","pe","ImageResourceDirectoryEntry"],"kind":"struct"},"1:2181:6105":{"crate_id":1,"path":["std","collections","hash","set","Difference"],"kind":"struct"},"1:16027:4458":{"crate_id":1,"path":["std","isize"],"kind":"primitive"},"2:1944:2011":{"crate_id":2,"path":["core","mem"],"kind":"module"},"6:5386:10321":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","seminfo"],"kind":"struct"},"1:12061:60986":{"crate_id":1,"path":["std","sync","mpsc","shared","StartResult"],"kind":"enum"},"12:1682:6964":{"crate_id":12,"path":["hashbrown","rustc_entry","RustcOccupiedEntry"],"kind":"struct"},"2:13083:4875":{"crate_id":2,"path":["core","str","pattern","DoubleEndedSearcher"],"kind":"trait"},"17:12442:8487":{"crate_id":17,"path":["object","macho","TwolevelHintsCommand"],"kind":"struct"},"1:8136:5926":{"crate_id":1,"path":["std","sync","mpsc","shared","Packet"],"kind":"struct"},"2:3375:4843":{"crate_id":2,"path":["core","ops","arith","MulAssign"],"kind":"trait"},"20:2690:2038":{"crate_id":20,"path":["regex_syntax","ast","RepetitionRange"],"kind":"enum"},"6:4164:10053":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Ehdr"],"kind":"struct"},"2:49378:5973":{"crate_id":2,"path":["core","slice","iter","RChunksExactMut"],"kind":"struct"},"20:3227:2022":{"crate_id":20,"path":["regex_syntax","hir","ClassBytesRange"],"kind":"struct"},"2:13129:6383":{"crate_id":2,"path":["core","str","pattern","MultiCharEqPattern"],"kind":"struct"},"1:1442:3395":{"crate_id":1,"path":["std","collections","hash","map","IntoIter"],"kind":"struct"},"20:346:7482":{"crate_id":20,"path":["regex_syntax","ast","visitor","ClassInduct"],"kind":"enum"},"17:13477:8778":{"crate_id":17,"path":["object","pe","ImageImportDescriptor"],"kind":"struct"},"2:49609:4895":{"crate_id":2,"path":["core","str","iter","MatchIndices"],"kind":"struct"},"1:5745:6005":{"crate_id":1,"path":["std","os","unix","fs","MetadataExt"],"kind":"trait"},"21:1363:7531":{"crate_id":21,"path":["aho_corasick","dfa","DFA"],"kind":"enum"},"20:2791:7522":{"crate_id":20,"path":["regex_syntax","ast","FlagsItem"],"kind":"struct"},"2:47492:176":{"crate_id":2,"path":["core","option","Option"],"kind":"enum"},"16:5707:7103":{"crate_id":16,"path":["gimli","read","cfi","UninitializedUnwindContext"],"kind":"struct"},"2:24212:10570":{"crate_id":2,"path":["core","num","fmt","Formatted"],"kind":"struct"},"1:5657:6094":{"crate_id":1,"path":["std","os","unix","ffi","os_str","OsStrExt"],"kind":"trait"},"6:5414:10335":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_exit"],"kind":"struct"},"2:56348:236":{"crate_id":2,"path":["core","core_simd","fmt","fmt","Wrapper"],"kind":"struct"},"2:51096:6457":{"crate_id":2,"path":["core","core_arch","simd","u16x2"],"kind":"struct"},"17:13240:8718":{"crate_id":17,"path":["object","pe","ImageSectionHeader"],"kind":"struct"},"5:5875:7731":{"crate_id":5,"path":["alloc","slice","insert_head","InsertionHole"],"kind":"struct"},"2:50068:9378":{"crate_id":2,"path":["core","str","lossy","Utf8LossyChunk"],"kind":"struct"},"16:5975:7112":{"crate_id":16,"path":["gimli","read","dwarf","Dwarf"],"kind":"struct"},"20:3441:4595":{"crate_id":20,"path":["regex_syntax","unicode","UnicodeWordError"],"kind":"struct"},"2:46670:4677":{"crate_id":2,"path":["core","iter","adapters","fuse","Fuse"],"kind":"struct"},"2:5604:6361":{"crate_id":2,"path":["core","ffi","sealed_trait","VaArgSafe"],"kind":"trait"},"6:5191:10224":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__timeval"],"kind":"struct"},"2:50171:6612":{"crate_id":2,"path":["core","str","CharEscapeDebugContinue"],"kind":"struct"},"1:8643:4563":{"crate_id":1,"path":["std","sync","barrier","Barrier"],"kind":"struct"},"5:3839:7723":{"crate_id":5,"path":["alloc","collections","linked_list","drop","DropGuard"],"kind":"struct"},"2:4:979":{"crate_id":2,"path":["core","panic"],"kind":"macro"},"2:57696:9456":{"crate_id":2,"path":["core","core_simd","vector","ptr","SimdMutPtr"],"kind":"struct"},"2:48792:5529":{"crate_id":2,"path":["core","hash","sip","SipHasher13"],"kind":"struct"},"5:3894:6772":{"crate_id":5,"path":["alloc","collections","linked_list","CursorMut"],"kind":"struct"},"17:12521:8498":{"crate_id":17,"path":["object","macho","FilesetEntryCommand"],"kind":"struct"},"2:11244:5968":{"crate_id":2,"path":["core","slice","iter","SplitMut"],"kind":"struct"},"2:47611:188":{"crate_id":2,"path":["core","pin","Pin"],"kind":"struct"},"6:6155:10494":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user"],"kind":"struct"},"16:3604:8088":{"crate_id":16,"path":["gimli","arch","X86_64"],"kind":"struct"},"20:2416:4600":{"crate_id":20,"path":["regex_syntax","ast","ClassUnicode"],"kind":"struct"},"21:1184:4758":{"crate_id":21,"path":["aho_corasick","state_id","StateID"],"kind":"trait"},"12:971:6189":{"crate_id":12,"path":["hashbrown","map","RawVacantEntryMut"],"kind":"struct"},"2:23136:6424":{"crate_id":2,"path":["core","core_simd","masks","Mask"],"kind":"struct"},"12:1147:6193":{"crate_id":12,"path":["hashbrown","map","VacantEntry"],"kind":"struct"},"1:9638:7766":{"crate_id":1,"path":["std","sys_common","mutex","StaticMutexGuard"],"kind":"struct"},"6:161:42757":{"crate_id":6,"path":["libc","unix","fpos_t"],"kind":"enum"},"22:905:64165":{"crate_id":22,"path":["memchr","memmem","twoway","Shift"],"kind":"enum"},"16:7406:7051":{"crate_id":16,"path":["gimli","read","str","DebugLineStr"],"kind":"struct"},"21:1934:7957":{"crate_id":21,"path":["aho_corasick","prefilter","StartBytesOne"],"kind":"struct"},"17:13497:8785":{"crate_id":17,"path":["object","pe","ImageBoundForwarderRef"],"kind":"struct"},"1:10697:9481":{"crate_id":1,"path":["std","env","JoinPathsError"],"kind":"struct"},"5:6973:1500":{"crate_id":5,"path":["alloc","vec"],"kind":"module"},"20:2008:127":{"crate_id":20,"path":["regex_syntax","ast","Error"],"kind":"struct"},"1:16018:4449":{"crate_id":1,"path":["std","i16"],"kind":"primitive"},"2:4751:102":{"crate_id":2,"path":["core","asserting","Capture"],"kind":"struct"},"20:3207:4602":{"crate_id":20,"path":["regex_syntax","hir","ClassBytes"],"kind":"struct"},"2:24090:6574":{"crate_id":2,"path":["core","num","dec2flt","ParseFloatError"],"kind":"struct"},"2:46309:6555":{"crate_id":2,"path":["core","char","convert","CharErrorKind"],"kind":"enum"},"17:10071:7478":{"crate_id":17,"path":["object","read","coff","file","CoffFile"],"kind":"struct"},"1:11152:6081":{"crate_id":1,"path":["std","net","addr","SocketAddr"],"kind":"enum"},"20:2712:1995":{"crate_id":20,"path":["regex_syntax","ast","Group"],"kind":"struct"},"9:996:6885":{"crate_id":9,"path":["miniz_oxide","MZStatus"],"kind":"enum"},"1:12258:6126":{"crate_id":1,"path":["std","time","Instant"],"kind":"struct"},"17:13356:8750":{"crate_id":17,"path":["object","pe","ImageAuxSymbolSection"],"kind":"struct"},"21:1793:7932":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","TeddySlim3Mask256"],"kind":"struct"},"16:7146:7136":{"crate_id":16,"path":["gimli","read","op","OperationIter"],"kind":"struct"},"2:51818:9393":{"crate_id":2,"path":["core","core_arch","simd","m8x16"],"kind":"struct"},"5:7620:5452":{"crate_id":5,"path":["alloc","vec","set_len_on_drop","SetLenOnDrop"],"kind":"struct"},"2:48800:9370":{"crate_id":2,"path":["core","hash","sip","SipHasher24"],"kind":"struct"},"17:13819:8887":{"crate_id":17,"path":["object","pe","ImageEnclaveConfig32"],"kind":"struct"},"1:8478:202":{"crate_id":1,"path":["std","sync","mpsc","Receiver"],"kind":"struct"},"1:10706:4672":{"crate_id":1,"path":["std","error","Chain"],"kind":"struct"},"17:10950:8247":{"crate_id":17,"path":["object","read","pe","file","PeComdatSectionIterator"],"kind":"struct"},"17:12795:8549":{"crate_id":17,"path":["object","macho","ScatteredRelocationInfo"],"kind":"struct"},"20:2292:7503":{"crate_id":20,"path":["regex_syntax","ast","HexLiteralKind"],"kind":"enum"},"1:7979:7751":{"crate_id":1,"path":["std","sync","mpsc","mpsc_queue","Queue"],"kind":"struct"},"1:13583:11033":{"crate_id":1,"path":["std","sys","unix","os","Env"],"kind":"struct"},"1:4611:4652":{"crate_id":1,"path":["std","io","util","Repeat"],"kind":"struct"},"0:55:1602":{"crate_id":0,"path":["regex","bytes"],"kind":"module"},"6:1630:9812":{"crate_id":6,"path":["libc","unix","linux_like","lconv"],"kind":"struct"},"16:6219:7119":{"crate_id":16,"path":["gimli","read","aranges","ArangeEntry"],"kind":"struct"},"2:45919:198":{"crate_id":2,"path":["core","ops","range","RangeTo"],"kind":"struct"},"2:51639:6439":{"crate_id":2,"path":["core","core_arch","simd","i16x8"],"kind":"struct"},"5:6411:223":{"crate_id":5,"path":["alloc","string","ToString"],"kind":"trait"},"16:4823:8973":{"crate_id":16,"path":["gimli","constants","DwIdx"],"kind":"struct"},"17:11779:8353":{"crate_id":17,"path":["object","elf","Verneed"],"kind":"struct"},"12:379:6956":{"crate_id":12,"path":["hashbrown","raw","RawIter"],"kind":"struct"},"1:15230:6122":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8CodePoints"],"kind":"struct"},"2:10308:189":{"crate_id":2,"path":["core","fmt","Pointer"],"kind":"trait"},"16:6269:7121":{"crate_id":16,"path":["gimli","read","line","LineInstruction"],"kind":"enum"},"12:1703:6965":{"crate_id":12,"path":["hashbrown","rustc_entry","RustcVacantEntry"],"kind":"struct"},"17:10331:7406":{"crate_id":17,"path":["object","read","elf","symbol","SymbolTable"],"kind":"struct"},"1:6561:6101":{"crate_id":1,"path":["std","os","unix","thread","JoinHandleExt"],"kind":"trait"},"1:11453:10427":{"crate_id":1,"path":["std","os","linux","raw","arch","stat"],"kind":"struct"},"17:13898:8907":{"crate_id":17,"path":["object","pe","ImageCoffSymbolsHeader"],"kind":"struct"},"1:15020:6166":{"crate_id":1,"path":["std","sys","unix","process","process_inner","ExitStatus"],"kind":"struct"},"17:10279:7404":{"crate_id":17,"path":["object","read","elf","section","SectionTable"],"kind":"struct"},"17:13564:8804":{"crate_id":17,"path":["object","pe","ImageLoadConfigCodeIntegrity"],"kind":"struct"},"1:12223:4566":{"crate_id":1,"path":["std","sync","condvar","WaitTimeoutResult"],"kind":"struct"},"22:826:5901":{"crate_id":22,"path":["memchr","memmem","prefilter","Prefilter"],"kind":"enum"},"2:3174:135":{"crate_id":2,"path":["core","convert","From"],"kind":"trait"},"17:13772:8876":{"crate_id":17,"path":["object","pe","ImageArmRuntimeFunctionEntry"],"kind":"struct"},"5:7111:7735":{"crate_id":5,"path":["alloc","vec","drain_filter","drop","BackshiftOnDrop"],"kind":"struct"},"2:46049:6529":{"crate_id":2,"path":["core","any","tags","Value"],"kind":"struct"},"2:50341:201":{"crate_id":2,"path":["core","future","ready","Ready"],"kind":"struct"},"2:24118:9336":{"crate_id":2,"path":["core","num","diy_float","Fp"],"kind":"struct"},"14:189:9230":{"crate_id":14,"path":["rustc_demangle","Demangle"],"kind":"struct"},"2:10298:119":{"crate_id":2,"path":["core","fmt","Display"],"kind":"trait"},"5:8203:3395":{"crate_id":5,"path":["alloc","collections","vec_deque","into_iter","IntoIter"],"kind":"struct"},"1:10614:5476":{"crate_id":1,"path":["std","thread","Thread"],"kind":"struct"},"17:8929:49915":{"crate_id":17,"path":["object","common","BinaryFormat"],"kind":"enum"},"16:3287:7312":{"crate_id":16,"path":["gimli","common","DebugTypesOffset"],"kind":"struct"},"2:11137:5483":{"crate_id":2,"path":["core","slice","iter","IterMut"],"kind":"struct"},"17:13865:8901":{"crate_id":17,"path":["object","pe","ImageEnclaveImport"],"kind":"struct"},"2:49358:5974":{"crate_id":2,"path":["core","slice","iter","RChunksMut"],"kind":"struct"},"20:2748:2000":{"crate_id":20,"path":["regex_syntax","ast","CaptureName"],"kind":"struct"},"9:0:4414":{"crate_id":9,"path":["miniz_oxide"],"kind":"module"},"1:11664:3396":{"crate_id":1,"path":["std","path","Iter"],"kind":"struct"},"5:4515:6753":{"crate_id":5,"path":["alloc","collections","vec_deque","pair_slices","PairSlices"],"kind":"struct"},"1:11410:6329":{"crate_id":1,"path":["std","os","unix","net","ancillary","AncillaryError"],"kind":"enum"},"16:3218:7309":{"crate_id":16,"path":["gimli","common","DebugStrOffset"],"kind":"struct"},"17:9528:1814":{"crate_id":17,"path":["object","read","util","Bytes"],"kind":"struct"},"13:120:48235":{"crate_id":13,"path":["std_detect","detect","arch","x86","Feature"],"kind":"enum"},"1:3662:7749":{"crate_id":1,"path":["std","io","buffered","bufwriter","flush_buf","BufGuard"],"kind":"struct"},"17:9961:8171":{"crate_id":17,"path":["object","read","any","SectionRelocationIterator"],"kind":"struct"},"17:1311:7479":{"crate_id":17,"path":["object","read","coff","relocation","CoffRelocationIterator"],"kind":"struct"},"5:1195:11030":{"crate_id":5,"path":["alloc","collections","btree","append","MergeIter"],"kind":"struct"},"1:11611:6144":{"crate_id":1,"path":["std","path","Component"],"kind":"enum"},"2:49429:4886":{"crate_id":2,"path":["core","str","iter","Chars"],"kind":"struct"},"17:10516:7465":{"crate_id":17,"path":["object","read","elf","version","VerneedIterator"],"kind":"struct"},"1:1194:11566":{"crate_id":1,"path":["std","backtrace","LazilyResolvedCapture"],"kind":"struct"},"19:117:9608":{"crate_id":19,"path":["panic_unwind","dwarf","eh","EHContext"],"kind":"struct"},"2:48007:90":{"crate_id":2,"path":["core","sync","atomic","AtomicU64"],"kind":"struct"},"6:5255:10256":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","mallinfo2"],"kind":"struct"},"17:9065:49918":{"crate_id":17,"path":["object","common","SymbolScope"],"kind":"enum"},"17:11434:8274":{"crate_id":17,"path":["object","elf","FileHeader32"],"kind":"struct"},"2:51177:6470":{"crate_id":2,"path":["core","core_arch","simd","u8x8"],"kind":"struct"},"1:9737:6269":{"crate_id":1,"path":["std","sys_common","remutex","ReentrantMutexGuard"],"kind":"struct"},"20:3012:8051":{"crate_id":20,"path":["regex_syntax","hir","translate","TranslatorI"],"kind":"struct"},"17:12480:8492":{"crate_id":17,"path":["object","macho","UuidCommand"],"kind":"struct"},"18:611:5902":{"crate_id":18,"path":["memchr","cow","CowBytes"],"kind":"struct"},"2:8879:3563":{"crate_id":2,"path":["core","iter","traits","marker","FusedIterator"],"kind":"trait"},"1:4084:127":{"crate_id":1,"path":["std","io","error","Error"],"kind":"struct"},"5:3375:6732":{"crate_id":5,"path":["alloc","collections","btree","set","IntersectionInner"],"kind":"enum"},"5:3882:6053":{"crate_id":5,"path":["alloc","collections","linked_list","Cursor"],"kind":"struct"},"6:6085:10453":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","pthread_attr_t"],"kind":"struct"},"1:16012:4445":{"crate_id":1,"path":["std","tuple"],"kind":"primitive"},"16:4350:8959":{"crate_id":16,"path":["gimli","constants","DwAte"],"kind":"struct"},"17:12221:8433":{"crate_id":17,"path":["object","macho","SubUmbrellaCommand"],"kind":"struct"},"20:2485:7511":{"crate_id":20,"path":["regex_syntax","ast","ClassSet"],"kind":"enum"},"2:48546:107":{"crate_id":2,"path":["core","fmt","rt","v1","Count"],"kind":"enum"},"1:1463:6182":{"crate_id":1,"path":["std","collections","hash","map","Values"],"kind":"struct"},"16:6636:7064":{"crate_id":16,"path":["gimli","read","loclists","RawLocListIter"],"kind":"struct"},"2:45873:194":{"crate_id":2,"path":["core","ops","range","Range"],"kind":"struct"},"2:51670:6443":{"crate_id":2,"path":["core","core_arch","simd","i32x4"],"kind":"struct"},"16:3488:7314":{"crate_id":16,"path":["gimli","common","DwoId"],"kind":"struct"},"17:11767:8350":{"crate_id":17,"path":["object","elf","Verdaux"],"kind":"struct"},"1:12019:6166":{"crate_id":1,"path":["std","process","ExitStatus"],"kind":"struct"},"5:1694:6781":{"crate_id":5,"path":["alloc","collections","btree","map","RangeMut"],"kind":"struct"},"1:15987:58677":{"crate_id":1,"path":["std","backtrace_rs","print","PrintFmt"],"kind":"enum"},"17:10117:7474":{"crate_id":17,"path":["object","read","coff","section","CoffSectionIterator"],"kind":"struct"},"1:16008:4441":{"crate_id":1,"path":["std","pointer"],"kind":"primitive"},"2:56387:236":{"crate_id":2,"path":["core","core_simd","fmt","fmt","Wrapper"],"kind":"struct"},"17:10887:8240":{"crate_id":17,"path":["object","read","macho","symbol","MachOSymbol"],"kind":"struct"},"17:10611:8200":{"crate_id":17,"path":["object","read","macho","file","MachOComdat"],"kind":"struct"},"16:7761:7148":{"crate_id":16,"path":["gimli","read","unit","AttrsIter"],"kind":"struct"},"16:6949:7346":{"crate_id":16,"path":["gimli","read","op","OperationEvaluationResult"],"kind":"enum"},"2:47619:205":{"crate_id":2,"path":["core","result","Result"],"kind":"enum"},"2:45942:197":{"crate_id":2,"path":["core","ops","range","RangeInclusive"],"kind":"struct"},"17:11726:8340":{"crate_id":17,"path":["object","elf","Dyn64"],"kind":"struct"},"20:2211:2002":{"crate_id":20,"path":["regex_syntax","ast","Concat"],"kind":"struct"},"5:1457:6193":{"crate_id":5,"path":["alloc","collections","btree","map","entry","VacantEntry"],"kind":"struct"},"17:13062:8663":{"crate_id":17,"path":["object","pe","ImageOptionalHeader32"],"kind":"struct"},"17:13810:8885":{"crate_id":17,"path":["object","pe","ImageRuntimeFunctionEntry"],"kind":"struct"},"17:11100:7381":{"crate_id":17,"path":["object","read","SymbolIndex"],"kind":"struct"},"20:3460:64745":{"crate_id":20,"path":["regex_syntax","unicode","CanonicalClassQuery"],"kind":"enum"},"2:5231:404":{"crate_id":2,"path":["core","char"],"kind":"module"},"6:3951:9956":{"crate_id":6,"path":["libc","unix","linux_like","linux","fsid_t"],"kind":"struct"},"2:46424:5837":{"crate_id":2,"path":["core","char","ToUppercase"],"kind":"struct"},"1:8384:5926":{"crate_id":1,"path":["std","sync","mpsc","sync","Packet"],"kind":"struct"},"2:53436:9440":{"crate_id":2,"path":["core","core_arch","x86","__m256"],"kind":"struct"},"17:10801:8238":{"crate_id":17,"path":["object","read","macho","segment","MachOSegment"],"kind":"struct"},"6:624:9741":{"crate_id":6,"path":["libc","unix","servent"],"kind":"struct"},"20:2002:7972":{"crate_id":20,"path":["regex_syntax","ast","print","Writer"],"kind":"struct"},"1:2797:5743":{"crate_id":1,"path":["std","error","Indented"],"kind":"struct"},"16:4417:8961":{"crate_id":16,"path":["gimli","constants","DwDs"],"kind":"struct"},"2:49767:4708":{"crate_id":2,"path":["core","str","iter","EscapeDefault"],"kind":"struct"},"2:51208:6458":{"crate_id":2,"path":["core","core_arch","simd","u16x4"],"kind":"struct"},"2:49286:5966":{"crate_id":2,"path":["core","slice","iter","ChunksExactMut"],"kind":"struct"},"2:47881:82":{"crate_id":2,"path":["core","sync","atomic","AtomicI32"],"kind":"struct"},"1:11430:6294":{"crate_id":1,"path":["std","os","unix","ucred","UCred"],"kind":"struct"},"6:1572:9774":{"crate_id":6,"path":["libc","unix","linux_like","addrinfo"],"kind":"struct"},"6:3957:9958":{"crate_id":6,"path":["libc","unix","linux_like","linux","packet_mreq"],"kind":"struct"},"12:1162:6949":{"crate_id":12,"path":["hashbrown","map","EntryRef"],"kind":"enum"},"16:6021:7300":{"crate_id":16,"path":["gimli","read","dwarf","RangeIterInner"],"kind":"enum"},"2:13766:138":{"crate_id":2,"path":["core","future","future","Future"],"kind":"trait"},"2:22599:61695":{"crate_id":2,"path":["core","core_simd","swizzle","deinterleave","Even"],"kind":"struct"},"6:3881:9904":{"crate_id":6,"path":["libc","unix","linux_like","linux","passwd"],"kind":"struct"},"17:13884:8905":{"crate_id":17,"path":["object","pe","ImageDebugDirectory"],"kind":"struct"},"16:7453:7048":{"crate_id":16,"path":["gimli","read","unit","DebugInfo"],"kind":"struct"},"17:10558:8195":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldCacheImageIterator"],"kind":"struct"},"2:3515:3316":{"crate_id":2,"path":["core","ops","drop","Drop"],"kind":"trait"},"16:6238:7050":{"crate_id":16,"path":["gimli","read","line","DebugLine"],"kind":"struct"},"17:10211:8185":{"crate_id":17,"path":["object","read","coff","comdat","CoffComdat"],"kind":"struct"},"17:10140:7406":{"crate_id":17,"path":["object","read","coff","symbol","SymbolTable"],"kind":"struct"},"2:24632:169":{"crate_id":2,"path":["core","num","nonzero","NonZeroU128"],"kind":"struct"},"2:3280:220":{"crate_id":2,"path":["core","marker","Sync"],"kind":"trait"},"16:5941:189":{"crate_id":16,"path":["gimli","read","cfi","Pointer"],"kind":"enum"},"12:472:11026":{"crate_id":12,"path":["hashbrown","raw","RawIterHashInner"],"kind":"struct"},"2:22561:61677":{"crate_id":2,"path":["core","core_simd","swizzle","rotate_lanes_right","Rotate"],"kind":"struct"},"2:22748:6509":{"crate_id":2,"path":["core","core_simd","elements","float","SimdFloat"],"kind":"trait"},"5:3748:160":{"crate_id":5,"path":["alloc","collections","linked_list","LinkedList"],"kind":"struct"},"1:6703:10442":{"crate_id":1,"path":["std","os","linux","fs","MetadataExt","st_ctime"],"kind":"foreign_type"},"1:16009:4442":{"crate_id":1,"path":["std","array"],"kind":"primitive"},"21:1527:5858":{"crate_id":21,"path":["aho_corasick","nfa","Builder"],"kind":"struct"},"5:0:277":{"crate_id":5,"path":["alloc"],"kind":"module"},"6:1700:9866":{"crate_id":6,"path":["libc","unix","linux_like","arpreq_old"],"kind":"struct"},"17:12946:8571":{"crate_id":17,"path":["object","pe","ImageOs2Header"],"kind":"struct"},"5:1644:6182":{"crate_id":5,"path":["alloc","collections","btree","map","Values"],"kind":"struct"},"17:13377:8754":{"crate_id":17,"path":["object","pe","ImageRelocation"],"kind":"struct"},"2:3276:218":{"crate_id":2,"path":["core","marker","StructuralPartialEq"],"kind":"trait"},"17:12685:8528":{"crate_id":17,"path":["object","macho","EntryPointCommand"],"kind":"struct"},"17:13306:8733":{"crate_id":17,"path":["object","pe","ImageAuxSymbolTokenDef"],"kind":"struct"},"1:12253:4577":{"crate_id":1,"path":["std","sync","rwlock","RwLockWriteGuard"],"kind":"struct"},"2:3102:6017":{"crate_id":2,"path":["core","convert","num","private","Sealed"],"kind":"trait"},"2:23767:6017":{"crate_id":2,"path":["core","core_simd","vector","sealed","Sealed"],"kind":"trait"},"21:1817:7938":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","Mask256"],"kind":"struct"},"1:16030:4461":{"crate_id":1,"path":["std","fn"],"kind":"primitive"},"2:7755:4671":{"crate_id":2,"path":["core","iter","adapters","zip","TrustedRandomAccessNoCoerce"],"kind":"trait"},"6:6091:10455":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_fpxreg"],"kind":"struct"},"16:3549:8952":{"crate_id":16,"path":["gimli","arch","X86"],"kind":"struct"},"2:8179:4557":{"crate_id":2,"path":["core","iter","sources","once","once"],"kind":"function"},"5:3300:95":{"crate_id":5,"path":["alloc","collections","btree","set","BTreeSet"],"kind":"struct"},"17:12456:8489":{"crate_id":17,"path":["object","macho","TwolevelHint"],"kind":"struct"},"1:15186:6114":{"crate_id":1,"path":["std","sys_common","wtf8","CodePoint"],"kind":"struct"},"16:4890:8975":{"crate_id":16,"path":["gimli","constants","DwLns"],"kind":"struct"},"21:1908:7951":{"crate_id":21,"path":["aho_corasick","prefilter","RareBytesTwo"],"kind":"struct"},"17:13942:8922":{"crate_id":17,"path":["object","pe","ImageSeparateDebugHeader"],"kind":"struct"},"1:1021:5926":{"crate_id":1,"path":["std","thread","Packet"],"kind":"struct"},"6:1540:9758":{"crate_id":6,"path":["libc","unix","linux_like","ip_mreq_source"],"kind":"struct"},"17:12247:8437":{"crate_id":17,"path":["object","macho","PreboundDylibCommand"],"kind":"struct"},"5:3396:6107":{"crate_id":5,"path":["alloc","collections","btree","set","Union"],"kind":"struct"},"1:1522:6188":{"crate_id":1,"path":["std","collections","hash","map","RawOccupiedEntryMut"],"kind":"struct"},"2:53126:6445":{"crate_id":2,"path":["core","core_arch","simd","i32x16"],"kind":"struct"},"6:5998:10423":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stack_t"],"kind":"struct"},"2:48580:71":{"crate_id":2,"path":["core","fmt","ArgumentV1"],"kind":"struct"},"16:0:4420":{"crate_id":16,"path":["gimli"],"kind":"module"},"2:46656:9367":{"crate_id":2,"path":["core","iter","adapters","flatten","FlattenCompat"],"kind":"struct"},"6:5359:10312":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","regex_t"],"kind":"struct"},"9:1075:6887":{"crate_id":9,"path":["miniz_oxide","StreamResult"],"kind":"struct"},"16:7236:7144":{"crate_id":16,"path":["gimli","read","rnglists","DebugRanges"],"kind":"struct"},"5:1560:94":{"crate_id":5,"path":["alloc","collections","btree","map","BTreeMap"],"kind":"struct"},"1:12248:4576":{"crate_id":1,"path":["std","sync","rwlock","RwLockReadGuard"],"kind":"struct"},"2:11923:5969":{"crate_id":2,"path":["core","slice","iter","GroupBy"],"kind":"struct"},"12:928:6183":{"crate_id":12,"path":["hashbrown","map","ValuesMut"],"kind":"struct"},"2:8399:136":{"crate_id":2,"path":["core","iter","traits","collect","FromIterator"],"kind":"trait"},"17:13205:8714":{"crate_id":17,"path":["object","pe","AnonObjectHeaderV2"],"kind":"struct"},"6:4215:10057":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Phdr"],"kind":"struct"},"1:7931:5925":{"crate_id":1,"path":["std","sync","mpsc","blocking","Inner"],"kind":"struct"},"2:32296:4635":{"crate_id":2,"path":["core","mem","manually_drop","ManuallyDrop"],"kind":"struct"},"2:13283:11032":{"crate_id":2,"path":["core","str","lossy","Utf8LossyChunksIter"],"kind":"struct"},"17:8954:7433":{"crate_id":17,"path":["object","common","SectionKind"],"kind":"enum"},"16:6577:7128":{"crate_id":16,"path":["gimli","read","loclists","DebugLoc"],"kind":"struct"},"1:11228:6086":{"crate_id":1,"path":["std","net","ip","Ipv4Addr"],"kind":"struct"},"16:6464:7060":{"crate_id":16,"path":["gimli","read","line","IncompleteLineProgram"],"kind":"struct"},"6:5436:10342":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","sifields_sigchld"],"kind":"struct"},"12:559:143":{"crate_id":12,"path":["hashbrown","map","HashMap"],"kind":"struct"},"20:3420:4594":{"crate_id":20,"path":["regex_syntax","parser","Parser"],"kind":"struct"},"21:1901:7949":{"crate_id":21,"path":["aho_corasick","prefilter","RareBytesOne"],"kind":"struct"},"2:37624:178":{"crate_id":2,"path":["core","cmp","Ordering"],"kind":"enum"},"17:14000:8932":{"crate_id":17,"path":["object","pe","ImageCor20Header"],"kind":"struct"},"2:50203:121":{"crate_id":2,"path":["core","time","Duration"],"kind":"struct"},"21:1625:7546":{"crate_id":21,"path":["aho_corasick","packed","api","SearchKind"],"kind":"enum"},"2:51282:6450":{"crate_id":2,"path":["core","core_arch","simd","i8x8"],"kind":"struct"},"6:6214:10527":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","seccomp_notif_sizes"],"kind":"struct"},"6:4133:10043":{"crate_id":6,"path":["libc","unix","linux_like","linux","dl_phdr_info"],"kind":"struct"},"2:53396:9436":{"crate_id":2,"path":["core","core_arch","x86","__m128i"],"kind":"struct"},"20:3181:4601":{"crate_id":20,"path":["regex_syntax","hir","ClassUnicodeIter"],"kind":"struct"},"17:10635:8202":{"crate_id":17,"path":["object","read","macho","load_command","LoadCommandIterator"],"kind":"struct"},"2:46450:5839":{"crate_id":2,"path":["core","char","TryFromCharError"],"kind":"struct"},"2:4669:6029":{"crate_id":2,"path":["core","array","try_collect_into_array","Guard"],"kind":"struct"},"16:4641:8967":{"crate_id":16,"path":["gimli","constants","DwAddr"],"kind":"struct"},"17:0:4421":{"crate_id":17,"path":["object"],"kind":"module"},"1:7681:6163":{"crate_id":1,"path":["std","process","Command"],"kind":"struct"},"17:681:8078":{"crate_id":17,"path":["object","read","any","Symbol"],"kind":"struct"},"2:24234:6650":{"crate_id":2,"path":["core","num","error","ParseIntError"],"kind":"struct"},"16:6072:7066":{"crate_id":16,"path":["gimli","read","reader","ReaderOffsetId"],"kind":"struct"},"18:637:7878":{"crate_id":18,"path":["memchr","memmem","genericsimd","Forward"],"kind":"struct"},"2:11317:4898":{"crate_id":2,"path":["core","slice","iter","RSplit"],"kind":"struct"},"2:46609:4665":{"crate_id":2,"path":["core","iter","adapters","copied","Copied"],"kind":"struct"},"17:10975:8249":{"crate_id":17,"path":["object","read","pe","section","PeSegment"],"kind":"struct"},"1:12278:6127":{"crate_id":1,"path":["std","time","SystemTime"],"kind":"struct"},"17:8849:7371":{"crate_id":17,"path":["object","common","Architecture"],"kind":"enum"},"2:49323:5953":{"crate_id":2,"path":["core","slice","iter","ArrayChunks"],"kind":"struct"},"16:4922:8976":{"crate_id":16,"path":["gimli","constants","DwLne"],"kind":"struct"},"2:5033:4710":{"crate_id":2,"path":["core","cell","BorrowError"],"kind":"struct"},"21:1481:2280":{"crate_id":21,"path":["aho_corasick","nfa","State"],"kind":"struct"},"2:51048:9385":{"crate_id":2,"path":["core","core_arch","simd","i8x2"],"kind":"struct"},"1:2755:5742":{"crate_id":1,"path":["std","error","Report"],"kind":"struct"},"2:48808:5528":{"crate_id":2,"path":["core","hash","sip","SipHasher"],"kind":"struct"},"1:11654:6145":{"crate_id":1,"path":["std","path","Components"],"kind":"struct"},"16:6605:7062":{"crate_id":16,"path":["gimli","read","loclists","LocationLists"],"kind":"struct"},"2:49336:5954":{"crate_id":2,"path":["core","slice","iter","ArrayChunksMut"],"kind":"struct"},"2:23661:6075":{"crate_id":2,"path":["core","core_simd","vector","Simd"],"kind":"struct"},"6:4066:10010":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_ramp_effect"],"kind":"struct"},"21:1771:7929":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","TeddySlim2Mask256"],"kind":"struct"},"1:4516:6058":{"crate_id":1,"path":["std","io","stdio","StderrLock"],"kind":"struct"},"21:0:1633":{"crate_id":21,"path":["aho_corasick"],"kind":"module"},"2:4050:5747":{"crate_id":2,"path":["core","any","Provider"],"kind":"trait"},"6:157:42756":{"crate_id":6,"path":["libc","unix","FILE"],"kind":"enum"},"2:2862:97":{"crate_id":2,"path":["core","borrow","Borrow"],"kind":"trait"},"1:1486:5446":{"crate_id":1,"path":["std","collections","hash","map","DrainFilter"],"kind":"struct"},"2:45857:196":{"crate_id":2,"path":["core","ops","range","RangeFull"],"kind":"struct"},"20:2539:7513":{"crate_id":20,"path":["regex_syntax","ast","ClassSetRange"],"kind":"struct"},"17:13924:8916":{"crate_id":17,"path":["object","pe","ImageFunctionEntry"],"kind":"struct"},"16:7571:7044":{"crate_id":16,"path":["gimli","read","unit","AttributeValue"],"kind":"enum"},"16:4477:8963":{"crate_id":16,"path":["gimli","constants","DwAccess"],"kind":"struct"},"2:5155:4717":{"crate_id":2,"path":["core","cell","BorrowRefMut"],"kind":"struct"},"2:22533:4792":{"crate_id":2,"path":["core","core_simd","swizzle","reverse","Reverse"],"kind":"struct"},"1:1497:6184":{"crate_id":1,"path":["std","collections","hash","map","IntoKeys"],"kind":"struct"},"1:9865:7769":{"crate_id":1,"path":["std","sys_common","thread_local_key","Key"],"kind":"struct"},"17:9886:8169":{"crate_id":17,"path":["object","read","any","SymbolIterator"],"kind":"struct"},"17:12208:8432":{"crate_id":17,"path":["object","macho","SubClientCommand"],"kind":"struct"},"17:13799:8884":{"crate_id":17,"path":["object","pe","ImageAlphaRuntimeFunctionEntry"],"kind":"struct"},"1:11594:6143":{"crate_id":1,"path":["std","path","PrefixComponent"],"kind":"struct"},"18:775:7878":{"crate_id":18,"path":["memchr","memmem","x86","avx","nostd","Forward"],"kind":"struct"},"1:1079:4706":{"crate_id":1,"path":["std","ascii","AsciiExt"],"kind":"trait"},"20:3446:56485":{"crate_id":20,"path":["regex_syntax","unicode","ClassQuery"],"kind":"enum"},"12:1666:6963":{"crate_id":12,"path":["hashbrown","rustc_entry","RustcEntry"],"kind":"enum"},"2:52793:6473":{"crate_id":2,"path":["core","core_arch","simd","u8x64"],"kind":"struct"},"1:16005:4439":{"crate_id":1,"path":["std","char"],"kind":"primitive"},"6:4262:10060":{"crate_id":6,"path":["libc","unix","linux_like","linux","mntent"],"kind":"struct"},"21:1178:6017":{"crate_id":21,"path":["aho_corasick","state_id","private","Sealed"],"kind":"trait"},"1:15755:7779":{"crate_id":1,"path":["std","backtrace_rs","symbolize","gimli","mmap","Mmap"],"kind":"struct"},"1:5956:6327":{"crate_id":1,"path":["std","os","unix","net","ancillary","ScmRights"],"kind":"struct"},"16:6366:6970":{"crate_id":16,"path":["gimli","read","line","LineRow"],"kind":"struct"},"22:880:7878":{"crate_id":22,"path":["memchr","memmem","twoway","Forward"],"kind":"struct"},"2:46995:4652":{"crate_id":2,"path":["core","iter","sources","repeat","Repeat"],"kind":"struct"},"17:1236:8079":{"crate_id":17,"path":["object","read","coff","symbol","CoffSymbolIterator"],"kind":"struct"},"2:3439:4856":{"crate_id":2,"path":["core","ops","bit","ShrAssign"],"kind":"trait"},"17:12741:8535":{"crate_id":17,"path":["object","macho","Nlist32"],"kind":"struct"},"6:5210:10226":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","msghdr"],"kind":"struct"},"22:987:3195":{"crate_id":22,"path":["memchr","memmem","Finder"],"kind":"struct"},"6:4347:10104":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_extended_err"],"kind":"struct"},"9:41:6869":{"crate_id":9,"path":["miniz_oxide","deflate","buffer","LocalBuf"],"kind":"struct"},"20:2453:7509":{"crate_id":20,"path":["regex_syntax","ast","ClassUnicodeOpKind"],"kind":"enum"},"6:5167:10208":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","aiocb"],"kind":"struct"},"17:10061:8179":{"crate_id":17,"path":["object","read","coff","file","CoffCommon"],"kind":"struct"},"1:10663:6110":{"crate_id":1,"path":["std","collections","hash","map","RandomState"],"kind":"struct"},"12:2032:3396":{"crate_id":12,"path":["hashbrown","set","Iter"],"kind":"struct"},"2:10240:205":{"crate_id":2,"path":["core","fmt","Result"],"kind":"typedef"},"16:4386:8960":{"crate_id":16,"path":["gimli","constants","DwLle"],"kind":"struct"},"2:46325:5840":{"crate_id":2,"path":["core","char","convert","CharTryFromError"],"kind":"struct"},"1:9067:4573":{"crate_id":1,"path":["std","sync","poison","TryLockError"],"kind":"enum"},"17:10224:8186":{"crate_id":17,"path":["object","read","coff","comdat","CoffComdatSectionIterator"],"kind":"struct"},"20:2616:7518":{"crate_id":20,"path":["regex_syntax","ast","AssertionKind"],"kind":"enum"},"5:3329:3396":{"crate_id":5,"path":["alloc","collections","btree","set","Iter"],"kind":"struct"},"6:6176:10508":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","mcontext_t"],"kind":"struct"},"2:9380:4876":{"crate_id":2,"path":["core","panicking","assert_matches_failed","Pattern"],"kind":"struct"},"2:46977:4568":{"crate_id":2,"path":["core","iter","sources","once","Once"],"kind":"struct"},"16:6644:7130":{"crate_id":16,"path":["gimli","read","loclists","RawLocListEntry"],"kind":"enum"},"17:9719:8166":{"crate_id":17,"path":["object","read","any","SectionIterator"],"kind":"struct"},"6:5221:10234":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","cmsghdr"],"kind":"struct"},"1:16028:4459":{"crate_id":1,"path":["std","usize"],"kind":"primitive"},"16:5580:7283":{"crate_id":16,"path":["gimli","read","cfi","AugmentationData"],"kind":"struct"},"2:46371:5834":{"crate_id":2,"path":["core","char","EscapeUnicodeState"],"kind":"enum"},"2:47534:3396":{"crate_id":2,"path":["core","option","Iter"],"kind":"struct"},"1:10805:6014":{"crate_id":1,"path":["std","fs","OpenOptions"],"kind":"struct"},"20:1945:7488":{"crate_id":20,"path":["regex_syntax","ast","parse","ParserI"],"kind":"struct"},"12:1121:6192":{"crate_id":12,"path":["hashbrown","map","OccupiedEntry"],"kind":"struct"},"2:32497:61868":{"crate_id":2,"path":["core","mem","valid_align","ValidAlignEnum64"],"kind":"enum"},"17:11277:8263":{"crate_id":17,"path":["object","read","CodeView"],"kind":"struct"},"16:7870:7054":{"crate_id":16,"path":["gimli","read","unit","DebugTypes"],"kind":"struct"},"5:1843:7723":{"crate_id":5,"path":["alloc","collections","btree","map","drop","DropGuard"],"kind":"struct"},"1:15093:6126":{"crate_id":1,"path":["std","sys","unix","time","inner","Instant"],"kind":"struct"},"17:9404:8069":{"crate_id":17,"path":["object","endian","I16Bytes"],"kind":"struct"},"2:10312:5349":{"crate_id":2,"path":["core","fmt","UpperExp"],"kind":"trait"},"2:13857:187":{"crate_id":2,"path":["core","future","pending","Pending"],"kind":"struct"},"17:13780:8879":{"crate_id":17,"path":["object","pe","ImageArm64RuntimeFunctionEntry"],"kind":"struct"},"17:10788:8236":{"crate_id":17,"path":["object","read","macho","segment","MachOSegmentIterator"],"kind":"struct"},"1:9775:7768":{"crate_id":1,"path":["std","sys_common","rwlock","StaticRwLockWriteGuard"],"kind":"struct"},"2:49663:1593":{"crate_id":2,"path":["core","str","iter","Matches"],"kind":"struct"},"6:511:7966":{"crate_id":6,"path":["libc","unix","group"],"kind":"struct"},"16:2773:7327":{"crate_id":16,"path":["gimli","common","LineEncoding"],"kind":"struct"},"2:3504:4725":{"crate_id":2,"path":["core","ops","deref","DerefMut"],"kind":"trait"},"1:11094:6041":{"crate_id":1,"path":["std","io","SeekFrom"],"kind":"enum"},"14:244:9234":{"crate_id":14,"path":["rustc_demangle","TryDemangleError"],"kind":"struct"},"16:6424:7124":{"crate_id":16,"path":["gimli","read","line","LineProgramHeader"],"kind":"struct"},"6:4470:10158":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_setup"],"kind":"struct"},"1:11176:6082":{"crate_id":1,"path":["std","net","addr","SocketAddrV4"],"kind":"struct"},"17:12552:8504":{"crate_id":17,"path":["object","macho","EncryptionInfoCommand64"],"kind":"struct"},"1:11189:6083":{"crate_id":1,"path":["std","net","addr","SocketAddrV6"],"kind":"struct"},"16:4535:8965":{"crate_id":16,"path":["gimli","constants","DwVirtuality"],"kind":"struct"},"2:53338:6468":{"crate_id":2,"path":["core","core_arch","simd","u64x8"],"kind":"struct"},"20:2568:7515":{"crate_id":20,"path":["regex_syntax","ast","ClassSetBinaryOp"],"kind":"struct"},"2:23134:6425":{"crate_id":2,"path":["core","core_simd","masks","MaskElement"],"kind":"trait"},"2:51693:6446":{"crate_id":2,"path":["core","core_arch","simd","i64x2"],"kind":"struct"},"16:7342:7081":{"crate_id":16,"path":["gimli","read","rnglists","RawRange"],"kind":"struct"},"1:13919:6163":{"crate_id":1,"path":["std","sys","unix","process","process_common","Command"],"kind":"struct"},"13:232:9656":{"crate_id":13,"path":["std_detect","detect","cache","Initializer"],"kind":"struct"},"5:3759:3396":{"crate_id":5,"path":["alloc","collections","linked_list","Iter"],"kind":"struct"},"2:49509:4901":{"crate_id":2,"path":["core","str","iter","SplitTerminator"],"kind":"struct"},"5:920:96":{"crate_id":5,"path":["alloc","collections","binary_heap","BinaryHeap"],"kind":"struct"},"1:7799:6170":{"crate_id":1,"path":["std","process","Termination"],"kind":"trait"},"2:24126:9337":{"crate_id":2,"path":["core","num","flt2dec","decoder","Decoded"],"kind":"struct"},"22:812:7878":{"crate_id":22,"path":["memchr","memmem","genericsimd","Forward"],"kind":"struct"},"1:3740:6052":{"crate_id":1,"path":["std","io","buffered","linewriter","LineWriter"],"kind":"struct"},"1:15332:6088":{"crate_id":1,"path":["std","sys_common","net","LookupHost"],"kind":"struct"},"2:24734:165":{"crate_id":2,"path":["core","num","nonzero","NonZeroI16"],"kind":"struct"},"17:11482:8289":{"crate_id":17,"path":["object","elf","Ident"],"kind":"struct"},"1:786:7769":{"crate_id":1,"path":["std","thread","local","fast","Key"],"kind":"struct"},"6:4095:10026":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_rumble_effect"],"kind":"struct"},"1:1655:6194":{"crate_id":1,"path":["std","collections","hash","map","OccupiedError"],"kind":"struct"},"20:2225:1960":{"crate_id":20,"path":["regex_syntax","ast","Literal"],"kind":"struct"},"2:3716:4859":{"crate_id":2,"path":["core","ops","range","OneSidedRange"],"kind":"trait"},"17:13637:8823":{"crate_id":17,"path":["object","pe","ImageLoadConfigDirectory32"],"kind":"struct"},"17:11794:8359":{"crate_id":17,"path":["object","elf","Vernaux"],"kind":"struct"},"2:23868:6632":{"crate_id":2,"path":["core","num","bignum","Big32x40"],"kind":"struct"},"16:2945:7326":{"crate_id":16,"path":["gimli","common","DebugLineOffset"],"kind":"struct"},"16:5736:7105":{"crate_id":16,"path":["gimli","read","cfi","UnwindTable"],"kind":"struct"},"2:3745:4863":{"crate_id":2,"path":["core","ops","try_trait","NeverShortCircuit"],"kind":"struct"},"21:1868:7943":{"crate_id":21,"path":["aho_corasick","prefilter","RareBytesBuilder"],"kind":"struct"},"1:15510:6981":{"crate_id":1,"path":["std","backtrace_rs","backtrace","libunwind","Frame"],"kind":"enum"},"6:5159:10206":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","statx_timestamp"],"kind":"struct"},"2:48632:73":{"crate_id":2,"path":["core","fmt","Arguments"],"kind":"struct"},"6:1760:9888":{"crate_id":6,"path":["libc","unix","linux_like","sigevent"],"kind":"struct"},"2:12524:3023":{"crate_id":2,"path":["core","str","converts","from_utf8"],"kind":"function"},"2:49459:1598":{"crate_id":2,"path":["core","str","iter","Split"],"kind":"struct"},"17:10489:7464":{"crate_id":17,"path":["object","read","elf","version","VerdefIterator"],"kind":"struct"},"1:16026:4457":{"crate_id":1,"path":["std","u128"],"kind":"primitive"},"1:8929:6307":{"crate_id":1,"path":["std","sync","once","WaiterQueue"],"kind":"struct"},"2:47671:5483":{"crate_id":2,"path":["core","result","IterMut"],"kind":"struct"},"2:3757:6531":{"crate_id":2,"path":["core","ops","try_trait","NeverShortCircuitResidual"],"kind":"enum"},"5:8368:216":{"crate_id":5,"path":["alloc","string","String"],"kind":"struct"},"12:2404:64149":{"crate_id":12,"path":["hashbrown","raw","Fallibility"],"kind":"enum"},"16:5927:7111":{"crate_id":16,"path":["gimli","read","cfi","CallFrameInstructionIter"],"kind":"struct"},"16:3172:7307":{"crate_id":16,"path":["gimli","common","DebugRngListsBase"],"kind":"struct"},"2:3246:115":{"crate_id":2,"path":["core","default","Default"],"kind":"trait"},"2:8472:3846":{"crate_id":2,"path":["core","iter","traits","exact_size","ExactSizeIterator"],"kind":"trait"},"16:6136:7087":{"crate_id":16,"path":["gimli","read","abbrev","AttributeSpecification"],"kind":"struct"},"20:2267:7502":{"crate_id":20,"path":["regex_syntax","ast","SpecialLiteralKind"],"kind":"enum"},"1:10596:5924":{"crate_id":1,"path":["std","thread","ThreadId"],"kind":"struct"},"1:15046:61192":{"crate_id":1,"path":["std","sys","unix","thread","cgroups","Cgroup"],"kind":"enum"},"17:12671:8527":{"crate_id":17,"path":["object","macho","FvmfileCommand"],"kind":"struct"},"17:12917:8551":{"crate_id":17,"path":["object","pe","ImageDosHeader"],"kind":"struct"},"7:0:1479":{"crate_id":7,"path":["unwind"],"kind":"module"},"6:4501:10168":{"crate_id":6,"path":["libc","unix","linux_like","linux","mq_attr"],"kind":"struct"},"2:46021:4860":{"crate_id":2,"path":["core","ops","try_trait","Yeet"],"kind":"struct"},"2:2887:104":{"crate_id":2,"path":["core","clone","Clone"],"kind":"trait"},"6:670:43088":{"crate_id":6,"path":["libc","unix","linux_like","timezone"],"kind":"enum"},"2:24870:6636":{"crate_id":2,"path":["core","num","nonzero","NonZeroIsize"],"kind":"struct"},"2:46483:6661":{"crate_id":2,"path":["core","ffi","c_str","FromBytesWithNulErrorKind"],"kind":"enum"},"1:15354:6273":{"crate_id":1,"path":["std","sys_common","net","TcpStream"],"kind":"struct"},"6:4317:10089":{"crate_id":6,"path":["libc","unix","linux_like","linux","inotify_event"],"kind":"struct"},"16:3118:7317":{"crate_id":16,"path":["gimli","common","RawRangeListsOffset"],"kind":"struct"},"2:5029:2644":{"crate_id":2,"path":["core","cell","RefCell"],"kind":"struct"},"17:11696:8336":{"crate_id":17,"path":["object","elf","ProgramHeader64"],"kind":"struct"},"5:8391:6722":{"crate_id":5,"path":["alloc","string","FromUtf16Error"],"kind":"struct"},"6:4425:10137":{"crate_id":6,"path":["libc","unix","linux_like","linux","nlattr"],"kind":"struct"},"2:24700:168":{"crate_id":2,"path":["core","num","nonzero","NonZeroI8"],"kind":"struct"},"2:23086:20161":{"crate_id":2,"path":["core","core_simd","masks","to_bitmask","ToBitMask"],"kind":"trait"},"17:9971:64155":{"crate_id":17,"path":["object","read","any","SectionRelocationIteratorInternal"],"kind":"enum"},"1:3327:6237":{"crate_id":1,"path":["std","fs","metadata"],"kind":"function"},"1:11356:6276":{"crate_id":1,"path":["std","net","tcp","IntoIncoming"],"kind":"struct"},"2:50238:6670":{"crate_id":2,"path":["core","time","FromFloatSecsErrorKind"],"kind":"enum"},"2:46679:4678":{"crate_id":2,"path":["core","iter","adapters","inspect","Inspect"],"kind":"struct"},"2:10310:5348":{"crate_id":2,"path":["core","fmt","LowerExp"],"kind":"trait"},"17:13963:8925":{"crate_id":17,"path":["object","pe","NonPagedDebugInfo"],"kind":"struct"},"2:52435:6429":{"crate_id":2,"path":["core","core_arch","simd","f32x8"],"kind":"struct"},"2:46350:5843":{"crate_id":2,"path":["core","char","decode","DecodeUtf16Error"],"kind":"struct"},"1:11398:6081":{"crate_id":1,"path":["std","os","unix","net","addr","SocketAddr"],"kind":"struct"},"17:10543:8192":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldCache"],"kind":"struct"},"5:8176:6728":{"crate_id":5,"path":["alloc","collections","btree","set_val","SetValZST"],"kind":"struct"},"5:4443:3396":{"crate_id":5,"path":["alloc","collections","vec_deque","iter","Iter"],"kind":"struct"},"1:11361:6277":{"crate_id":1,"path":["std","net","Shutdown"],"kind":"enum"},"16:5522:7098":{"crate_id":16,"path":["gimli","read","cfi","CieOrFde"],"kind":"enum"},"1:11293:4606":{"crate_id":1,"path":["std","net","ip","fmt","Span"],"kind":"struct"},"2:50167:6609":{"crate_id":2,"path":["core","str","LinesAnyMap"],"kind":"struct"},"17:12712:8532":{"crate_id":17,"path":["object","macho","DataInCodeEntry"],"kind":"struct"},"2:3733:137":{"crate_id":2,"path":["core","ops","try_trait","FromResidual"],"kind":"trait"},"12:856:6182":{"crate_id":12,"path":["hashbrown","map","Values"],"kind":"struct"},"2:46986:4651":{"crate_id":2,"path":["core","iter","sources","once_with","OnceWith"],"kind":"struct"},"5:1091:7723":{"crate_id":5,"path":["alloc","collections","binary_heap","drop","DropGuard"],"kind":"struct"},"17:13554:8801":{"crate_id":17,"path":["object","pe","ImageResourceDataEntry"],"kind":"struct"},"5:3039:62821":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Dying"],"kind":"enum"},"18:713:4792":{"crate_id":18,"path":["memchr","memmem","twoway","Reverse"],"kind":"struct"},"2:10579:5527":{"crate_id":2,"path":["core","hash","BuildHasherDefault"],"kind":"struct"},"17:10673:50105":{"crate_id":17,"path":["object","read","macho","load_command","LoadCommandVariant"],"kind":"enum"},"20:3482:1828":{"crate_id":20,"path":["regex_syntax","utf8","Utf8Sequence"],"kind":"enum"},"6:4431:10140":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_nl"],"kind":"struct"},"2:7927:4647":{"crate_id":2,"path":["core","iter","range","Step"],"kind":"trait"},"2:49039:6719":{"crate_id":2,"path":["core","slice","ascii","EscapeByte"],"kind":"struct"},"2:56374:236":{"crate_id":2,"path":["core","core_simd","fmt","fmt","Wrapper"],"kind":"struct"},"5:4699:7727":{"crate_id":5,"path":["alloc","collections","vec_deque","truncate","Dropper"],"kind":"struct"},"1:11204:6085":{"crate_id":1,"path":["std","net","ip","IpAddr"],"kind":"enum"},"6:6899:10554":{"crate_id":6,"path":["libc","unix","linux_like","linux","can_frame"],"kind":"struct"},"5:4628:235":{"crate_id":5,"path":["alloc","collections","vec_deque","VecDeque"],"kind":"struct"},"16:6391:7123":{"crate_id":16,"path":["gimli","read","line","ColumnType"],"kind":"enum"},"15:269:6977":{"crate_id":15,"path":["addr2line","RangeAttributes"],"kind":"struct"},"12:2412:9662":{"crate_id":12,"path":["hashbrown","raw","TableLayout"],"kind":"struct"},"1:4727:5339":{"crate_id":1,"path":["std","io","Write"],"kind":"trait"},"6:4300:10080":{"crate_id":6,"path":["libc","unix","linux_like","linux","in6_pktinfo"],"kind":"struct"},"1:8977:4579":{"crate_id":1,"path":["std","sync","once_lock","OnceLock"],"kind":"struct"},"2:47797:81":{"crate_id":2,"path":["core","sync","atomic","AtomicI16"],"kind":"struct"},"16:2968:7304":{"crate_id":16,"path":["gimli","common","DebugLineStrOffset"],"kind":"struct"},"5:4242:7723":{"crate_id":5,"path":["alloc","collections","vec_deque","drain","drop","DropGuard"],"kind":"struct"},"1:12167:6218":{"crate_id":1,"path":["std","sync","mpsc","TryRecvError"],"kind":"enum"},"17:10407:7389":{"crate_id":17,"path":["object","read","elf","comdat","ElfComdatIterator"],"kind":"struct"},"2:50179:6613":{"crate_id":2,"path":["core","str","CharEscapeDefault"],"kind":"struct"},"6:3990:9977":{"crate_id":6,"path":["libc","unix","linux_like","linux","sembuf"],"kind":"struct"},"1:4475:6061":{"crate_id":1,"path":["std","io","stdio","Stdout"],"kind":"struct"},"1:1501:6185":{"crate_id":1,"path":["std","collections","hash","map","IntoValues"],"kind":"struct"},"1:14602:6233":{"crate_id":1,"path":["std","sys","unix","fs","FileTimes"],"kind":"struct"},"2:3371:4845":{"crate_id":2,"path":["core","ops","arith","SubAssign"],"kind":"trait"},"1:11670:6147":{"crate_id":1,"path":["std","path","Ancestors"],"kind":"struct"},"1:11424:6275":{"crate_id":1,"path":["std","os","unix","net","listener","Incoming"],"kind":"struct"},"2:49043:5956":{"crate_id":2,"path":["core","slice","ascii","EscapeAscii"],"kind":"struct"},"1:10878:6053":{"crate_id":1,"path":["std","io","cursor","Cursor"],"kind":"struct"},"16:2794:7033":{"crate_id":16,"path":["gimli","common","Register"],"kind":"struct"},"2:3426:4853":{"crate_id":2,"path":["core","ops","bit","BitOrAssign"],"kind":"trait"},"1:14644:61190":{"crate_id":1,"path":["std","sys","unix","kernel_copy","SpliceMode"],"kind":"enum"},"22:137:4786":{"crate_id":22,"path":["memchr","memchr","iter","Memchr"],"kind":"struct"},"16:4506:8964":{"crate_id":16,"path":["gimli","constants","DwVis"],"kind":"struct"},"17:12632:8524":{"crate_id":17,"path":["object","macho","LinkerOptionCommand"],"kind":"struct"},"2:49445:1814":{"crate_id":2,"path":["core","str","iter","Bytes"],"kind":"struct"},"5:5833:2002":{"crate_id":5,"path":["alloc","slice","Concat"],"kind":"trait"},"16:7477:7070":{"crate_id":16,"path":["gimli","read","unit","UnitType"],"kind":"enum"},"6:4377:10120":{"crate_id":6,"path":["libc","unix","linux_like","linux","j1939_filter"],"kind":"struct"},"16:5273:7295":{"crate_id":16,"path":["gimli","constants","DwEhPe"],"kind":"struct"},"2:47755:91":{"crate_id":2,"path":["core","sync","atomic","AtomicU8"],"kind":"struct"},"2:14239:5443":{"crate_id":2,"path":["core","alloc","Allocator"],"kind":"trait"},"2:50175:6614":{"crate_id":2,"path":["core","str","CharEscapeUnicode"],"kind":"struct"},"21:1571:2648":{"crate_id":21,"path":["aho_corasick","packed","api","MatchKind"],"kind":"enum"},"5:6688:6763":{"crate_id":5,"path":["alloc","sync","ArcInner"],"kind":"struct"},"17:13465:8777":{"crate_id":17,"path":["object","pe","ImageTlsDirectory32"],"kind":"struct"},"17:13098:8692":{"crate_id":17,"path":["object","pe","ImageRomOptionalHeader"],"kind":"struct"},"1:6941:5993":{"crate_id":1,"path":["std","os","fd","owned","OwnedFd"],"kind":"struct"},"2:22580:61700":{"crate_id":2,"path":["core","core_simd","swizzle","interleave","Hi"],"kind":"struct"},"9:963:6884":{"crate_id":9,"path":["miniz_oxide","MZFlush"],"kind":"enum"},"5:5903:1338":{"crate_id":5,"path":["alloc","str"],"kind":"module"},"1:15413:6281":{"crate_id":1,"path":["std","sys_common","net","UdpSocket"],"kind":"struct"},"16:5433:7093":{"crate_id":16,"path":["gimli","read","cfi","EhFrame"],"kind":"struct"},"17:13386:8755":{"crate_id":17,"path":["object","pe","ImageLinenumber"],"kind":"struct"},"6:605:9731":{"crate_id":6,"path":["libc","unix","sigval"],"kind":"struct"},"2:50055:6394":{"crate_id":2,"path":["core","str","pattern","TwoWaySearcher"],"kind":"struct"},"1:9722:6268":{"crate_id":1,"path":["std","sys_common","remutex","ReentrantMutex"],"kind":"struct"},"1:1153:9457":{"crate_id":1,"path":["std","backtrace","BacktraceFrame"],"kind":"struct"},"2:46688:4688":{"crate_id":2,"path":["core","iter","adapters","intersperse","Intersperse"],"kind":"struct"},"16:7360:194":{"crate_id":16,"path":["gimli","read","rnglists","Range"],"kind":"struct"},"1:5377:6273":{"crate_id":1,"path":["std","net","tcp","TcpStream"],"kind":"struct"},"1:4436:6059":{"crate_id":1,"path":["std","io","stdio","Stdin"],"kind":"struct"},"6:0:798":{"crate_id":6,"path":["libc"],"kind":"module"},"2:4739:6521":{"crate_id":2,"path":["core","asserting","TryCaptureWithDebug"],"kind":"struct"},"17:13453:8771":{"crate_id":17,"path":["object","pe","ImageTlsDirectory64"],"kind":"struct"},"5:7780:234":{"crate_id":5,"path":["alloc","vec","Vec"],"kind":"struct"},"2:49776:4891":{"crate_id":2,"path":["core","str","iter","EscapeUnicode"],"kind":"struct"},"2:8601:157":{"crate_id":2,"path":["core","iter","traits","iterator","Iterator"],"kind":"trait"},"2:53515:9445":{"crate_id":2,"path":["core","core_arch","x86","__m128bh"],"kind":"struct"},"17:13041:8654":{"crate_id":17,"path":["object","pe","ImageFileHeader"],"kind":"struct"},"1:11571:2280":{"crate_id":1,"path":["std","path","State"],"kind":"enum"},"5:5315:200":{"crate_id":5,"path":["alloc","rc","Rc"],"kind":"struct"},"6:88:42690":{"crate_id":6,"path":["libc","unix","DIR"],"kind":"enum"},"6:4364:10115":{"crate_id":6,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_j1939"],"kind":"struct"},"17:13272:8730":{"crate_id":17,"path":["object","pe","ImageSymbolBytes"],"kind":"struct"},"1:14571:10651":{"crate_id":1,"path":["std","sys","unix","fs","StatxExtraFields"],"kind":"struct"},"2:12734:6602":{"crate_id":2,"path":["core","str","iter","SplitInternal"],"kind":"struct"},"1:897:5936":{"crate_id":1,"path":["std","thread","scoped","Scope"],"kind":"struct"},"17:11555:8308":{"crate_id":17,"path":["object","elf","CompressionHeader64"],"kind":"struct"},"1:6865:5995":{"crate_id":1,"path":["std","os","fd","raw","FromRawFd"],"kind":"trait"},"17:12118:8420":{"crate_id":17,"path":["object","macho","Section64"],"kind":"struct"},"16:6999:7134":{"crate_id":16,"path":["gimli","read","op","Piece"],"kind":"struct"},"12:787:6184":{"crate_id":12,"path":["hashbrown","map","IntoKeys"],"kind":"struct"},"2:6892:4689":{"crate_id":2,"path":["core","iter","adapters","intersperse","IntersperseWith"],"kind":"struct"},"2:52003:6472":{"crate_id":2,"path":["core","core_arch","simd","u8x32"],"kind":"struct"},"17:10160:8182":{"crate_id":17,"path":["object","read","coff","symbol","CoffSymbolTable"],"kind":"struct"},"2:5207:4720":{"crate_id":2,"path":["core","cell","SyncUnsafeCell"],"kind":"struct"},"2:51718:6428":{"crate_id":2,"path":["core","core_arch","simd","f32x4"],"kind":"struct"},"21:1645:7547":{"crate_id":21,"path":["aho_corasick","packed","pattern","Patterns"],"kind":"struct"},"17:11337:7460":{"crate_id":17,"path":["object","read","CompressionFormat"],"kind":"enum"},"2:51027:9384":{"crate_id":2,"path":["core","core_arch","simd","u8x2"],"kind":"struct"},"2:49983:6390":{"crate_id":2,"path":["core","str","pattern","CharPredicateSearcher"],"kind":"struct"},"16:5766:7107":{"crate_id":16,"path":["gimli","read","cfi","UnwindTableRow"],"kind":"struct"},"17:10448:7454":{"crate_id":17,"path":["object","read","elf","note","NoteIterator"],"kind":"struct"},"1:3329:6238":{"crate_id":1,"path":["std","fs","symlink_metadata"],"kind":"function"},"1:2576:127":{"crate_id":1,"path":["std","error","Error"],"kind":"trait"},"1:8197:7751":{"crate_id":1,"path":["std","sync","mpsc","spsc_queue","Queue"],"kind":"struct"},"1:1534:6190":{"crate_id":1,"path":["std","collections","hash","map","RawEntryBuilder"],"kind":"struct"},"7:38:47589":{"crate_id":7,"path":["unwind","libunwind","_Unwind_Reason_Code"],"kind":"enum"},"17:12494:8494":{"crate_id":17,"path":["object","macho","RpathCommand"],"kind":"struct"},"1:11116:4672":{"crate_id":1,"path":["std","io","Chain"],"kind":"struct"},"16:5421:7092":{"crate_id":16,"path":["gimli","read","cfi","EhHdrTable"],"kind":"struct"},"2:5038:4711":{"crate_id":2,"path":["core","cell","BorrowMutError"],"kind":"struct"},"2:50034:6392":{"crate_id":2,"path":["core","str","pattern","StrSearcherImpl"],"kind":"enum"},"17:12507:8495":{"crate_id":17,"path":["object","macho","LinkeditDataCommand"],"kind":"struct"},"1:16006:4440":{"crate_id":1,"path":["std","unit"],"kind":"primitive"},"2:49417:4889":{"crate_id":2,"path":["core","str","error","ParseBoolError"],"kind":"struct"},"2:3434:4855":{"crate_id":2,"path":["core","ops","bit","ShlAssign"],"kind":"trait"},"1:7445:185":{"crate_id":1,"path":["std","path","Path"],"kind":"struct"},"1:16003:4437":{"crate_id":1,"path":["std","bool"],"kind":"primitive"},"17:12645:8525":{"crate_id":17,"path":["object","macho","SymsegCommand"],"kind":"struct"},"16:3392:7318":{"crate_id":16,"path":["gimli","common","UnitSectionOffset"],"kind":"enum"},"2:14129:201":{"crate_id":2,"path":["core","task","ready","Ready"],"kind":"struct"},"6:6028:10445":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stat64"],"kind":"struct"},"17:11118:49923":{"crate_id":17,"path":["object","read","SymbolSection"],"kind":"enum"},"18:745:64162":{"crate_id":18,"path":["memchr","memmem","twoway","SuffixKind"],"kind":"enum"},"5:6672:4561":{"crate_id":5,"path":["alloc","sync","Weak"],"kind":"struct"},"17:12307:8448":{"crate_id":17,"path":["object","macho","RoutinesCommand64"],"kind":"struct"},"6:1547:9760":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr"],"kind":"struct"},"17:10656:8204":{"crate_id":17,"path":["object","read","macho","load_command","LoadCommandData"],"kind":"struct"},"17:10435:8188":{"crate_id":17,"path":["object","read","elf","comdat","ElfComdatSectionIterator"],"kind":"struct"},"18:705:7878":{"crate_id":18,"path":["memchr","memmem","twoway","Forward"],"kind":"struct"},"2:3521:131":{"crate_id":2,"path":["core","ops","function","FnMut"],"kind":"trait"},"17:10149:8169":{"crate_id":17,"path":["object","read","coff","symbol","SymbolIterator"],"kind":"struct"},"20:3284:1995":{"crate_id":20,"path":["regex_syntax","hir","Group"],"kind":"struct"},"22:920:64162":{"crate_id":22,"path":["memchr","memmem","twoway","SuffixKind"],"kind":"enum"},"15:0:4419":{"crate_id":15,"path":["addr2line"],"kind":"module"},"2:49877:6384":{"crate_id":2,"path":["core","str","pattern","MultiCharEqSearcher"],"kind":"struct"},"2:7669:2992":{"crate_id":2,"path":["core","iter","adapters","zip","zip"],"kind":"function"},"16:7279:7351":{"crate_id":16,"path":["gimli","read","rnglists","RangeListsFormat"],"kind":"enum"},"17:10081:7404":{"crate_id":17,"path":["object","read","coff","section","SectionTable"],"kind":"struct"},"17:13520:8793":{"crate_id":17,"path":["object","pe","ImageResourceDirectory"],"kind":"struct"},"21:1686:1622":{"crate_id":21,"path":["aho_corasick","packed","teddy","compile","Compiler"],"kind":"struct"},"1:16011:4444":{"crate_id":1,"path":["std","str"],"kind":"primitive"},"6:3945:9955":{"crate_id":6,"path":["libc","unix","linux_like","linux","itimerspec"],"kind":"struct"},"2:10300:5344":{"crate_id":2,"path":["core","fmt","Octal"],"kind":"trait"},"17:9759:8167":{"crate_id":17,"path":["object","read","any","ComdatIterator"],"kind":"struct"},"17:12095:8414":{"crate_id":17,"path":["object","macho","Section32"],"kind":"struct"},"2:48495:67":{"crate_id":2,"path":["core","fmt","Alignment"],"kind":"enum"},"16:3041:7306":{"crate_id":16,"path":["gimli","common","DebugLocListsIndex"],"kind":"struct"},"17:9133:49920":{"crate_id":17,"path":["object","common","RelocationEncoding"],"kind":"enum"},"2:53047:6461":{"crate_id":2,"path":["core","core_arch","simd","u16x32"],"kind":"struct"},"2:46431:5838":{"crate_id":2,"path":["core","char","CaseMappingIter"],"kind":"enum"},"16:3264:7311":{"crate_id":16,"path":["gimli","common","DebugStrOffsetsIndex"],"kind":"struct"},"17:10844:7406":{"crate_id":17,"path":["object","read","macho","symbol","SymbolTable"],"kind":"struct"},"17:11519:8303":{"crate_id":17,"path":["object","elf","SectionHeader64"],"kind":"struct"},"1:6791:6099":{"crate_id":1,"path":["std","os","linux","process","ChildExt"],"kind":"trait"},"22:1025:5896":{"crate_id":22,"path":["memchr","memmem","NeedleInfo"],"kind":"struct"},"6:1658:9837":{"crate_id":6,"path":["libc","unix","linux_like","in_pktinfo"],"kind":"struct"},"2:53477:9443":{"crate_id":2,"path":["core","core_arch","x86","__m512"],"kind":"struct"},"14:194:48263":{"crate_id":14,"path":["rustc_demangle","DemangleStyle"],"kind":"enum"},"1:4514:6057":{"crate_id":1,"path":["std","io","stdio","Stderr"],"kind":"struct"},"5:8463:5447":{"crate_id":5,"path":["alloc","vec","splice","Splice"],"kind":"struct"},"16:5360:7089":{"crate_id":16,"path":["gimli","read","cfi","DebugFrame"],"kind":"struct"},"9:749:6821":{"crate_id":9,"path":["miniz_oxide","deflate","core","TDEFLStatus"],"kind":"enum"},"20:2992:56482":{"crate_id":20,"path":["regex_syntax","hir","translate","HirFrame"],"kind":"enum"},"6:4040:9998":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_replay"],"kind":"struct"},"20:3220:4603":{"crate_id":20,"path":["regex_syntax","hir","ClassBytesIter"],"kind":"struct"},"2:46587:4672":{"crate_id":2,"path":["core","iter","adapters","chain","Chain"],"kind":"struct"},"17:12582:8507":{"crate_id":17,"path":["object","macho","BuildVersionCommand"],"kind":"struct"},"2:49751:4880":{"crate_id":2,"path":["core","str","iter","EncodeUtf16"],"kind":"struct"},"15:230:6972":{"crate_id":15,"path":["addr2line","LocationRangeIter"],"kind":"struct"},"16:5595:7100":{"crate_id":16,"path":["gimli","read","cfi","CommonInformationEntry"],"kind":"struct"},"1:14551:6100":{"crate_id":1,"path":["std","sys","unix","fd","FileDesc"],"kind":"struct"},"16:5472:7095":{"crate_id":16,"path":["gimli","read","cfi","BaseAddresses"],"kind":"struct"},"21:1809:7937":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","Mask128"],"kind":"struct"},"2:3357:4839":{"crate_id":2,"path":["core","ops","arith","Rem"],"kind":"trait"},"2:6437:4676":{"crate_id":2,"path":["core","iter","adapters","flatten","FlatMap"],"kind":"struct"},"2:3647:4858":{"crate_id":2,"path":["core","ops","range","RangeBounds"],"kind":"trait"},"5:994:1838":{"crate_id":5,"path":["alloc","collections","binary_heap","Hole"],"kind":"struct"},"12:2253:6191":{"crate_id":12,"path":["hashbrown","set","Entry"],"kind":"enum"},"18:767:7888":{"crate_id":18,"path":["memchr","memmem","twoway","ApproximateByteSet"],"kind":"struct"},"17:13054:8661":{"crate_id":17,"path":["object","pe","ImageDataDirectory"],"kind":"struct"},"6:5969:10411":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","flock"],"kind":"struct"},"2:24802:167":{"crate_id":2,"path":["core","num","nonzero","NonZeroI64"],"kind":"struct"},"20:1894:7485":{"crate_id":20,"path":["regex_syntax","ast","parse","Primitive"],"kind":"enum"},"17:9264:8157":{"crate_id":17,"path":["object","endian","LittleEndian"],"kind":"struct"},"2:6633:62420":{"crate_id":2,"path":["core","iter","adapters","flatten","TrustedConstSize"],"kind":"trait"},"16:4852:8974":{"crate_id":16,"path":["gimli","constants","DwDefaulted"],"kind":"struct"},"6:5469:10350":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","utmpx"],"kind":"struct"},"20:3038:127":{"crate_id":20,"path":["regex_syntax","hir","Error"],"kind":"struct"},"22:300:3132":{"crate_id":22,"path":["memchr","memmem"],"kind":"module"},"2:51866:9394":{"crate_id":2,"path":["core","core_arch","simd","m16x8"],"kind":"struct"},"2:47004:4654":{"crate_id":2,"path":["core","iter","sources","repeat_with","RepeatWith"],"kind":"struct"},"20:2727:1997":{"crate_id":20,"path":["regex_syntax","ast","GroupKind"],"kind":"enum"},"20:2961:7969":{"crate_id":20,"path":["regex_syntax","hir","print","PrinterBuilder"],"kind":"struct"},"5:8115:3395":{"crate_id":5,"path":["alloc","collections","binary_heap","IntoIter"],"kind":"struct"},"6:4255:6293":{"crate_id":6,"path":["libc","unix","linux_like","linux","ucred"],"kind":"struct"},"2:12771:6603":{"crate_id":2,"path":["core","str","iter","SplitNInternal"],"kind":"struct"},"16:5029:8979":{"crate_id":16,"path":["gimli","constants","DwRle"],"kind":"struct"},"2:47713:84":{"crate_id":2,"path":["core","sync","atomic","AtomicI8"],"kind":"struct"},"2:57675:9455":{"crate_id":2,"path":["core","core_simd","vector","ptr","SimdConstPtr"],"kind":"struct"},"2:3491:116":{"crate_id":2,"path":["core","ops","deref","Deref"],"kind":"trait"},"2:9973:6587":{"crate_id":2,"path":["core","fmt","builders","PadAdapter"],"kind":"struct"},"2:8366:4661":{"crate_id":2,"path":["core","iter","traits","accum","Product"],"kind":"trait"},"17:12783:8542":{"crate_id":17,"path":["object","macho","RelocationInfo"],"kind":"struct"},"2:13078:4877":{"crate_id":2,"path":["core","str","pattern","ReverseSearcher"],"kind":"trait"},"22:977:5893":{"crate_id":22,"path":["memchr","memmem","FindRevIter"],"kind":"struct"},"2:2396:4726":{"crate_id":2,"path":["core","ptr","non_null","NonNull"],"kind":"struct"},"2:46470:6660":{"crate_id":2,"path":["core","ffi","c_str","FromBytesWithNulError"],"kind":"struct"},"9:1056:6879":{"crate_id":9,"path":["miniz_oxide","DataFormat"],"kind":"enum"},"2:46970:4649":{"crate_id":2,"path":["core","iter","sources","from_fn","FromFn"],"kind":"struct"},"1:10381:9565":{"crate_id":1,"path":["std","backtrace_rs","symbolize","SymbolName"],"kind":"struct"},"17:12699:8531":{"crate_id":17,"path":["object","macho","SourceVersionCommand"],"kind":"struct"},"2:51489:6459":{"crate_id":2,"path":["core","core_arch","simd","u16x8"],"kind":"struct"},"5:432:2019":{"crate_id":5,"path":["alloc","boxed","Box"],"kind":"struct"},"1:11066:1958":{"crate_id":1,"path":["std","io","util","Empty"],"kind":"struct"},"17:9592:128":{"crate_id":17,"path":["object","read","any","File"],"kind":"struct"},"5:2262:6786":{"crate_id":5,"path":["alloc","collections","btree","navigate","LeafRange"],"kind":"struct"},"2:48829:2280":{"crate_id":2,"path":["core","hash","sip","State"],"kind":"struct"},"6:5292:10270":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","rtentry"],"kind":"struct"},"6:6185:10511":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","ipc_perm"],"kind":"struct"},"16:6176:7117":{"crate_id":16,"path":["gimli","read","aranges","ArangeHeader"],"kind":"struct"},"1:4745:6040":{"crate_id":1,"path":["std","io","Seek"],"kind":"trait"},"5:5093:660":{"crate_id":5,"path":["alloc","fmt"],"kind":"module"},"16:2991:7315":{"crate_id":16,"path":["gimli","common","LocationListsOffset"],"kind":"struct"},"18:755:64163":{"crate_id":18,"path":["memchr","memmem","twoway","SuffixOrdering"],"kind":"enum"},"2:3388:4849":{"crate_id":2,"path":["core","ops","bit","Not"],"kind":"trait"},"20:1970:7490":{"crate_id":20,"path":["regex_syntax","ast","parse","ClassState"],"kind":"enum"},"6:4459:10152":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_alg"],"kind":"struct"},"2:11162:1598":{"crate_id":2,"path":["core","slice","iter","Split"],"kind":"struct"},"12:353:9657":{"crate_id":12,"path":["hashbrown","raw","RawIterRange"],"kind":"struct"},"17:9729:64157":{"crate_id":17,"path":["object","read","any","SectionIteratorInternal"],"kind":"enum"},"1:1476:5448":{"crate_id":1,"path":["std","collections","hash","map","Drain"],"kind":"struct"},"16:6964:4740":{"crate_id":16,"path":["gimli","read","op","Location"],"kind":"enum"},"18:858:5897":{"crate_id":18,"path":["memchr","memmem","SearcherConfig"],"kind":"struct"},"1:14103:7775":{"crate_id":1,"path":["std","sys","unix","stack_overflow","Handler"],"kind":"struct"},"1:2175:6104":{"crate_id":1,"path":["std","collections","hash","set","Intersection"],"kind":"struct"},"21:1383:5756":{"crate_id":21,"path":["aho_corasick","dfa","Standard"],"kind":"struct"},"17:10502:8190":{"crate_id":17,"path":["object","read","elf","version","VerdauxIterator"],"kind":"struct"},"20:2113:6804":{"crate_id":20,"path":["regex_syntax","ast","Position"],"kind":"struct"},"5:8344:6769":{"crate_id":5,"path":["alloc","ffi","c_str","IntoStringError"],"kind":"struct"},"2:3400:4847":{"crate_id":2,"path":["core","ops","bit","BitOr"],"kind":"trait"},"16:7894:7084":{"crate_id":16,"path":["gimli","read","value","ValueType"],"kind":"enum"},"17:11001:8251":{"crate_id":17,"path":["object","read","pe","section","PeSection"],"kind":"struct"},"2:8235:2053":{"crate_id":2,"path":["core","iter","sources","repeat","repeat"],"kind":"function"},"2:51442:6471":{"crate_id":2,"path":["core","core_arch","simd","u8x16"],"kind":"struct"},"5:8298:6767":{"crate_id":5,"path":["alloc","ffi","c_str","NulError"],"kind":"struct"},"2:2291:6354":{"crate_id":2,"path":["core","ptr","metadata","DynMetadata"],"kind":"struct"},"1:16016:4447":{"crate_id":1,"path":["std","f64"],"kind":"primitive"},"16:7856:7150":{"crate_id":16,"path":["gimli","read","unit","EntriesTreeIter"],"kind":"struct"},"12:777:3395":{"crate_id":12,"path":["hashbrown","map","IntoIter"],"kind":"struct"},"16:4955:8977":{"crate_id":16,"path":["gimli","constants","DwLnct"],"kind":"struct"},"17:12610:8513":{"crate_id":17,"path":["object","macho","DyldInfoCommand"],"kind":"struct"},"16:7024:7349":{"crate_id":16,"path":["gimli","read","op","EvaluationState"],"kind":"enum"},"16:5346:7046":{"crate_id":16,"path":["gimli","read","addr","DebugAddr"],"kind":"struct"},"1:13564:9465":{"crate_id":1,"path":["std","sys","unix","os","SplitPaths"],"kind":"struct"},"5:5837:4879":{"crate_id":5,"path":["alloc","slice","Join"],"kind":"trait"},"12:1203:6951":{"crate_id":12,"path":["hashbrown","map","OccupiedEntryRef"],"kind":"struct"},"2:9260:2645":{"crate_id":2,"path":["core","panic","unwind_safe","AssertUnwindSafe"],"kind":"struct"},"2:37648:4792":{"crate_id":2,"path":["core","cmp","Reverse"],"kind":"struct"},"17:10106:7473":{"crate_id":17,"path":["object","read","coff","section","CoffSegment"],"kind":"struct"},"6:1908:44058":{"crate_id":6,"path":["libc","unix","linux_like","linux","fpos64_t"],"kind":"enum"},"4:0:4412":{"crate_id":4,"path":["rustc_std_workspace_core"],"kind":"module"},"2:3273:3969":{"crate_id":2,"path":["core","marker","Sized"],"kind":"trait"},"1:16019:4450":{"crate_id":1,"path":["std","i32"],"kind":"primitive"},"2:14068:5494":{"crate_id":2,"path":["core","task","wake","Context"],"kind":"struct"},"2:51394:9388":{"crate_id":2,"path":["core","core_arch","simd","f64x1"],"kind":"struct"},"17:12725:8533":{"crate_id":17,"path":["object","macho","NoteCommand"],"kind":"struct"},"6:4033:9995":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_mask"],"kind":"struct"},"16:6357:7122":{"crate_id":16,"path":["gimli","read","line","LineInstructions"],"kind":"struct"},"16:5384:7090":{"crate_id":16,"path":["gimli","read","cfi","EhFrameHdr"],"kind":"struct"},"2:3739:4861":{"crate_id":2,"path":["core","ops","try_trait","Residual"],"kind":"trait"},"16:4671:8968":{"crate_id":16,"path":["gimli","constants","DwId"],"kind":"struct"},"1:1646:6193":{"crate_id":1,"path":["std","collections","hash","map","VacantEntry"],"kind":"struct"},"17:10041:8177":{"crate_id":17,"path":["object","read","archive","ArchiveMemberIterator"],"kind":"struct"},"12:1881:145":{"crate_id":12,"path":["hashbrown","set","HashSet"],"kind":"struct"},"16:3064:7363":{"crate_id":16,"path":["gimli","common","DebugMacinfoOffset"],"kind":"struct"},"6:6124:10469":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user_regs_struct"],"kind":"struct"},"12:2052:6104":{"crate_id":12,"path":["hashbrown","set","Intersection"],"kind":"struct"},"17:10864:8239":{"crate_id":17,"path":["object","read","macho","symbol","MachOSymbolTable"],"kind":"struct"},"6:4341:10101":{"crate_id":6,"path":["libc","unix","linux_like","linux","regmatch_t"],"kind":"struct"},"2:3341:4840":{"crate_id":2,"path":["core","ops","arith","Sub"],"kind":"trait"},"16:6110:7086":{"crate_id":16,"path":["gimli","read","abbrev","Abbreviation"],"kind":"struct"},"17:12343:8454":{"crate_id":17,"path":["object","macho","DysymtabCommand"],"kind":"struct"},"17:11378:7429":{"crate_id":17,"path":["object","read","CompressedData"],"kind":"struct"},"2:3277:217":{"crate_id":2,"path":["core","marker","StructuralEq"],"kind":"trait"},"1:8650:4564":{"crate_id":1,"path":["std","sync","barrier","BarrierWaitResult"],"kind":"struct"},"5:7849:7739":{"crate_id":5,"path":["alloc","vec","dedup_by","FillGapOnDrop"],"kind":"struct"},"2:3999:68":{"crate_id":2,"path":["core","any","Any"],"kind":"trait"},"2:56335:236":{"crate_id":2,"path":["core","core_simd","fmt","fmt","Wrapper"],"kind":"struct"},"5:7453:7723":{"crate_id":5,"path":["alloc","vec","into_iter","drop","DropGuard"],"kind":"struct"},"6:5282:10263":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","nl_mmap_hdr"],"kind":"struct"},"2:13816:61759":{"crate_id":2,"path":["core","future","join","MaybeDone"],"kind":"enum"},"2:74:1433":{"crate_id":2,"path":["core","u32"],"kind":"module"},"2:3811:4866":{"crate_id":2,"path":["core","ops","unsize","DispatchFromDyn"],"kind":"trait"},"17:11616:8319":{"crate_id":17,"path":["object","elf","Syminfo64"],"kind":"struct"},"2:10924:6017":{"crate_id":2,"path":["core","slice","index","private_slice_index","Sealed"],"kind":"trait"},"2:48839:9375":{"crate_id":2,"path":["core","hash","sip","Sip13Rounds"],"kind":"struct"},"20:3025:7521":{"crate_id":20,"path":["regex_syntax","hir","translate","Flags"],"kind":"struct"},"2:2956:177":{"crate_id":2,"path":["core","cmp","Ord"],"kind":"trait"},"6:4478:10160":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_user_dev"],"kind":"struct"},"2:3405:4848":{"crate_id":2,"path":["core","ops","bit","BitXor"],"kind":"trait"},"20:2951:1960":{"crate_id":20,"path":["regex_syntax","hir","literal","Literal"],"kind":"struct"},"2:2920:183":{"crate_id":2,"path":["core","cmp","PartialEq"],"kind":"trait"},"16:5231:8980":{"crate_id":16,"path":["gimli","constants","DwOp"],"kind":"struct"},"20:2977:8047":{"crate_id":20,"path":["regex_syntax","hir","translate","TranslatorBuilder"],"kind":"struct"},"2:32397:61867":{"crate_id":2,"path":["core","mem","valid_align","ValidAlignEnum32"],"kind":"enum"},"22:0:1551":{"crate_id":22,"path":["memchr"],"kind":"module"},"2:32337:4637":{"crate_id":2,"path":["core","mem","valid_align","ValidAlign"],"kind":"struct"},"1:3345:6243":{"crate_id":1,"path":["std","fs","canonicalize"],"kind":"function"},"6:4387:10123":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_filter"],"kind":"struct"},"1:12000:6164":{"crate_id":1,"path":["std","process","CommandArgs"],"kind":"struct"},"6:6935:10561":{"crate_id":6,"path":["libc","unix","align","in6_addr"],"kind":"struct"},"17:2484:50006":{"crate_id":17,"path":["object","read","elf","relocation","ElfRelaIterator"],"kind":"enum"},"5:1215:6783":{"crate_id":5,"path":["alloc","collections","btree","borrow","DormantMutRef"],"kind":"struct"},"2:8882:4658":{"crate_id":2,"path":["core","iter","traits","marker","TrustedLen"],"kind":"trait"},"17:9088:49919":{"crate_id":17,"path":["object","common","RelocationKind"],"kind":"enum"},"1:14937:7776":{"crate_id":1,"path":["std","sys","unix","process","process_inner","do_exec","Reset"],"kind":"struct"},"5:8168:194":{"crate_id":5,"path":["alloc","collections","btree","set","Range"],"kind":"struct"},"21:1316:2648":{"crate_id":21,"path":["aho_corasick","ahocorasick","MatchKind"],"kind":"enum"},"1:903:5937":{"crate_id":1,"path":["std","thread","scoped","ScopedJoinHandle"],"kind":"struct"},"16:5561:7099":{"crate_id":16,"path":["gimli","read","cfi","Augmentation"],"kind":"struct"},"18:802:5893":{"crate_id":18,"path":["memchr","memmem","FindRevIter"],"kind":"struct"},"2:47593:4741":{"crate_id":2,"path":["core","panic","panic_info","PanicInfo"],"kind":"struct"},"1:9770:7767":{"crate_id":1,"path":["std","sys_common","rwlock","StaticRwLockReadGuard"],"kind":"struct"},"17:11458:8288":{"crate_id":17,"path":["object","elf","FileHeader64"],"kind":"struct"},"6:4306:10083":{"crate_id":6,"path":["libc","unix","linux_like","linux","arpd_request"],"kind":"struct"},"6:1533:9755":{"crate_id":6,"path":["libc","unix","linux_like","ip_mreqn"],"kind":"struct"},"1:7259:9470":{"crate_id":1,"path":["std","path","fmt","DebugHelper"],"kind":"struct"},"16:4304:8958":{"crate_id":16,"path":["gimli","constants","DwForm"],"kind":"struct"},"5:1674:6185":{"crate_id":5,"path":["alloc","collections","btree","map","IntoValues"],"kind":"struct"},"1:16025:4456":{"crate_id":1,"path":["std","u64"],"kind":"primitive"},"2:8412:4660":{"crate_id":2,"path":["core","iter","traits","collect","Extend"],"kind":"trait"},"6:5522:10361":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","sigset_t"],"kind":"struct"},"1:4438:6060":{"crate_id":1,"path":["std","io","stdio","StdinLock"],"kind":"struct"},"12:1784:7721":{"crate_id":12,"path":["hashbrown","scopeguard","ScopeGuard"],"kind":"struct"},"2:48091:92":{"crate_id":2,"path":["core","sync","atomic","AtomicUsize"],"kind":"struct"},"1:10958:4599":{"crate_id":1,"path":["std","io","error","ErrorKind"],"kind":"enum"},"1:11475:5992":{"crate_id":1,"path":["std","os","fd","owned","BorrowedFd"],"kind":"struct"},"18:152:4787":{"crate_id":18,"path":["memchr","memchr","iter","Memchr2"],"kind":"struct"},"17:11628:8320":{"crate_id":17,"path":["object","elf","Rel32"],"kind":"struct"},"16:6126:7115":{"crate_id":16,"path":["gimli","read","abbrev","Attributes"],"kind":"enum"},"6:4013:9986":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_absinfo"],"kind":"struct"},"21:1252:4756":{"crate_id":21,"path":["aho_corasick","ahocorasick","FindOverlappingIter"],"kind":"struct"},"16:5855:7110":{"crate_id":16,"path":["gimli","read","cfi","CallFrameInstruction"],"kind":"enum"},"17:13978:8926":{"crate_id":17,"path":["object","pe","ImageArchitectureEntry"],"kind":"struct"},"17:10529:8191":{"crate_id":17,"path":["object","read","elf","version","VernauxIterator"],"kind":"struct"},"1:1492:6183":{"crate_id":1,"path":["std","collections","hash","map","ValuesMut"],"kind":"struct"},"5:792:108":{"crate_id":5,"path":["alloc","borrow","Cow"],"kind":"enum"},"2:2865:4869":{"crate_id":2,"path":["core","borrow","BorrowMut"],"kind":"trait"},"14:216:48269":{"crate_id":14,"path":["rustc_demangle","SizeLimitedFmtAdapter"],"kind":"struct"},"1:1623:6191":{"crate_id":1,"path":["std","collections","hash","map","Entry"],"kind":"enum"},"2:11113:3396":{"crate_id":2,"path":["core","slice","iter","Iter"],"kind":"struct"},"2:52586:6453":{"crate_id":2,"path":["core","core_arch","simd","i8x64"],"kind":"struct"},"5:6257:5452":{"crate_id":5,"path":["alloc","string","retain","SetLenOnDrop"],"kind":"struct"},"13:0:4411":{"crate_id":13,"path":["std_detect"],"kind":"module"},"17:10584:7435":{"crate_id":17,"path":["object","read","macho","file","MachOFile"],"kind":"struct"},"2:12810:6605":{"crate_id":2,"path":["core","str","iter","MatchesInternal"],"kind":"struct"},"2:51336:6442":{"crate_id":2,"path":["core","core_arch","simd","i32x2"],"kind":"struct"},"2:22837:6533":{"crate_id":2,"path":["core","core_simd","elements","uint","SimdUint"],"kind":"trait"},"18:621:7527":{"crate_id":18,"path":["memchr","cow","Imp"],"kind":"struct"},"21:1615:3152":{"crate_id":21,"path":["aho_corasick","packed","api","Searcher"],"kind":"struct"},"1:12006:181":{"crate_id":1,"path":["std","process","Output"],"kind":"struct"},"21:1656:7556":{"crate_id":21,"path":["aho_corasick","packed","pattern","PatternIter"],"kind":"struct"},"2:10529:142":{"crate_id":2,"path":["core","hash","Hash"],"kind":"trait"},"17:13488:8782":{"crate_id":17,"path":["object","pe","ImageBoundImportDescriptor"],"kind":"struct"},"16:5960:7290":{"crate_id":16,"path":["gimli","read","cfi","PointerEncodingParameters"],"kind":"struct"},"2:50191:6616":{"crate_id":2,"path":["core","str","IsNotEmpty"],"kind":"struct"},"6:4046:10000":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_trigger"],"kind":"struct"},"2:51520:6463":{"crate_id":2,"path":["core","core_arch","simd","u32x4"],"kind":"struct"},"12:2419:4545":{"crate_id":12,"path":["hashbrown","TryReserveError"],"kind":"enum"},"17:9849:64156":{"crate_id":17,"path":["object","read","any","SymbolTableInternal"],"kind":"enum"},"2:3296:5334":{"crate_id":2,"path":["core","marker","Freeze"],"kind":"trait"},"6:569:9711":{"crate_id":6,"path":["libc","unix","hostent"],"kind":"struct"},"1:2031:145":{"crate_id":1,"path":["std","collections","hash","set","HashSet"],"kind":"struct"},"6:4523:10178":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_can"],"kind":"struct"},"16:4995:8978":{"crate_id":16,"path":["gimli","constants","DwMacro"],"kind":"struct"},"2:3274:4723":{"crate_id":2,"path":["core","marker","Unsize"],"kind":"trait"},"5:8362:10565":{"crate_id":5,"path":["alloc","slice","merge_sort","Run"],"kind":"struct"},"5:3040:10563":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Immut"],"kind":"struct"},"17:4157:7436":{"crate_id":17,"path":["object","read","macho","relocation","MachORelocationIterator"],"kind":"struct"},"5:5415:6029":{"crate_id":5,"path":["alloc","rc","from_iter_exact","Guard"],"kind":"struct"},"2:3383:4844":{"crate_id":2,"path":["core","ops","arith","RemAssign"],"kind":"trait"},"22:915:7883":{"crate_id":22,"path":["memchr","memmem","twoway","Suffix"],"kind":"struct"},"9:809:2280":{"crate_id":9,"path":["miniz_oxide","inflate","core","State"],"kind":"enum"},"17:10912:8241":{"crate_id":17,"path":["object","read","pe","file","PeFile"],"kind":"struct"},"2:25240:6558":{"crate_id":2,"path":["core","num","saturating","Saturating"],"kind":"struct"},"6:5945:10394":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","sigaction"],"kind":"struct"},"18:136:4786":{"crate_id":18,"path":["memchr","memchr","iter","Memchr"],"kind":"struct"},"16:3365:7293":{"crate_id":16,"path":["gimli","common","EhFrameOffset"],"kind":"struct"},"16:6591:7129":{"crate_id":16,"path":["gimli","read","loclists","DebugLocLists"],"kind":"struct"},"17:11572:8310":{"crate_id":17,"path":["object","elf","Sym32"],"kind":"struct"},"1:11416:6286":{"crate_id":1,"path":["std","os","unix","net","ancillary","SocketAncillary"],"kind":"struct"},"5:3370:6104":{"crate_id":5,"path":["alloc","collections","btree","set","Intersection"],"kind":"struct"},"20:2197:2006":{"crate_id":20,"path":["regex_syntax","ast","Alternation"],"kind":"struct"},"20:2822:6310":{"crate_id":20,"path":["regex_syntax","ast","Flag"],"kind":"enum"},"2:8403:151":{"crate_id":2,"path":["core","iter","traits","collect","IntoIterator"],"kind":"trait"},"16:4230:8957":{"crate_id":16,"path":["gimli","constants","DwAt"],"kind":"struct"},"2:23462:6426":{"crate_id":2,"path":["core","core_simd","ord","SimdPartialOrd"],"kind":"trait"},"2:49627:4896":{"crate_id":2,"path":["core","str","iter","RMatchIndices"],"kind":"struct"},"2:24836:164":{"crate_id":2,"path":["core","num","nonzero","NonZeroI128"],"kind":"struct"},"14:250:9235":{"crate_id":14,"path":["rustc_demangle","SizeLimitExhausted"],"kind":"struct"},"2:24166:42136":{"crate_id":2,"path":["core","num","flt2dec","Sign"],"kind":"enum"},"1:2187:6106":{"crate_id":1,"path":["std","collections","hash","set","SymmetricDifference"],"kind":"struct"},"17:11604:8316":{"crate_id":17,"path":["object","elf","Syminfo32"],"kind":"struct"},"16:2816:7320":{"crate_id":16,"path":["gimli","common","DebugAbbrevOffset"],"kind":"struct"},"20:2330:7504":{"crate_id":20,"path":["regex_syntax","ast","ClassPerl"],"kind":"struct"},"2:22931:6074":{"crate_id":2,"path":["core","core_simd","lane_count","LaneCount"],"kind":"struct"},"6:591:9723":{"crate_id":6,"path":["libc","unix","winsize"],"kind":"struct"},"6:4101:10029":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_effect"],"kind":"struct"},"6:6100:10458":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_xmmreg"],"kind":"struct"},"2:2282:6353":{"crate_id":2,"path":["core","ptr","metadata","PtrComponents"],"kind":"struct"},"5:8263:4546":{"crate_id":5,"path":["alloc","collections","TryReserveErrorKind"],"kind":"enum"},"2:3558:4864":{"crate_id":2,"path":["core","ops","generator","Generator"],"kind":"trait"},"1:4398:6259":{"crate_id":1,"path":["std","io","stdio","StdinRaw"],"kind":"struct"},"1:15392:6274":{"crate_id":1,"path":["std","sys_common","net","TcpListener"],"kind":"struct"},"2:24010:9330":{"crate_id":2,"path":["core","num","dec2flt","common","AsciiStr"],"kind":"struct"},"1:12731:128":{"crate_id":1,"path":["std","sys","unix","fs","File"],"kind":"struct"},"1:1432:5483":{"crate_id":1,"path":["std","collections","hash","map","IterMut"],"kind":"struct"},"17:10420:7388":{"crate_id":17,"path":["object","read","elf","comdat","ElfComdat"],"kind":"struct"},"2:6510:4666":{"crate_id":2,"path":["core","iter","adapters","flatten","Flatten"],"kind":"struct"},"12:2059:6105":{"crate_id":12,"path":["hashbrown","set","Difference"],"kind":"struct"},"1:1306:143":{"crate_id":1,"path":["std","collections","hash","map","HashMap"],"kind":"struct"},"1:4404:6261":{"crate_id":1,"path":["std","io","stdio","StderrRaw"],"kind":"struct"},"17:10926:8245":{"crate_id":17,"path":["object","read","pe","file","PeComdatIterator"],"kind":"struct"},"6:531:9686":{"crate_id":6,"path":["libc","unix","timespec"],"kind":"struct"},"6:1708:9867":{"crate_id":6,"path":["libc","unix","linux_like","arphdr"],"kind":"struct"},"6:1617:9805":{"crate_id":6,"path":["libc","unix","linux_like","sched_param"],"kind":"struct"},"5:7379:3395":{"crate_id":5,"path":["alloc","vec","into_iter","IntoIter"],"kind":"struct"},"2:9762:79":{"crate_id":2,"path":["core","sync","atomic","AtomicBool"],"kind":"struct"},"2:23125:6017":{"crate_id":2,"path":["core","core_simd","masks","sealed","Sealed"],"kind":"trait"},"12:880:5446":{"crate_id":12,"path":["hashbrown","map","DrainFilter"],"kind":"struct"},"5:5609:1307":{"crate_id":5,"path":["alloc","slice"],"kind":"module"},"17:9551:7372":{"crate_id":17,"path":["object","read","util","ByteString"],"kind":"struct"},"1:15475:9564":{"crate_id":1,"path":["std","alloc","System"],"kind":"struct"},"12:2398:9660":{"crate_id":12,"path":["hashbrown","raw","bitmask","BitMask"],"kind":"struct"},"1:2159:3396":{"crate_id":1,"path":["std","collections","hash","set","Iter"],"kind":"struct"},"17:13180:8704":{"crate_id":17,"path":["object","pe","Guid"],"kind":"struct"},"1:12034:6167":{"crate_id":1,"path":["std","process","ExitStatusError"],"kind":"struct"},"1:2170:5446":{"crate_id":1,"path":["std","collections","hash","set","DrainFilter"],"kind":"struct"},"1:10591:5858":{"crate_id":1,"path":["std","thread","Builder"],"kind":"struct"},"5:8313:6661":{"crate_id":5,"path":["alloc","ffi","c_str","FromBytesWithNulErrorKind"],"kind":"enum"},"17:13760:8873":{"crate_id":17,"path":["object","pe","ImageHotPatchHashes"],"kind":"struct"},"5:1472:6192":{"crate_id":5,"path":["alloc","collections","btree","map","entry","OccupiedEntry"],"kind":"struct"},"21:1297:7529":{"crate_id":21,"path":["aho_corasick","ahocorasick","StreamChunk"],"kind":"enum"},"17:13788:8880":{"crate_id":17,"path":["object","pe","ImageAlpha64RuntimeFunctionEntry"],"kind":"struct"},"18:645:5904":{"crate_id":18,"path":["memchr","memmem","prefilter","PrefilterFn"],"kind":"struct"},"20:3080:1825":{"crate_id":20,"path":["regex_syntax","hir","Hir"],"kind":"struct"},"2:51592:6451":{"crate_id":2,"path":["core","core_arch","simd","i8x16"],"kind":"struct"},"6:4395:10126":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_fprog"],"kind":"struct"},"5:5889:7733":{"crate_id":5,"path":["alloc","slice","merge","MergeHole"],"kind":"struct"},"22:958:7878":{"crate_id":22,"path":["memchr","memmem","x86","sse","Forward"],"kind":"struct"},"2:9978:6588":{"crate_id":2,"path":["core","fmt","builders","PadAdapterState"],"kind":"struct"},"2:52129:6464":{"crate_id":2,"path":["core","core_arch","simd","u32x8"],"kind":"struct"},"21:1336:6132":{"crate_id":21,"path":["aho_corasick","buffer","Buffer"],"kind":"struct"},"6:3997:9981":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_event"],"kind":"struct"},"16:4734:8970":{"crate_id":16,"path":["gimli","constants","DwInl"],"kind":"struct"},"21:1517:7917":{"crate_id":21,"path":["aho_corasick","nfa","IterTransitionsMut"],"kind":"struct"},"1:8742:4578":{"crate_id":1,"path":["std","sync","lazy_lock","LazyLock"],"kind":"struct"},"2:2218:1050":{"crate_id":2,"path":["core","ptr"],"kind":"module"},"12:114:11024":{"crate_id":12,"path":["hashbrown","raw","bitmask","BitMaskIter"],"kind":"struct"},"17:12537:8500":{"crate_id":17,"path":["object","macho","EncryptionInfoCommand32"],"kind":"struct"},"12:2392:1995":{"crate_id":12,"path":["hashbrown","raw","sse2","Group"],"kind":"struct"},"1:14242:6057":{"crate_id":1,"path":["std","sys","unix","stdio","Stderr"],"kind":"struct"},"1:15971:1757":{"crate_id":1,"path":["std","backtrace_rs","symbolize","gimli","Cache"],"kind":"struct"},"2:52082:6460":{"crate_id":2,"path":["core","core_arch","simd","u16x16"],"kind":"struct"},"6:3918:9932":{"crate_id":6,"path":["libc","unix","linux_like","linux","signalfd_siginfo"],"kind":"struct"},"2:24144:42144":{"crate_id":2,"path":["core","num","flt2dec","decoder","FullDecoded"],"kind":"enum"},"2:53299:6448":{"crate_id":2,"path":["core","core_arch","simd","i64x8"],"kind":"struct"},"1:8485:6214":{"crate_id":1,"path":["std","sync","mpsc","Sender"],"kind":"struct"},"16:6252:7120":{"crate_id":16,"path":["gimli","read","line","LineRows"],"kind":"struct"},"1:12738:6231":{"crate_id":1,"path":["std","sys","unix","fs","ReadDir"],"kind":"struct"},"6:4145:10052":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Ehdr"],"kind":"struct"},"16:3714:8953":{"crate_id":16,"path":["gimli","constants","DwUt"],"kind":"struct"},"1:14634:6039":{"crate_id":1,"path":["std","sys","unix","io","IoSlice"],"kind":"struct"},"6:563:9708":{"crate_id":6,"path":["libc","unix","ipv6_mreq"],"kind":"struct"},"1:0:1329":{"crate_id":1,"path":["std"],"kind":"module"},"2:2507:5493":{"crate_id":2,"path":["core","ptr","unique","Unique"],"kind":"struct"},"1:11133:1814":{"crate_id":1,"path":["std","io","Bytes"],"kind":"struct"},"17:9162:7374":{"crate_id":17,"path":["object","common","FileFlags"],"kind":"enum"},"5:6954:6729":{"crate_id":5,"path":["alloc","task","Wake"],"kind":"trait"},"1:11449:6098":{"crate_id":1,"path":["std","os","linux","process","PidFd"],"kind":"struct"},"5:8130:5448":{"crate_id":5,"path":["alloc","collections","binary_heap","Drain"],"kind":"struct"},"9:722:6820":{"crate_id":9,"path":["miniz_oxide","deflate","core","TDEFLFlush"],"kind":"enum"},"1:9643:11508":{"crate_id":1,"path":["std","sys_common","mutex","MovableMutex"],"kind":"struct"},"2:52160:6467":{"crate_id":2,"path":["core","core_arch","simd","u64x4"],"kind":"struct"},"16:3018:7305":{"crate_id":16,"path":["gimli","common","DebugLocListsBase"],"kind":"struct"},"17:10988:8250":{"crate_id":17,"path":["object","read","pe","section","PeSectionIterator"],"kind":"struct"},"2:3268:211":{"crate_id":2,"path":["core","marker","Send"],"kind":"trait"},"2:10933:214":{"crate_id":2,"path":["core","slice","index","SliceIndex"],"kind":"trait"},"16:6620:7333":{"crate_id":16,"path":["gimli","read","loclists","LocListsFormat"],"kind":"enum"},"17:11947:8385":{"crate_id":17,"path":["object","macho","DyldCacheImageInfo"],"kind":"struct"},"2:46028:5748":{"crate_id":2,"path":["core","any","TypeId"],"kind":"struct"},"6:4331:10095":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_vm"],"kind":"struct"},"17:11030:127":{"crate_id":17,"path":["object","read","Error"],"kind":"struct"},"5:69:5445":{"crate_id":5,"path":["alloc","raw_vec","RawVec"],"kind":"struct"},"6:4127:10041":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_abs_setup"],"kind":"struct"},"1:7653:6161":{"crate_id":1,"path":["std","process","ChildStdout"],"kind":"struct"},"2:3580:4857":{"crate_id":2,"path":["core","ops","index","IndexMut"],"kind":"trait"},"2:46779:4685":{"crate_id":2,"path":["core","iter","adapters","take","Take"],"kind":"struct"},"17:13842:8900":{"crate_id":17,"path":["object","pe","ImageEnclaveConfig64"],"kind":"struct"},"6:5347:10307":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","ntptimeval"],"kind":"struct"},"1:10581:58679":{"crate_id":1,"path":["std","thread","local","fast","DtorState"],"kind":"enum"},"2:10291:109":{"crate_id":2,"path":["core","fmt","Debug"],"kind":"trait"},"2:51741:6431":{"crate_id":2,"path":["core","core_arch","simd","f64x2"],"kind":"struct"},"6:6614:10539":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","not_x32","statvfs"],"kind":"struct"},"6:3905:9922":{"crate_id":6,"path":["libc","unix","linux_like","linux","dqblk"],"kind":"struct"},"16:547:7285":{"crate_id":16,"path":["gimli","read","cfi","RegisterRuleMap"],"kind":"struct"},"3:300:205":{"crate_id":3,"path":["compiler_builtins","float","cmp","Result"],"kind":"enum"},"2:51250:9386":{"crate_id":2,"path":["core","core_arch","simd","u64x1"],"kind":"struct"},"1:8293:5926":{"crate_id":1,"path":["std","sync","mpsc","stream","Packet"],"kind":"struct"},"17:12262:8440":{"crate_id":17,"path":["object","macho","DylinkerCommand"],"kind":"struct"},"1:4752:6043":{"crate_id":1,"path":["std","io","BufRead"],"kind":"trait"},"21:1778:7930":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","TeddyFat2Mask256"],"kind":"struct"},"16:7303:7146":{"crate_id":16,"path":["gimli","read","rnglists","RawRngListEntry"],"kind":"enum"},"17:8902:49914":{"crate_id":17,"path":["object","common","AddressSize"],"kind":"enum"},"22:708:7527":{"crate_id":22,"path":["memchr","cow","Imp"],"kind":"enum"},"21:1268:4757":{"crate_id":21,"path":["aho_corasick","ahocorasick","StreamFindIter"],"kind":"struct"},"22:1061:5899":{"crate_id":22,"path":["memchr","memmem","SearcherRev"],"kind":"struct"},"2:50225:6130":{"crate_id":2,"path":["core","time","FromFloatSecsError"],"kind":"struct"},"1:8843:9472":{"crate_id":1,"path":["std","sync","mutex","fmt","LockedPlaceholder"],"kind":"struct"},"5:3048:62820":{"crate_id":5,"path":["alloc","collections","btree","node","marker","ValMut"],"kind":"struct"},"2:46600:4664":{"crate_id":2,"path":["core","iter","adapters","cloned","Cloned"],"kind":"struct"},"12:1103:6191":{"crate_id":12,"path":["hashbrown","map","Entry"],"kind":"enum"},"16:5314:8157":{"crate_id":16,"path":["gimli","endianity","LittleEndian"],"kind":"struct"},"17:11199:8262":{"crate_id":17,"path":["object","read","ObjectMapEntry"],"kind":"struct"},"6:6812:10543":{"crate_id":6,"path":["libc","unix","linux_like","linux","arch","generic","termios2"],"kind":"struct"},"1:4688:6038":{"crate_id":1,"path":["std","io","IoSliceMut"],"kind":"struct"},"20:3535:1829":{"crate_id":20,"path":["regex_syntax","utf8","Utf8Sequences"],"kind":"struct"},"21:1861:3151":{"crate_id":21,"path":["aho_corasick","prefilter","Packed"],"kind":"struct"},"11:46:9664":{"crate_id":11,"path":["adler","algo","U32X4"],"kind":"struct"},"17:13685:8860":{"crate_id":17,"path":["object","pe","ImageLoadConfigDirectory64"],"kind":"struct"},"2:45781:4867":{"crate_id":2,"path":["core","ops","control_flow","ControlFlow"],"kind":"enum"},"2:5630:779":{"crate_id":2,"path":["core","iter"],"kind":"module"},"2:3410:4850":{"crate_id":2,"path":["core","ops","bit","Shl"],"kind":"trait"},"2:2925:124":{"crate_id":2,"path":["core","cmp","Eq"],"kind":"trait"},"22:820:5904":{"crate_id":22,"path":["memchr","memmem","prefilter","PrefilterFn"],"kind":"struct"},"1:10953:6203":{"crate_id":1,"path":["std","io","error","Custom"],"kind":"struct"},"1:11146:4893":{"crate_id":1,"path":["std","io","Lines"],"kind":"struct"},"2:5184:4719":{"crate_id":2,"path":["core","cell","UnsafeCell"],"kind":"struct"},"2:53451:9441":{"crate_id":2,"path":["core","core_arch","x86","__m256d"],"kind":"struct"},"6:4083:10020":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_periodic_effect"],"kind":"struct"},"6:3892:9912":{"crate_id":6,"path":["libc","unix","linux_like","linux","spwd"],"kind":"struct"},"2:46717:4680":{"crate_id":2,"path":["core","iter","adapters","peekable","Peekable"],"kind":"struct"},"17:11026:8253":{"crate_id":17,"path":["object","read","traits","NoDynamicRelocationIterator"],"kind":"struct"},"1:11520:6133":{"crate_id":1,"path":["std","path","Prefix"],"kind":"enum"},"2:3278:106":{"crate_id":2,"path":["core","marker","Copy"],"kind":"trait"},"2:13892:9329":{"crate_id":2,"path":["core","future","poll_fn","PollFn"],"kind":"struct"},"20:2584:7516":{"crate_id":20,"path":["regex_syntax","ast","ClassSetBinaryOpKind"],"kind":"enum"},"2:24182:42145":{"crate_id":2,"path":["core","num","fmt","Part"],"kind":"enum"},"1:13957:6165":{"crate_id":1,"path":["std","sys","unix","process","process_common","Stdio"],"kind":"enum"},"17:13733:8861":{"crate_id":17,"path":["object","pe","ImageHotPatchInfo"],"kind":"struct"},"17:9659:64160":{"crate_id":17,"path":["object","read","any","SegmentIteratorInternal"],"kind":"enum"},"5:923:6774":{"crate_id":5,"path":["alloc","collections","binary_heap","PeekMut"],"kind":"struct"},"5:1011:3396":{"crate_id":5,"path":["alloc","collections","binary_heap","Iter"],"kind":"struct"},"1:6689:6005":{"crate_id":1,"path":["std","os","linux","fs","MetadataExt"],"kind":"trait"},"6:4052:10002":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_envelope"],"kind":"struct"},"6:6923:10559":{"crate_id":6,"path":["libc","unix","linux_like","linux","non_exhaustive","open_how"],"kind":"struct"},"2:51766:6432":{"crate_id":2,"path":["core","core_arch","simd","f64x4"],"kind":"struct"},"17:607:8077":{"crate_id":17,"path":["object","read","any","Comdat"],"kind":"struct"},"2:23079:6017":{"crate_id":2,"path":["core","core_simd","masks","to_bitmask","sealed","Sealed"],"kind":"trait"},"22:1033:5897":{"crate_id":22,"path":["memchr","memmem","SearcherConfig"],"kind":"struct"},"2:46699:4679":{"crate_id":2,"path":["core","iter","adapters","map","Map"],"kind":"struct"},"5:8106:5444":{"crate_id":5,"path":["alloc","alloc","Global"],"kind":"struct"},"6:5563:10387":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","semid_ds"],"kind":"struct"},"6:616:9736":{"crate_id":6,"path":["libc","unix","tms"],"kind":"struct"},"16:5753:7106":{"crate_id":16,"path":["gimli","read","cfi","RegisterRuleIter"],"kind":"struct"},"17:9689:64159":{"crate_id":17,"path":["object","read","any","SegmentInternal"],"kind":"enum"},"16:6731:7339":{"crate_id":16,"path":["gimli","read","lookup","LookupEntryIter"],"kind":"struct"},"12:399:6955":{"crate_id":12,"path":["hashbrown","raw","RawIntoIter"],"kind":"struct"},"17:12598:8511":{"crate_id":17,"path":["object","macho","BuildToolVersion"],"kind":"struct"},"5:7642:5453":{"crate_id":5,"path":["alloc","vec","in_place_drop","InPlaceDrop"],"kind":"struct"},"17:11539:8304":{"crate_id":17,"path":["object","elf","CompressionHeader32"],"kind":"struct"},"21:1853:5858":{"crate_id":21,"path":["aho_corasick","prefilter","Builder"],"kind":"struct"},"6:4203:10056":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Phdr"],"kind":"struct"},"18:791:4755":{"crate_id":18,"path":["memchr","memmem","FindIter"],"kind":"struct"},"1:6086:6283":{"crate_id":1,"path":["std","os","unix","net","datagram","UnixDatagram"],"kind":"struct"},"6:5379:10320":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","Elf32_Chdr"],"kind":"struct"},"2:22850:6017":{"crate_id":2,"path":["core","core_simd","elements","sealed","Sealed"],"kind":"trait"},"18:695:5907":{"crate_id":18,"path":["memchr","memmem","rarebytes","RareNeedleBytes"],"kind":"struct"},"2:46758:4684":{"crate_id":2,"path":["core","iter","adapters","skip_while","SkipWhile"],"kind":"struct"},"16:5456:7094":{"crate_id":16,"path":["gimli","read","cfi","CieOffsetEncoding"],"kind":"enum"},"1:6701:10440":{"crate_id":1,"path":["std","os","linux","fs","MetadataExt","st_mtime"],"kind":"foreign_type"},"20:1981:7491":{"crate_id":20,"path":["regex_syntax","ast","parse","NestLimiter"],"kind":"struct"},"16:7786:7058":{"crate_id":16,"path":["gimli","read","unit","EntriesRaw"],"kind":"struct"},"1:699:5308":{"crate_id":1,"path":["std","thread","local","LocalKey"],"kind":"struct"},"20:2240:7501":{"crate_id":20,"path":["regex_syntax","ast","LiteralKind"],"kind":"enum"},"5:374:5498":{"crate_id":5,"path":["alloc","boxed","thin","ThinBox"],"kind":"struct"},"2:46363:4891":{"crate_id":2,"path":["core","char","EscapeUnicode"],"kind":"struct"},"6:6881:10551":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_cond_t"],"kind":"struct"},"16:6682:7061":{"crate_id":16,"path":["gimli","read","loclists","LocListIter"],"kind":"struct"},"2:5407:5829":{"crate_id":2,"path":["core","char","REPLACEMENT_CHARACTER"],"kind":"constant"},"21:1308:2647":{"crate_id":21,"path":["aho_corasick","ahocorasick","AhoCorasickBuilder"],"kind":"struct"},"2:49563:1599":{"crate_id":2,"path":["core","str","iter","SplitN"],"kind":"struct"},"1:6699:10438":{"crate_id":1,"path":["std","os","linux","fs","MetadataExt","st_atime"],"kind":"foreign_type"},"1:8031:5926":{"crate_id":1,"path":["std","sync","mpsc","oneshot","Packet"],"kind":"struct"},"6:5407:10334":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_entry"],"kind":"struct"},"17:10623:8201":{"crate_id":17,"path":["object","read","macho","file","MachOComdatSectionIterator"],"kind":"struct"},"17:11822:8369":{"crate_id":17,"path":["object","elf","NoteHeader64"],"kind":"struct"},"17:12040:8403":{"crate_id":17,"path":["object","macho","LcStr"],"kind":"struct"},"16:7119:7039":{"crate_id":16,"path":["gimli","read","op","Expression"],"kind":"struct"},"2:47923:89":{"crate_id":2,"path":["core","sync","atomic","AtomicU32"],"kind":"struct"},"14:11:9230":{"crate_id":14,"path":["rustc_demangle","legacy","Demangle"],"kind":"struct"},"16:7264:7063":{"crate_id":16,"path":["gimli","read","rnglists","RangeLists"],"kind":"struct"},"2:9517:1112":{"crate_id":2,"path":["core","result"],"kind":"module"},"17:294:8073":{"crate_id":17,"path":["object","read","util","DebugByte"],"kind":"struct"},"2:2062:6029":{"crate_id":2,"path":["core","mem","maybe_uninit","write_slice_cloned","Guard"],"kind":"struct"},"1:7667:6162":{"crate_id":1,"path":["std","process","ChildStderr"],"kind":"struct"},"1:1156:9458":{"crate_id":1,"path":["std","backtrace","BacktraceSymbol"],"kind":"struct"},"17:13429:8763":{"crate_id":17,"path":["object","pe","ImageExportDirectory"],"kind":"struct"},"18:821:5894":{"crate_id":18,"path":["memchr","memmem","FinderRev"],"kind":"struct"},"2:53592:9448":{"crate_id":2,"path":["core","core_arch","x86","cpuid","CpuidResult"],"kind":"struct"},"1:2437:9465":{"crate_id":1,"path":["std","env","SplitPaths"],"kind":"struct"},"21:1342:7893":{"crate_id":21,"path":["aho_corasick","classes","ByteClasses"],"kind":"struct"},"17:11750:8342":{"crate_id":17,"path":["object","elf","Verdef"],"kind":"struct"},"16:7073:7135":{"crate_id":16,"path":["gimli","read","op","EvaluationResult"],"kind":"enum"},"2:46388:4708":{"crate_id":2,"path":["core","char","EscapeDefault"],"kind":"struct"},"2:3416:4851":{"crate_id":2,"path":["core","ops","bit","Shr"],"kind":"trait"},"12:466:11025":{"crate_id":12,"path":["hashbrown","raw","RawIterHash"],"kind":"struct"},"17:2543:7461":{"crate_id":17,"path":["object","read","elf","relocation","ElfSectionRelocationIterator"],"kind":"struct"},"1:6863:5994":{"crate_id":1,"path":["std","os","fd","raw","AsRawFd"],"kind":"trait"},"12:2269:6192":{"crate_id":12,"path":["hashbrown","set","OccupiedEntry"],"kind":"struct"},"1:3652:6050":{"crate_id":1,"path":["std","io","buffered","bufwriter","BufWriter"],"kind":"struct"},"5:6652:69":{"crate_id":5,"path":["alloc","sync","Arc"],"kind":"struct"},"8:0:4413":{"crate_id":8,"path":["cfg_if"],"kind":"module"},"1:5779:6006":{"crate_id":1,"path":["std","os","unix","fs","FileTypeExt"],"kind":"trait"},"1:1511:6187":{"crate_id":1,"path":["std","collections","hash","map","RawEntryMut"],"kind":"enum"},"2:46618:4673":{"crate_id":2,"path":["core","iter","adapters","cycle","Cycle"],"kind":"struct"},"12:2072:6107":{"crate_id":12,"path":["hashbrown","set","Union"],"kind":"struct"},"1:13655:6178":{"crate_id":1,"path":["std","sys","unix","os_str","Slice"],"kind":"struct"},"2:46340:5842":{"crate_id":2,"path":["core","char","decode","DecodeUtf16"],"kind":"struct"},"1:10673:6195":{"crate_id":1,"path":["std","collections","hash","map","DefaultHasher"],"kind":"struct"},"2:10294:109":{"crate_id":2,"path":["core","fmt","macros","Debug"],"kind":"proc_derive"},"21:1694:6424":{"crate_id":21,"path":["aho_corasick","packed","teddy","compile","Mask"],"kind":"struct"},"21:1493:7915":{"crate_id":21,"path":["aho_corasick","nfa","Dense"],"kind":"struct"},"2:53189:6465":{"crate_id":2,"path":["core","core_arch","simd","u32x16"],"kind":"struct"},"2:50418:158":{"crate_id":2,"path":["core","alloc","layout","Layout"],"kind":"struct"},"6:6864:10546":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_condattr_t"],"kind":"struct"},"16:4704:8969":{"crate_id":16,"path":["gimli","constants","DwCc"],"kind":"struct"},"9:927:47693":{"crate_id":9,"path":["miniz_oxide","inflate","TINFLStatus"],"kind":"enum"},"2:48528:67":{"crate_id":2,"path":["core","fmt","rt","v1","Alignment"],"kind":"enum"},"2:2152:670":{"crate_id":2,"path":["core","mem","forget"],"kind":"function"},"20:2155:7483":{"crate_id":20,"path":["regex_syntax","ast","Ast"],"kind":"enum"},"2:3286:4722":{"crate_id":2,"path":["core","marker","PhantomData"],"kind":"struct"},"2:48049:85":{"crate_id":2,"path":["core","sync","atomic","AtomicIsize"],"kind":"struct"},"17:13221:8717":{"crate_id":17,"path":["object","pe","AnonObjectHeaderBigobj"],"kind":"struct"},"6:6887:10552":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_mutex_t"],"kind":"struct"},"1:15202:6115":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8Buf"],"kind":"struct"},"21:1879:7897":{"crate_id":21,"path":["aho_corasick","prefilter","ByteSet"],"kind":"struct"},"6:1676:9849":{"crate_id":6,"path":["libc","unix","linux_like","in6_rtmsg"],"kind":"struct"},"2:53530:9446":{"crate_id":2,"path":["core","core_arch","x86","__m256bh"],"kind":"struct"},"17:12756:8539":{"crate_id":17,"path":["object","macho","Nlist64"],"kind":"struct"},"6:1717:9873":{"crate_id":6,"path":["libc","unix","linux_like","mmsghdr"],"kind":"struct"},"21:1916:7954":{"crate_id":21,"path":["aho_corasick","prefilter","RareBytesThree"],"kind":"struct"},"16:6032:7038":{"crate_id":16,"path":["gimli","read","endian_slice","EndianSlice"],"kind":"struct"},"2:11410:4899":{"crate_id":2,"path":["core","slice","iter","RSplitN"],"kind":"struct"},"16:3091:7364":{"crate_id":16,"path":["gimli","common","DebugMacroOffset"],"kind":"struct"},"6:4517:10175":{"crate_id":6,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_can_addr"],"kind":"union"},"17:12028:8401":{"crate_id":17,"path":["object","macho","LoadCommand"],"kind":"struct"},"20:3518:1827":{"crate_id":20,"path":["regex_syntax","utf8","Utf8Range"],"kind":"struct"},"2:2193:4632":{"crate_id":2,"path":["core","mem","Discriminant"],"kind":"struct"},"1:3201:6234":{"crate_id":1,"path":["std","fs","read"],"kind":"function"},"21:1746:7925":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","TeddySlim1Mask128"],"kind":"struct"},"18:668:5906":{"crate_id":18,"path":["memchr","memmem","rabinkarp","NeedleHash"],"kind":"struct"},"16:4448:8962":{"crate_id":16,"path":["gimli","constants","DwEnd"],"kind":"struct"},"20:2431:7508":{"crate_id":20,"path":["regex_syntax","ast","ClassUnicodeKind"],"kind":"enum"},"17:13582:8808":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation32"],"kind":"struct"},"2:4884:4727":{"crate_id":2,"path":["core","cell","lazy","LazyCell"],"kind":"struct"},"1:14627:118":{"crate_id":1,"path":["std","sys","unix","fs","DirBuilder"],"kind":"struct"},"2:49908:6388":{"crate_id":2,"path":["core","str","pattern","CharArrayRefSearcher"],"kind":"struct"},"1:7619:6159":{"crate_id":1,"path":["std","process","Child"],"kind":"struct"},"6:4410:10130":{"crate_id":6,"path":["libc","unix","linux_like","linux","nlmsghdr"],"kind":"struct"},"17:13172:8703":{"crate_id":17,"path":["object","pe","ImageRomHeaders"],"kind":"struct"},"12:764:5483":{"crate_id":12,"path":["hashbrown","map","IterMut"],"kind":"struct"},"6:5130:10182":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","statx"],"kind":"struct"},"21:1825:64769":{"crate_id":21,"path":["aho_corasick","prefilter","Candidate"],"kind":"enum"},"1:9471:11113":{"crate_id":1,"path":["std","sys_common","backtrace","_print","DisplayBacktrace"],"kind":"struct"},"2:49257:5963":{"crate_id":2,"path":["core","slice","iter","Chunks"],"kind":"struct"},"2:46394:5835":{"crate_id":2,"path":["core","char","EscapeDefaultState"],"kind":"enum"},"2:11355:5975":{"crate_id":2,"path":["core","slice","iter","RSplitMut"],"kind":"struct"},"1:2460:7780":{"crate_id":1,"path":["std","env","Args"],"kind":"struct"},"6:5978:10417":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","flock64"],"kind":"struct"},"2:47550:3395":{"crate_id":2,"path":["core","option","IntoIter"],"kind":"struct"},"1:1528:6189":{"crate_id":1,"path":["std","collections","hash","map","RawVacantEntryMut"],"kind":"struct"},"2:47688:178":{"crate_id":2,"path":["core","sync","atomic","Ordering"],"kind":"enum"},"2:49477:4898":{"crate_id":2,"path":["core","str","iter","RSplit"],"kind":"struct"},"5:2218:6734":{"crate_id":5,"path":["alloc","collections","btree","merge_iter","MergeIterInner"],"kind":"struct"},"2:47559:4740":{"crate_id":2,"path":["core","panic","location","Location"],"kind":"struct"},"21:1350:7901":{"crate_id":21,"path":["aho_corasick","classes","ByteClassRepresentatives"],"kind":"struct"},"17:13933:8920":{"crate_id":17,"path":["object","pe","ImageFunctionEntry64"],"kind":"struct"},"2:11424:5977":{"crate_id":2,"path":["core","slice","iter","SplitNMut"],"kind":"struct"},"1:16020:4451":{"crate_id":1,"path":["std","i64"],"kind":"primitive"},"2:22578:61697":{"crate_id":2,"path":["core","core_simd","swizzle","interleave","Lo"],"kind":"struct"},"2:3774:4724":{"crate_id":2,"path":["core","ops","unsize","CoerceUnsized"],"kind":"trait"},"2:3576:3564":{"crate_id":2,"path":["core","ops","index","Index"],"kind":"trait"},"1:16015:4446":{"crate_id":1,"path":["std","f32"],"kind":"primitive"},"6:1622:9807":{"crate_id":6,"path":["libc","unix","linux_like","Dl_info"],"kind":"struct"},"1:10854:118":{"crate_id":1,"path":["std","fs","DirBuilder"],"kind":"struct"},"6:4073:10013":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_condition_effect"],"kind":"struct"},"5:1939:5446":{"crate_id":5,"path":["alloc","collections","btree","map","DrainFilter"],"kind":"struct"},"6:6106:10459":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_fpstate"],"kind":"struct"},"2:51073:6469":{"crate_id":2,"path":["core","core_arch","simd","u8x4"],"kind":"struct"},"0:0:1635":{"crate_id":0,"path":["regex"],"kind":"module"},"1:10822:6015":{"crate_id":1,"path":["std","fs","Permissions"],"kind":"struct"},"2:46410:4890":{"crate_id":2,"path":["core","char","EscapeDebug"],"kind":"struct"},"1:10431:7770":{"crate_id":1,"path":["std","backtrace_rs","print","BacktraceFrameFmt"],"kind":"struct"},"5:7212:5448":{"crate_id":5,"path":["alloc","vec","drain","Drain"],"kind":"struct"},"2:32345:61866":{"crate_id":2,"path":["core","mem","valid_align","ValidAlignEnum16"],"kind":"enum"},"2:24247:6649":{"crate_id":2,"path":["core","num","error","IntErrorKind"],"kind":"enum"},"2:48519:133":{"crate_id":2,"path":["core","fmt","rt","v1","FormatSpec"],"kind":"struct"},"17:9649:8165":{"crate_id":17,"path":["object","read","any","SegmentIterator"],"kind":"struct"},"5:4215:5448":{"crate_id":5,"path":["alloc","collections","vec_deque","drain","Drain"],"kind":"struct"},"1:7511:119":{"crate_id":1,"path":["std","path","Display"],"kind":"struct"},"17:9368:8068":{"crate_id":17,"path":["object","endian","U64Bytes"],"kind":"struct"},"1:3565:6049":{"crate_id":1,"path":["std","io","buffered","bufreader","BufReader"],"kind":"struct"},"20:332:7481":{"crate_id":20,"path":["regex_syntax","ast","visitor","ClassFrame"],"kind":"enum"},"5:8446:5446":{"crate_id":5,"path":["alloc","vec","drain_filter","DrainFilter"],"kind":"struct"},"2:50045:6393":{"crate_id":2,"path":["core","str","pattern","EmptyNeedle"],"kind":"struct"},"17:12168:8209":{"crate_id":17,"path":["object","macho","Dylib"],"kind":"struct"},"16:6087:7045":{"crate_id":16,"path":["gimli","read","abbrev","DebugAbbrev"],"kind":"struct"},"2:8362:4662":{"crate_id":2,"path":["core","iter","traits","accum","Sum"],"kind":"trait"},"2:52369:6444":{"crate_id":2,"path":["core","core_arch","simd","i32x8"],"kind":"struct"},"20:1893:1826":{"crate_id":20,"path":["regex_syntax","is_word_byte"],"kind":"function"},"2:47542:5483":{"crate_id":2,"path":["core","option","IterMut"],"kind":"struct"},"1:5862:6322":{"crate_id":1,"path":["std","os","unix","net","addr","AsciiEscaped"],"kind":"struct"},"2:3181:227":{"crate_id":2,"path":["core","convert","TryFrom"],"kind":"trait"},"1:1637:6192":{"crate_id":1,"path":["std","collections","hash","map","OccupiedEntry"],"kind":"struct"},"17:10827:7428":{"crate_id":17,"path":["object","read","macho","section","MachOSectionInternal"],"kind":"struct"},"20:2362:7506":{"crate_id":20,"path":["regex_syntax","ast","ClassAscii"],"kind":"struct"},"16:6691:7131":{"crate_id":16,"path":["gimli","read","loclists","LocationListEntry"],"kind":"struct"},"6:1554:9763":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_in"],"kind":"struct"},"3:0:430":{"crate_id":3,"path":["compiler_builtins"],"kind":"module"},"16:3145:7316":{"crate_id":16,"path":["gimli","common","RangeListsOffset"],"kind":"struct"},"20:2470:7510":{"crate_id":20,"path":["regex_syntax","ast","ClassBracketed"],"kind":"struct"},"2:49248:5964":{"crate_id":2,"path":["core","slice","iter","Windows"],"kind":"struct"},"2:7857:6364":{"crate_id":2,"path":["core","iter","adapters","GenericShunt"],"kind":"struct"},"17:9799:8168":{"crate_id":17,"path":["object","read","any","ComdatSectionIterator"],"kind":"struct"},"5:1663:6184":{"crate_id":5,"path":["alloc","collections","btree","map","IntoKeys"],"kind":"struct"},"20:2554:7514":{"crate_id":20,"path":["regex_syntax","ast","ClassSetUnion"],"kind":"struct"},"21:1838:7940":{"crate_id":21,"path":["aho_corasick","prefilter","PrefilterObj"],"kind":"struct"},"17:9839:7406":{"crate_id":17,"path":["object","read","any","SymbolTable"],"kind":"struct"},"2:49349:5971":{"crate_id":2,"path":["core","slice","iter","RChunks"],"kind":"struct"},"17:11738:8341":{"crate_id":17,"path":["object","elf","Versym"],"kind":"struct"},"2:48269:5346":{"crate_id":2,"path":["core","fmt","num","LowerHex"],"kind":"struct"},"2:22601:61699":{"crate_id":2,"path":["core","core_simd","swizzle","deinterleave","Odd"],"kind":"struct"},"16:7158:7137":{"crate_id":16,"path":["gimli","read","op","Evaluation"],"kind":"struct"},"17:12051:8404":{"crate_id":17,"path":["object","macho","SegmentCommand32"],"kind":"struct"},"1:8694:4565":{"crate_id":1,"path":["std","sync","condvar","Condvar"],"kind":"struct"},"12:162:6953":{"crate_id":12,"path":["hashbrown","raw","Bucket"],"kind":"struct"},"6:3868:9895":{"crate_id":6,"path":["libc","unix","linux_like","linux","glob_t"],"kind":"struct"},"17:13574:8807":{"crate_id":17,"path":["object","pe","ImageDynamicRelocationTable"],"kind":"struct"},"5:6764:6029":{"crate_id":5,"path":["alloc","sync","from_iter_exact","Guard"],"kind":"struct"},"2:47015:4656":{"crate_id":2,"path":["core","iter","sources","successors","Successors"],"kind":"struct"},"2:49758:4890":{"crate_id":2,"path":["core","str","iter","EscapeDebug"],"kind":"struct"},"2:46281:4708":{"crate_id":2,"path":["core","ascii","EscapeDefault"],"kind":"struct"},"1:2938:180":{"crate_id":1,"path":["std","ffi","os_str","OsString"],"kind":"struct"},"2:24666:5931":{"crate_id":2,"path":["core","num","nonzero","NonZeroUsize"],"kind":"struct"},"17:9476:8071":{"crate_id":17,"path":["object","endian","I64Bytes"],"kind":"struct"},"2:53500:9444":{"crate_id":2,"path":["core","core_arch","x86","__m512d"],"kind":"struct"},"1:16021:4452":{"crate_id":1,"path":["std","i128"],"kind":"primitive"},"1:14317:5476":{"crate_id":1,"path":["std","sys","unix","thread","Thread"],"kind":"struct"},"2:24598:172":{"crate_id":2,"path":["core","num","nonzero","NonZeroU64"],"kind":"struct"},"1:15073:10653":{"crate_id":1,"path":["std","sys","unix","time","Timespec"],"kind":"struct"},"2:24768:166":{"crate_id":2,"path":["core","num","nonzero","NonZeroI32"],"kind":"struct"},"17:11254:7373":{"crate_id":17,"path":["object","read","Export"],"kind":"struct"},"2:3168:74":{"crate_id":2,"path":["core","convert","AsMut"],"kind":"trait"},"5:3336:6105":{"crate_id":5,"path":["alloc","collections","btree","set","Difference"],"kind":"struct"},"2:46799:4687":{"crate_id":2,"path":["core","iter","adapters","zip","Zip"],"kind":"struct"},"2:8163:11031":{"crate_id":2,"path":["core","iter","sources","from_generator","FromGenerator"],"kind":"struct"},"21:1215:2646":{"crate_id":21,"path":["aho_corasick","ahocorasick","AhoCorasick"],"kind":"struct"},"2:8886:4659":{"crate_id":2,"path":["core","iter","traits","marker","TrustedStep"],"kind":"trait"},"21:1955:1592":{"crate_id":21,"path":["aho_corasick","Match"],"kind":"struct"},"1:15123:9561":{"crate_id":1,"path":["std","sys_common","process","CommandEnv"],"kind":"struct"},"2:23939:6633":{"crate_id":2,"path":["core","num","bignum","tests","Big8x3"],"kind":"struct"},"6:4419:10136":{"crate_id":6,"path":["libc","unix","linux_like","linux","nlmsgerr"],"kind":"struct"},"2:3367:4841":{"crate_id":2,"path":["core","ops","arith","AddAssign"],"kind":"trait"},"5:5536:4561":{"crate_id":5,"path":["alloc","rc","Weak"],"kind":"struct"},"20:3354:2038":{"crate_id":20,"path":["regex_syntax","hir","RepetitionRange"],"kind":"enum"},"17:9210:49921":{"crate_id":17,"path":["object","common","SymbolFlags"],"kind":"enum"},"1:6323:6292":{"crate_id":1,"path":["std","os","unix","net","stream","UnixStream"],"kind":"struct"},"9:776:6866":{"crate_id":9,"path":["miniz_oxide","deflate","CompressionLevel"],"kind":"enum"},"2:13072:3152":{"crate_id":2,"path":["core","str","pattern","Searcher"],"kind":"trait"},"1:5504:6281":{"crate_id":1,"path":["std","net","udp","UdpSocket"],"kind":"struct"},"1:11246:6087":{"crate_id":1,"path":["std","net","ip","Ipv6Addr"],"kind":"struct"},"17:13282:8731":{"crate_id":17,"path":["object","pe","ImageSymbolEx"],"kind":"struct"},"6:4120:10039":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_ff_erase"],"kind":"struct"},"16:5672:7102":{"crate_id":16,"path":["gimli","read","cfi","FrameDescriptionEntry"],"kind":"struct"},"17:12195:8430":{"crate_id":17,"path":["object","macho","SubFrameworkCommand"],"kind":"struct"},"2:46056:6530":{"crate_id":2,"path":["core","any","tags","MaybeSizedValue"],"kind":"struct"},"1:11082:6039":{"crate_id":1,"path":["std","io","IoSlice"],"kind":"struct"},"1:8912:4568":{"crate_id":1,"path":["std","sync","once","Once"],"kind":"struct"},"22:836:5905":{"crate_id":22,"path":["memchr","memmem","prefilter","PrefilterState"],"kind":"struct"},"18:867:5898":{"crate_id":18,"path":["memchr","memmem","SearcherKind"],"kind":"enum"},"21:1887:7898":{"crate_id":21,"path":["aho_corasick","prefilter","RareByteOffsets"],"kind":"struct"},"2:46465:100":{"crate_id":2,"path":["core","ffi","c_str","CStr"],"kind":"struct"},"16:6807:7133":{"crate_id":16,"path":["gimli","read","op","Operation"],"kind":"enum"},"20:3053:4599":{"crate_id":20,"path":["regex_syntax","hir","ErrorKind"],"kind":"enum"},"1:16010:4443":{"crate_id":1,"path":["std","slice"],"kind":"primitive"},"12:1238:6952":{"crate_id":12,"path":["hashbrown","map","VacantEntryRef"],"kind":"struct"},"1:10569:6017":{"crate_id":1,"path":["std","sealed","Sealed"],"kind":"trait"},"17:9809:64158":{"crate_id":17,"path":["object","read","any","ComdatSectionIteratorInternal"],"kind":"enum"},"2:12845:4882":{"crate_id":2,"path":["core","str","iter","SplitInclusive"],"kind":"struct"},"2:11438:5976":{"crate_id":2,"path":["core","slice","iter","RSplitNMut"],"kind":"struct"},"17:13609:8815":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation64V2"],"kind":"struct"},"1:1505:6186":{"crate_id":1,"path":["std","collections","hash","map","RawEntryBuilderMut"],"kind":"struct"},"1:9064:4572":{"crate_id":1,"path":["std","sync","poison","PoisonError"],"kind":"struct"},"1:15236:6123":{"crate_id":1,"path":["std","sys_common","wtf8","EncodeWide"],"kind":"struct"},"14:56:8289":{"crate_id":14,"path":["rustc_demangle","v0","Ident"],"kind":"struct"},"2:22801:6526":{"crate_id":2,"path":["core","core_simd","elements","int","SimdInt"],"kind":"trait"},"6:4241:10059":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Shdr"],"kind":"struct"},"2:48276:5347":{"crate_id":2,"path":["core","fmt","num","UpperHex"],"kind":"struct"},"17:9600:64154":{"crate_id":17,"path":["object","read","any","FileInternal"],"kind":"enum"},"21:1679:5858":{"crate_id":21,"path":["aho_corasick","packed","teddy","compile","Builder"],"kind":"struct"},"22:930:64163":{"crate_id":22,"path":["memchr","memmem","twoway","SuffixOrdering"],"kind":"enum"},"1:13418:6288":{"crate_id":1,"path":["std","sys","unix","net","Socket"],"kind":"struct"},"2:9259:3248":{"crate_id":2,"path":["core","panic","unwind_safe","RefUnwindSafe"],"kind":"trait"},"2:53377:6433":{"crate_id":2,"path":["core","core_arch","simd","f64x8"],"kind":"struct"},"22:896:7879":{"crate_id":22,"path":["memchr","memmem","twoway","TwoWay"],"kind":"struct"},"2:4065:5746":{"crate_id":2,"path":["core","any","Demand"],"kind":"struct"},"1:2941:179":{"crate_id":1,"path":["std","ffi","os_str","OsStr"],"kind":"struct"},"5:2200:7724":{"crate_id":5,"path":["alloc","collections","btree","mem","replace","PanicGuard"],"kind":"struct"},"2:3177:228":{"crate_id":2,"path":["core","convert","TryInto"],"kind":"trait"},"21:1393:7904":{"crate_id":21,"path":["aho_corasick","dfa","ByteClass"],"kind":"struct"},"20:1992:7969":{"crate_id":20,"path":["regex_syntax","ast","print","PrinterBuilder"],"kind":"struct"},"6:4449:10151":{"crate_id":6,"path":["libc","unix","linux_like","linux","dirent64"],"kind":"struct"},"2:53553:9447":{"crate_id":2,"path":["core","core_arch","x86","__m512bh"],"kind":"struct"},"1:15217:6116":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8"],"kind":"struct"},"1:2166:5448":{"crate_id":1,"path":["std","collections","hash","set","Drain"],"kind":"struct"},"5:1235:6784":{"crate_id":5,"path":["alloc","collections","btree","dedup_sorted_iter","DedupSortedIter"],"kind":"struct"},"21:1706:7549":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","Teddy"],"kind":"struct"},"1:6794:6019":{"crate_id":1,"path":["std","os","linux","process","CommandExt"],"kind":"trait"},"17:9943:64152":{"crate_id":17,"path":["object","read","any","DynamicRelocationIteratorInternal"],"kind":"enum"},"6:5459:10348":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_data"],"kind":"union"},"2:49266:5967":{"crate_id":2,"path":["core","slice","iter","ChunksMut"],"kind":"struct"},"5:2330:6785":{"crate_id":5,"path":["alloc","collections","btree","navigate","LazyLeafRange"],"kind":"struct"},"6:4005:9983":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_id"],"kind":"struct"},"2:50351:9383":{"crate_id":2,"path":["core","future","ResumeTy"],"kind":"struct"},"1:6203:6291":{"crate_id":1,"path":["std","os","unix","net","listener","UnixListener"],"kind":"struct"},"6:1690:9860":{"crate_id":6,"path":["libc","unix","linux_like","arpreq"],"kind":"struct"},"5:2310:6802":{"crate_id":5,"path":["alloc","collections","btree","navigate","LazyLeafHandle"],"kind":"enum"},"16:6569:7335":{"crate_id":16,"path":["gimli","read","lists","ListsHeader"],"kind":"struct"},"2:50359:190":{"crate_id":2,"path":["core","task","poll","Poll"],"kind":"enum"},"16:6554:7127":{"crate_id":16,"path":["gimli","read","line","FileEntryFormat"],"kind":"struct"},"12:750:3396":{"crate_id":12,"path":["hashbrown","map","Iter"],"kind":"struct"},"2:13962:61760":{"crate_id":2,"path":["core","future","from_generator","GenFuture"],"kind":"struct"},"5:3362:6106":{"crate_id":5,"path":["alloc","collections","btree","set","SymmetricDifference"],"kind":"struct"},"17:12234:8435":{"crate_id":17,"path":["object","macho","SubLibraryCommand"],"kind":"struct"},"1:12183:6219":{"crate_id":1,"path":["std","sync","mpsc","RecvTimeoutError"],"kind":"enum"},"16:7295:7065":{"crate_id":16,"path":["gimli","read","rnglists","RawRngListIter"],"kind":"struct"},"14:231:6724":{"crate_id":14,"path":["rustc_demangle","v0","ParseError"],"kind":"enum"},"2:46500:6662":{"crate_id":2,"path":["core","ffi","c_str","FromBytesUntilNulError"],"kind":"struct"},"17:13402:8759":{"crate_id":17,"path":["object","pe","ImageArchiveMemberHeader"],"kind":"struct"},"1:2366:600":{"crate_id":1,"path":["std","env"],"kind":"module"},"16:7333:7067":{"crate_id":16,"path":["gimli","read","rnglists","RngListIter"],"kind":"struct"},"17:10200:8184":{"crate_id":17,"path":["object","read","coff","comdat","CoffComdatIterator"],"kind":"struct"},"20:1929:4594":{"crate_id":20,"path":["regex_syntax","ast","parse","Parser"],"kind":"struct"},"2:24530:170":{"crate_id":2,"path":["core","num","nonzero","NonZeroU16"],"kind":"struct"},"1:4401:6260":{"crate_id":1,"path":["std","io","stdio","StdoutRaw"],"kind":"struct"},"1:12154:6217":{"crate_id":1,"path":["std","sync","mpsc","RecvError"],"kind":"struct"},"17:9440:8070":{"crate_id":17,"path":["object","endian","I32Bytes"],"kind":"struct"},"2:12500:6717":{"crate_id":2,"path":["core","slice","SlicePattern"],"kind":"trait"},"20:2846:7493":{"crate_id":20,"path":["regex_syntax","either","Either"],"kind":"enum"},"2:50195:6610":{"crate_id":2,"path":["core","str","BytesIsNotEmpty"],"kind":"struct"},"5:1635:6181":{"crate_id":5,"path":["alloc","collections","btree","map","Keys"],"kind":"struct"},"21:1598:7545":{"crate_id":21,"path":["aho_corasick","packed","api","ForceAlgorithm"],"kind":"enum"},"2:49581:4899":{"crate_id":2,"path":["core","str","iter","RSplitN"],"kind":"struct"},"22:288:1551":{"crate_id":22,"path":["memchr","memchr","memchr"],"kind":"function"},"2:55964:6417":{"crate_id":2,"path":["core","core_simd","swizzle","Which"],"kind":"enum"},"2:46768:4669":{"crate_id":2,"path":["core","iter","adapters","step_by","StepBy"],"kind":"struct"},"2:11282:5978":{"crate_id":2,"path":["core","slice","iter","SplitInclusiveMut"],"kind":"struct"},"2:51144:6437":{"crate_id":2,"path":["core","core_arch","simd","i16x2"],"kind":"struct"},"17:9769:64153":{"crate_id":17,"path":["object","read","any","ComdatIteratorInternal"],"kind":"enum"},"18:661:5905":{"crate_id":18,"path":["memchr","memmem","prefilter","PrefilterState"],"kind":"struct"},"2:5164:4718":{"crate_id":2,"path":["core","cell","RefMut"],"kind":"struct"},"5:2553:6789":{"crate_id":5,"path":["alloc","collections","btree","node","NodeRef"],"kind":"struct"},"16:6744:7340":{"crate_id":16,"path":["gimli","read","lookup","PubStuffHeader"],"kind":"struct"},"6:5400:10332":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","ptrace_peeksiginfo_args"],"kind":"struct"},"6:4401:10127":{"crate_id":6,"path":["libc","unix","linux_like","linux","seccomp_data"],"kind":"struct"},"2:3524:132":{"crate_id":2,"path":["core","ops","function","FnOnce"],"kind":"trait"},"2:45898:195":{"crate_id":2,"path":["core","ops","range","RangeFrom"],"kind":"struct"},"16:7420:7069":{"crate_id":16,"path":["gimli","read","unit","UnitOffset"],"kind":"struct"},"1:1161:15067":{"crate_id":1,"path":["std","backtrace","BytesOrWide"],"kind":"enum"},"16:6491:7125":{"crate_id":16,"path":["gimli","read","line","CompleteLineProgram"],"kind":"struct"},"17:11406:8270":{"crate_id":17,"path":["object","archive","Header"],"kind":"struct"},"2:21:672":{"crate_id":2,"path":["core","format_args"],"kind":"macro"},"2:4727:6520":{"crate_id":2,"path":["core","asserting","TryCaptureWithoutDebug"],"kind":"struct"},"1:12120:6213":{"crate_id":1,"path":["std","sync","mpsc","TryIter"],"kind":"struct"},"2:51231:6462":{"crate_id":2,"path":["core","core_arch","simd","u32x2"],"kind":"struct"},"1:10642:15064":{"crate_id":1,"path":["std","backtrace","BacktraceStatus"],"kind":"enum"},"22:290:3130":{"crate_id":22,"path":["memchr","memchr","memchr2"],"kind":"function"},"2:3309:4909":{"crate_id":2,"path":["core","marker","Unpin"],"kind":"trait"},"18:850:5896":{"crate_id":18,"path":["memchr","memmem","NeedleInfo"],"kind":"struct"},"2:46558:9366":{"crate_id":2,"path":["core","ffi","VaList"],"kind":"struct"},"2:49891:6387":{"crate_id":2,"path":["core","str","pattern","CharArraySearcher"],"kind":"struct"},"20:2777:7521":{"crate_id":20,"path":["regex_syntax","ast","Flags"],"kind":"struct"},"16:4614:8966":{"crate_id":16,"path":["gimli","constants","DwLang"],"kind":"struct"},"20:2984:8048":{"crate_id":20,"path":["regex_syntax","hir","translate","Translator"],"kind":"struct"},"17:13620:8816":{"crate_id":17,"path":["object","pe","ImagePrologueDynamicRelocationHeader"],"kind":"struct"},"16:7928:6529":{"crate_id":16,"path":["gimli","read","value","Value"],"kind":"enum"},"2:3336:4835":{"crate_id":2,"path":["core","ops","arith","Add"],"kind":"trait"},"1:4304:6065":{"crate_id":1,"path":["std","io","readbuf","ReadBuf"],"kind":"struct"},"16:7804:7057":{"crate_id":16,"path":["gimli","read","unit","EntriesCursor"],"kind":"struct"},"21:1752:7926":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","TeddySlim1Mask256"],"kind":"struct"},"17:12010:8400":{"crate_id":17,"path":["object","macho","MachHeader64"],"kind":"struct"},"2:3165:75":{"crate_id":2,"path":["core","convert","AsRef"],"kind":"trait"},"12:2066:6106":{"crate_id":12,"path":["hashbrown","set","SymmetricDifference"],"kind":"struct"},"2:3379:4842":{"crate_id":2,"path":["core","ops","arith","DivAssign"],"kind":"trait"},"1:5964:6328":{"crate_id":1,"path":["std","os","unix","net","ancillary","ScmCredentials"],"kind":"struct"},"2:10302:5345":{"crate_id":2,"path":["core","fmt","Binary"],"kind":"trait"},"6:4112:10034":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_ff_upload"],"kind":"struct"},"6:5269:10257":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","nl_pktinfo"],"kind":"struct"},"9:27:6868":{"crate_id":9,"path":["miniz_oxide","deflate","buffer","HashBuffers"],"kind":"struct"},"1:11264:6176":{"crate_id":1,"path":["std","net","ip","Ipv6MulticastScope"],"kind":"enum"},"2:4964:4709":{"crate_id":2,"path":["core","cell","Cell"],"kind":"struct"},"2:49681:4897":{"crate_id":2,"path":["core","str","iter","RMatches"],"kind":"struct"},"17:11231:7375":{"crate_id":17,"path":["object","read","Import"],"kind":"struct"},"2:46638:4674":{"crate_id":2,"path":["core","iter","adapters","filter","Filter"],"kind":"struct"},"1:7121:4732":{"crate_id":1,"path":["std","panic","always_abort"],"kind":"function"},"1:5801:6009":{"crate_id":1,"path":["std","os","unix","fs","DirBuilderExt"],"kind":"trait"},"6:1744:9883":{"crate_id":6,"path":["libc","unix","linux_like","utsname"],"kind":"struct"},"2:5583:15069":{"crate_id":2,"path":["core","ffi","c_void"],"kind":"enum"},"16:7042:7350":{"crate_id":16,"path":["gimli","read","op","EvaluationWaiting"],"kind":"enum"},"12:2280:6193":{"crate_id":12,"path":["hashbrown","set","VacantEntry"],"kind":"struct"},"20:3132:1960":{"crate_id":20,"path":["regex_syntax","hir","Literal"],"kind":"enum"},"2:49368:5972":{"crate_id":2,"path":["core","slice","iter","RChunksExact"],"kind":"struct"},"18:886:5899":{"crate_id":18,"path":["memchr","memmem","SearcherRev"],"kind":"struct"},"2:49742:4881":{"crate_id":2,"path":["core","str","iter","SplitAsciiWhitespace"],"kind":"struct"},"17:10266:7393":{"crate_id":17,"path":["object","read","elf","segment","ElfSegment"],"kind":"struct"},"2:53462:9442":{"crate_id":2,"path":["core","core_arch","x86","__m512i"],"kind":"struct"},"2:46727:4681":{"crate_id":2,"path":["core","iter","adapters","rev","Rev"],"kind":"struct"},"20:3436:4612":{"crate_id":20,"path":["regex_syntax","unicode","CaseFoldError"],"kind":"struct"},"6:5528:10362":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","sysinfo"],"kind":"struct"},"17:12467:8490":{"crate_id":17,"path":["object","macho","PrebindCksumCommand"],"kind":"struct"},"1:11336:9532":{"crate_id":1,"path":["std","net","parser","AddrParseError"],"kind":"struct"},"6:1596:9791":{"crate_id":6,"path":["libc","unix","linux_like","fd_set"],"kind":"struct"},"9:234:6844":{"crate_id":9,"path":["miniz_oxide","deflate","core","HuffmanOxide"],"kind":"struct"},"2:4377:3395":{"crate_id":2,"path":["core","array","iter","IntoIter"],"kind":"struct"},"6:5274:10258":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","nl_mmap_req"],"kind":"struct"},"20:2377:7507":{"crate_id":20,"path":["regex_syntax","ast","ClassAsciiKind"],"kind":"enum"},"1:11502:4733":{"crate_id":1,"path":["std","panic","BacktraceStyle"],"kind":"enum"},"5:8197:3395":{"crate_id":5,"path":["alloc","collections","linked_list","IntoIter"],"kind":"struct"},"1:14953:7777":{"crate_id":1,"path":["std","sys","unix","process","process_inner","posix_spawn","PosixSpawnFileActions"],"kind":"struct"},"2:52936:6441":{"crate_id":2,"path":["core","core_arch","simd","i16x32"],"kind":"struct"},"21:1560:7922":{"crate_id":21,"path":["aho_corasick","nfa","QueuedSet"],"kind":"struct"},"16:6014:7114":{"crate_id":16,"path":["gimli","read","dwarf","RangeIter"],"kind":"struct"},"6:4183:10054":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Sym"],"kind":"struct"},"17:12275:8441":{"crate_id":17,"path":["object","macho","ThreadCommand"],"kind":"struct"},"1:5012:6079":{"crate_id":1,"path":["std","net","addr","ToSocketAddrs"],"kind":"trait"},"20:2127:7499":{"crate_id":20,"path":["regex_syntax","ast","WithComments"],"kind":"struct"},"2:10539:146":{"crate_id":2,"path":["core","hash","Hasher"],"kind":"trait"},"17:11159:8259":{"crate_id":17,"path":["object","read","SymbolMapName"],"kind":"struct"},"17:10128:7475":{"crate_id":17,"path":["object","read","coff","section","CoffSection"],"kind":"struct"},"17:13590:8810":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation64"],"kind":"struct"},"1:14959:7778":{"crate_id":1,"path":["std","sys","unix","process","process_inner","posix_spawn","PosixSpawnattr"],"kind":"struct"},"17:10236:7370":{"crate_id":17,"path":["object","read","elf","file","ElfFile"],"kind":"struct"},"2:8447:120":{"crate_id":2,"path":["core","iter","traits","double_ended","DoubleEndedIterator"],"kind":"trait"},"6:5428:10340":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","ptrace_syscall_info"],"kind":"struct"},"21:1278:7528":{"crate_id":21,"path":["aho_corasick","ahocorasick","StreamChunkIter"],"kind":"struct"},"2:4920:4728":{"crate_id":2,"path":["core","cell","once","OnceCell"],"kind":"struct"},"6:3862:9894":{"crate_id":6,"path":["libc","unix","linux_like","linux","rlimit64"],"kind":"struct"},"17:10814:7427":{"crate_id":17,"path":["object","read","macho","section","MachOSection"],"kind":"struct"},"12:183:6957":{"crate_id":12,"path":["hashbrown","raw","RawTable"],"kind":"struct"},"2:49956:6389":{"crate_id":2,"path":["core","str","pattern","CharSliceSearcher"],"kind":"struct"},"2:48133:4562":{"crate_id":2,"path":["core","sync","exclusive","Exclusive"],"kind":"struct"},"2:2966:184":{"crate_id":2,"path":["core","cmp","PartialOrd"],"kind":"trait"},"20:3376:4604":{"crate_id":20,"path":["regex_syntax","hir","HirInfo"],"kind":"struct"},"2:22937:6076":{"crate_id":2,"path":["core","core_simd","lane_count","SupportedLaneCount"],"kind":"trait"},"11:54:6940":{"crate_id":11,"path":["adler","Adler32"],"kind":"struct"},"2:52400:6447":{"crate_id":2,"path":["core","core_arch","simd","i64x4"],"kind":"struct"},"20:2967:7971":{"crate_id":20,"path":["regex_syntax","hir","print","Printer"],"kind":"struct"},"2:9767:86":{"crate_id":2,"path":["core","sync","atomic","AtomicPtr"],"kind":"struct"},"1:10812:6233":{"crate_id":1,"path":["std","fs","FileTimes"],"kind":"struct"},"16:7195:7140":{"crate_id":16,"path":["gimli","read","pubnames","PubNamesEntryIter"],"kind":"struct"},"22:942:7888":{"crate_id":22,"path":["memchr","memmem","twoway","ApproximateByteSet"],"kind":"struct"},"20:2929:4609":{"crate_id":20,"path":["regex_syntax","hir","interval","IntervalSetIter"],"kind":"struct"},"17:13627:8818":{"crate_id":17,"path":["object","pe","ImageEpilogueDynamicRelocationHeader"],"kind":"struct"},"1:9178:9472":{"crate_id":1,"path":["std","sync","rwlock","fmt","LockedPlaceholder"],"kind":"struct"},"21:1589:3186":{"crate_id":21,"path":["aho_corasick","packed","api","Config"],"kind":"struct"},"21:1566:7923":{"crate_id":21,"path":["aho_corasick","nfa","AllBytesIter"],"kind":"struct"},"2:51313:6438":{"crate_id":2,"path":["core","core_arch","simd","i16x4"],"kind":"struct"},"2:50395:6620":{"crate_id":2,"path":["core","task","wake","RawWaker"],"kind":"struct"},"18:730:64165":{"crate_id":18,"path":["memchr","memmem","twoway","Shift"],"kind":"enum"},"1:3343:6242":{"crate_id":1,"path":["std","fs","read_link"],"kind":"function"},"1:1045:5928":{"crate_id":1,"path":["std","thread","JoinHandle"],"kind":"struct"},"2:46736:4682":{"crate_id":2,"path":["core","iter","adapters","scan","Scan"],"kind":"struct"},"1:14809:6097":{"crate_id":1,"path":["std","sys","unix","os_str","Buf"],"kind":"struct"},"1:5985:6331":{"crate_id":1,"path":["std","os","unix","net","ancillary","Messages"],"kind":"struct"},"6:4023:9992":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_keymap_entry"],"kind":"struct"},"1:1136:5749":{"crate_id":1,"path":["std","backtrace","Backtrace"],"kind":"struct"},"1:16029:4460":{"crate_id":1,"path":["std","reference"],"kind":"primitive"},"12:1183:6950":{"crate_id":12,"path":["hashbrown","map","KeyOrRef"],"kind":"enum"},"12:432:6954":{"crate_id":12,"path":["hashbrown","raw","RawDrain"],"kind":"struct"},"16:3241:7310":{"crate_id":16,"path":["gimli","common","DebugStrOffsetsBase"],"kind":"struct"},"2:12992:3565":{"crate_id":2,"path":["core","str","traits","FromStr"],"kind":"trait"},"2:5110:3004":{"crate_id":2,"path":["core","cell","Ref"],"kind":"struct"},"5:1486:6194":{"crate_id":5,"path":["alloc","collections","btree","map","entry","OccupiedError"],"kind":"struct"},"17:9005:49916":{"crate_id":17,"path":["object","common","ComdatKind"],"kind":"enum"},"2:46708:4667":{"crate_id":2,"path":["core","iter","adapters","map_while","MapWhile"],"kind":"struct"},"20:2763:7520":{"crate_id":20,"path":["regex_syntax","ast","SetFlags"],"kind":"struct"},"16:5996:7113":{"crate_id":16,"path":["gimli","read","dwarf","Unit"],"kind":"struct"},"2:22927:6017":{"crate_id":2,"path":["core","core_simd","lane_count","sealed","Sealed"],"kind":"trait"},"18:830:5895":{"crate_id":18,"path":["memchr","memmem","FinderBuilder"],"kind":"struct"},"20:2023:4599":{"crate_id":20,"path":["regex_syntax","ast","ErrorKind"],"kind":"enum"},"1:7290:9470":{"crate_id":1,"path":["std","path","fmt","DebugHelper"],"kind":"struct"},"20:2898:134":{"crate_id":20,"path":["regex_syntax","error","Formatter"],"kind":"struct"},"18:812:3195":{"crate_id":18,"path":["memchr","memmem","Finder"],"kind":"struct"},"2:24049:10567":{"crate_id":2,"path":["core","num","dec2flt","decimal","Decimal"],"kind":"struct"},"2:47839:88":{"crate_id":2,"path":["core","sync","atomic","AtomicU16"],"kind":"struct"},"16:6718:7338":{"crate_id":16,"path":["gimli","read","lookup","DebugLookup"],"kind":"struct"},"20:540:1824":{"crate_id":20,"path":["regex_syntax","hir"],"kind":"module"},"1:6867:5996":{"crate_id":1,"path":["std","os","fd","raw","IntoRawFd"],"kind":"trait"},"2:2186:578":{"crate_id":2,"path":["core","mem","drop"],"kind":"function"},"17:13986:8929":{"crate_id":17,"path":["object","pe","ImportObjectHeader"],"kind":"struct"},"1:12057:10647":{"crate_id":1,"path":["std","sync","mpsc","blocking","SignalToken"],"kind":"struct"},"5:6475:5448":{"crate_id":5,"path":["alloc","string","Drain"],"kind":"struct"},"15:248:6973":{"crate_id":15,"path":["addr2line","LocationRangeUnitIter"],"kind":"struct"},"20:2909:4608":{"crate_id":20,"path":["regex_syntax","hir","interval","IntervalSet"],"kind":"struct"},"1:12128:3395":{"crate_id":1,"path":["std","sync","mpsc","IntoIter"],"kind":"struct"},"6:4281:10072":{"crate_id":6,"path":["libc","unix","linux_like","linux","posix_spawnattr_t"],"kind":"struct"},"17:9245:7383":{"crate_id":17,"path":["object","endian","Endianness"],"kind":"enum"},"16:2866:7302":{"crate_id":16,"path":["gimli","common","DebugAddrIndex"],"kind":"struct"},"2:3422:4852":{"crate_id":2,"path":["core","ops","bit","BitAndAssign"],"kind":"trait"},"16:3939:8956":{"crate_id":16,"path":["gimli","constants","DwTag"],"kind":"struct"},"17:10052:8178":{"crate_id":17,"path":["object","read","archive","ArchiveMember"],"kind":"struct"},"17:11499:8293":{"crate_id":17,"path":["object","elf","SectionHeader32"],"kind":"struct"},"2:46647:4675":{"crate_id":2,"path":["core","iter","adapters","filter_map","FilterMap"],"kind":"struct"},"1:12238:4567":{"crate_id":1,"path":["std","sync","mutex","MutexGuard"],"kind":"struct"},"22:170:4788":{"crate_id":22,"path":["memchr","memchr","iter","Memchr3"],"kind":"struct"},"1:7336:186":{"crate_id":1,"path":["std","path","PathBuf"],"kind":"struct"},"1:16022:4453":{"crate_id":1,"path":["std","u8"],"kind":"primitive"},"5:7824:7735":{"crate_id":5,"path":["alloc","vec","retain_mut","BackshiftOnDrop"],"kind":"struct"},"9:603:10781":{"crate_id":9,"path":["miniz_oxide","inflate","stream","InflateState"],"kind":"struct"},"2:56361:236":{"crate_id":2,"path":["core","core_simd","fmt","fmt","Wrapper"],"kind":"struct"},"17:12982:8602":{"crate_id":17,"path":["object","pe","ImageVxdHeader"],"kind":"struct"},"2:22990:6424":{"crate_id":2,"path":["core","core_simd","masks","mask_impl","Mask"],"kind":"struct"},"1:14236:6059":{"crate_id":1,"path":["std","sys","unix","stdio","Stdin"],"kind":"struct"},"21:1801:7933":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","TeddyFat3Mask256"],"kind":"struct"},"2:2768:579":{"crate_id":2,"path":["core","ptr","drop_in_place"],"kind":"function"},"21:1758:7927":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","TeddyFat1Mask256"],"kind":"struct"},"17:10317:7391":{"crate_id":17,"path":["object","read","elf","section","ElfSection"],"kind":"struct"},"16:5717:7104":{"crate_id":16,"path":["gimli","read","cfi","UnwindContext"],"kind":"struct"},"1:8392:2280":{"crate_id":1,"path":["std","sync","mpsc","sync","State"],"kind":"struct"},"6:4193:10055":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Sym"],"kind":"struct"},"1:5793:6001":{"crate_id":1,"path":["std","os","unix","fs","DirEntryExt2"],"kind":"trait"},"12:1256:6194":{"crate_id":12,"path":["hashbrown","map","OccupiedError"],"kind":"struct"},"5:4643:7727":{"crate_id":5,"path":["alloc","collections","vec_deque","drop","Dropper"],"kind":"struct"},"17:11653:8325":{"crate_id":17,"path":["object","elf","Rel64"],"kind":"struct"},"17:10938:8246":{"crate_id":17,"path":["object","read","pe","file","PeComdat"],"kind":"struct"},"5:8121:6775":{"crate_id":5,"path":["alloc","collections","binary_heap","IntoIterSorted"],"kind":"struct"},"9:157:6836":{"crate_id":9,"path":["miniz_oxide","deflate","core","CompressorOxide"],"kind":"struct"},"1:15054:6127":{"crate_id":1,"path":["std","sys","unix","time","SystemTime"],"kind":"struct"},"1:8492:6215":{"crate_id":1,"path":["std","sync","mpsc","SyncSender"],"kind":"struct"},"2:3728:224":{"crate_id":2,"path":["core","ops","try_trait","Try"],"kind":"trait"},"5:1441:6191":{"crate_id":5,"path":["alloc","collections","btree","map","entry","Entry"],"kind":"enum"},"2:48616:5343":{"crate_id":2,"path":["core","fmt","FlagV1"],"kind":"enum"},"2:32693:4638":{"crate_id":2,"path":["core","mem","transmutability","Assume"],"kind":"struct"},"2:48847:9376":{"crate_id":2,"path":["core","hash","sip","Sip24Rounds"],"kind":"struct"},"2:13781:150":{"crate_id":2,"path":["core","future","into_future","IntoFuture"],"kind":"trait"},"21:1947:7959":{"crate_id":21,"path":["aho_corasick","prefilter","StartBytesThree"],"kind":"struct"},"2:51922:9396":{"crate_id":2,"path":["core","core_arch","simd","m64x2"],"kind":"struct"},"1:2462:9466":{"crate_id":1,"path":["std","env","ArgsOs"],"kind":"struct"},"6:632:9746":{"crate_id":6,"path":["libc","unix","protoent"],"kind":"struct"},"16:5295:48340":{"crate_id":16,"path":["gimli","endianity","RunTimeEndian"],"kind":"enum"},"17:299:8074":{"crate_id":17,"path":["object","read","util","DebugLen"],"kind":"struct"},"14:47:9230":{"crate_id":14,"path":["rustc_demangle","v0","Demangle"],"kind":"struct"},"17:10353:7397":{"crate_id":17,"path":["object","read","elf","symbol","ElfSymbolTable"],"kind":"struct"},"17:11082:7379":{"crate_id":17,"path":["object","read","SectionIndex"],"kind":"struct"},"2:24564:171":{"crate_id":2,"path":["core","num","nonzero","NonZeroU32"],"kind":"struct"},"21:1714:1623":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","Exec"],"kind":"enum"},"22:1042:5898":{"crate_id":22,"path":["memchr","memmem","SearcherKind"],"kind":"enum"},"17:12142:8422":{"crate_id":17,"path":["object","macho","Fvmlib"],"kind":"struct"},"2:49435:4885":{"crate_id":2,"path":["core","str","iter","CharIndices"],"kind":"struct"},"20:3411:2650":{"crate_id":20,"path":["regex_syntax","parser","ParserBuilder"],"kind":"struct"},"22:950:7878":{"crate_id":22,"path":["memchr","memmem","x86","avx","std","Forward"],"kind":"struct"},"21:1548:7920":{"crate_id":21,"path":["aho_corasick","nfa","fill_failure_transitions_leftmost","QueuedState"],"kind":"struct"},"16:7823:7059":{"crate_id":16,"path":["gimli","read","unit","EntriesTree"],"kind":"struct"},"2:48817:146":{"crate_id":2,"path":["core","hash","sip","Hasher"],"kind":"struct"},"17:10477:7462":{"crate_id":17,"path":["object","read","elf","hash","GnuHashTable"],"kind":"struct"},"6:6858:10545":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_rwlockattr_t"],"kind":"struct"},"17:10304:7392":{"crate_id":17,"path":["object","read","elf","section","ElfSectionIterator"],"kind":"struct"},"17:12385:8475":{"crate_id":17,"path":["object","macho","DylibModule32"],"kind":"struct"},"17:10095:7472":{"crate_id":17,"path":["object","read","coff","section","CoffSegmentIterator"],"kind":"struct"},"2:50404:6621":{"crate_id":2,"path":["core","task","wake","RawWakerVTable"],"kind":"struct"},"2:49297:5955":{"crate_id":2,"path":["core","slice","iter","ArrayWindows"],"kind":"struct"},"2:38868:5335":{"crate_id":2,"path":["core","marker","PhantomPinned"],"kind":"struct"},"17:13192:8709":{"crate_id":17,"path":["object","pe","AnonObjectHeader"],"kind":"struct"},"1:3198:6232":{"crate_id":1,"path":["std","fs","DirEntry"],"kind":"struct"},"1:12298:6128":{"crate_id":1,"path":["std","time","SystemTimeError"],"kind":"struct"},"1:12243:4569":{"crate_id":1,"path":["std","sync","once","OnceState"],"kind":"struct"},"17:12408:8484":{"crate_id":17,"path":["object","macho","DylibModule64"],"kind":"struct"},"17:13912:8914":{"crate_id":17,"path":["object","pe","ImageDebugMisc"],"kind":"struct"},"1:5972:6330":{"crate_id":1,"path":["std","os","unix","net","ancillary","AncillaryData"],"kind":"enum"},"1:3686:6045":{"crate_id":1,"path":["std","io","buffered","bufwriter","WriterPanicked"],"kind":"struct"},"2:49839:6380":{"crate_id":2,"path":["core","str","pattern","SearchStep"],"kind":"enum"},"6:6636:10540":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","align","max_align_t"],"kind":"struct"},"21:1843:5905":{"crate_id":21,"path":["aho_corasick","prefilter","PrefilterState"],"kind":"struct"},"1:12134:6216":{"crate_id":1,"path":["std","sync","mpsc","SendError"],"kind":"struct"},"5:783:222":{"crate_id":5,"path":["alloc","borrow","ToOwned"],"kind":"trait"},"6:4060:10007":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_constant_effect"],"kind":"struct"},"18:740:7883":{"crate_id":18,"path":["memchr","memmem","twoway","Suffix"],"kind":"struct"},"17:11358:7430":{"crate_id":17,"path":["object","read","CompressedFileRange"],"kind":"struct"},"1:11350:6275":{"crate_id":1,"path":["std","net","tcp","Incoming"],"kind":"struct"},"17:10179:8183":{"crate_id":17,"path":["object","read","coff","symbol","CoffSymbol"],"kind":"struct"},"2:5100:4716":{"crate_id":2,"path":["core","cell","BorrowRef"],"kind":"struct"},"17:13318:8736":{"crate_id":17,"path":["object","pe","ImageAuxSymbolFunction"],"kind":"struct"},"17:11714:8337":{"crate_id":17,"path":["object","elf","Dyn32"],"kind":"struct"},"6:5185:10221":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__exit_status"],"kind":"struct"},"20:2345:7505":{"crate_id":20,"path":["regex_syntax","ast","ClassPerlKind"],"kind":"enum"},"1:14589:9560":{"crate_id":1,"path":["std","sys","unix","fs","FilePermissions"],"kind":"struct"},"2:49527:4900":{"crate_id":2,"path":["core","str","iter","RSplitTerminator"],"kind":"struct"},"6:4439:10145":{"crate_id":6,"path":["libc","unix","linux_like","linux","dirent"],"kind":"struct"},"6:519:9680":{"crate_id":6,"path":["libc","unix","utimbuf"],"kind":"struct"},"1:5934:6325":{"crate_id":1,"path":["std","os","unix","net","ancillary","AncillaryDataIter"],"kind":"struct"},"2:51355:9387":{"crate_id":2,"path":["core","core_arch","simd","i64x1"],"kind":"struct"},"17:13394:8757":{"crate_id":17,"path":["object","pe","ImageBaseRelocation"],"kind":"struct"},"17:11932:8381":{"crate_id":17,"path":["object","macho","DyldCacheMappingInfo"],"kind":"struct"},"16:7738:7147":{"crate_id":16,"path":["gimli","read","unit","Attribute"],"kind":"struct"},"5:1618:3395":{"crate_id":5,"path":["alloc","collections","btree","map","IntoIter"],"kind":"struct"},"18:897:5900":{"crate_id":18,"path":["memchr","memmem","SearcherRevKind"],"kind":"enum"},"5:3970:7723":{"crate_id":5,"path":["alloc","collections","linked_list","drop","DropGuard"],"kind":"struct"},"6:4293:10079":{"crate_id":6,"path":["libc","unix","linux_like","linux","genlmsghdr"],"kind":"struct"},"2:49733:4883":{"crate_id":2,"path":["core","str","iter","SplitWhitespace"],"kind":"struct"},"6:4358:10112":{"crate_id":6,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_tp"],"kind":"struct"},"2:3171:149":{"crate_id":2,"path":["core","convert","Into"],"kind":"trait"},"2:45809:4865":{"crate_id":2,"path":["core","ops","generator","GeneratorState"],"kind":"enum"},"17:12373:8473":{"crate_id":17,"path":["object","macho","DylibTableOfContents"],"kind":"struct"},"6:4227:10058":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Shdr"],"kind":"struct"},"17:13506:8786":{"crate_id":17,"path":["object","pe","ImageDelayloadDescriptor"],"kind":"struct"},"16:7971:127":{"crate_id":16,"path":["gimli","read","Error"],"kind":"enum"},"16:3522:8084":{"crate_id":16,"path":["gimli","arch","Arm"],"kind":"struct"},"1:2163:3395":{"crate_id":1,"path":["std","collections","hash","set","IntoIter"],"kind":"struct"},"22:996:5894":{"crate_id":22,"path":["memchr","memmem","FinderRev"],"kind":"struct"},"1:16004:4438":{"crate_id":1,"path":["std","never"],"kind":"primitive"},"2:46287:9360":{"crate_id":2,"path":["core","async_iter","from_iter","FromIter"],"kind":"struct"},"1:823:7769":{"crate_id":1,"path":["std","thread","local","os","Key"],"kind":"struct"},"21:1785:7931":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","TeddySlim3Mask128"],"kind":"struct"},"2:52322:6440":{"crate_id":2,"path":["core","core_arch","simd","i16x16"],"kind":"struct"},"2:22874:6512":{"crate_id":2,"path":["core","core_simd","eq","SimdPartialEq"],"kind":"trait"},"1:1450:6181":{"crate_id":1,"path":["std","collections","hash","map","Keys"],"kind":"struct"},"17:3743:7424":{"crate_id":17,"path":["object","read","macho","section","MachOSectionIterator"],"kind":"struct"},"11:0:4416":{"crate_id":11,"path":["adler"],"kind":"module"},"1:5380:6274":{"crate_id":1,"path":["std","net","tcp","TcpListener"],"kind":"struct"},"2:14165:141":{"crate_id":2,"path":["core","alloc","global","GlobalAlloc"],"kind":"trait"},"12:2040:5448":{"crate_id":12,"path":["hashbrown","set","Drain"],"kind":"struct"},"9:1020:6886":{"crate_id":9,"path":["miniz_oxide","MZError"],"kind":"enum"},"16:3506:7313":{"crate_id":16,"path":["gimli","common","DwarfFileType"],"kind":"enum"},"2:28051:6525":{"crate_id":2,"path":["core","num","wrapping","Wrapping"],"kind":"struct"},"16:6101:7043":{"crate_id":16,"path":["gimli","read","abbrev","Abbreviations"],"kind":"struct"},"16:7884:7055":{"crate_id":16,"path":["gimli","read","unit","DebugTypesUnitHeadersIter"],"kind":"struct"},"20:2639:2008":{"crate_id":20,"path":["regex_syntax","ast","Repetition"],"kind":"struct"},"17:13446:8770":{"crate_id":17,"path":["object","pe","ImageImportByName"],"kind":"struct"},"2:23467:20180":{"crate_id":2,"path":["core","core_simd","ord","SimdOrd"],"kind":"trait"},"2:48262:5344":{"crate_id":2,"path":["core","fmt","num","Octal"],"kind":"struct"},"16:7467:7049":{"crate_id":16,"path":["gimli","read","unit","DebugInfoUnitHeadersIter"],"kind":"struct"},"6:4371:10117":{"crate_id":6,"path":["libc","unix","linux_like","linux","can_filter"],"kind":"struct"},"17:9280:8158":{"crate_id":17,"path":["object","endian","BigEndian"],"kind":"struct"},"2:13278:9327":{"crate_id":2,"path":["core","str","lossy","Utf8Lossy"],"kind":"struct"},"9:900:9665":{"crate_id":9,"path":["miniz_oxide","inflate","core","LocalVars"],"kind":"struct"},"21:1423:6205":{"crate_id":21,"path":["aho_corasick","dfa","Repr"],"kind":"struct"},"6:6644:10542":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","align","sem_t"],"kind":"struct"},"2:48513:70":{"crate_id":2,"path":["core","fmt","rt","v1","Argument"],"kind":"struct"},"1:13935:11571":{"crate_id":1,"path":["std","sys","unix","process","process_common","Argv"],"kind":"struct"},"16:6780:7132":{"crate_id":16,"path":["gimli","read","op","DieReference"],"kind":"enum"},"2:10304:5346":{"crate_id":2,"path":["core","fmt","LowerHex"],"kind":"trait"},"2:45965:199":{"crate_id":2,"path":["core","ops","range","RangeToInclusive"],"kind":"struct"},"2:24219:6687":{"crate_id":2,"path":["core","num","error","TryFromIntError"],"kind":"struct"},"1:10657:15066":{"crate_id":1,"path":["std","backtrace","RawFrame"],"kind":"enum"},"5:3772:5483":{"crate_id":5,"path":["alloc","collections","linked_list","IterMut"],"kind":"struct"},"1:15033:6167":{"crate_id":1,"path":["std","sys","unix","process","process_inner","ExitStatusError"],"kind":"struct"},"17:10253:7394":{"crate_id":17,"path":["object","read","elf","segment","ElfSegmentIterator"],"kind":"struct"},"6:578:9717":{"crate_id":6,"path":["libc","unix","iovec"],"kind":"struct"},"2:3430:4854":{"crate_id":2,"path":["core","ops","bit","BitXorAssign"],"kind":"trait"},"2:47602:5267":{"crate_id":2,"path":["core","panicking","AssertKind"],"kind":"enum"},"16:5330:8158":{"crate_id":16,"path":["gimli","endianity","BigEndian"],"kind":"struct"},"17:12073:8413":{"crate_id":17,"path":["object","macho","SegmentCommand64"],"kind":"struct"},"6:584:9720":{"crate_id":6,"path":["libc","unix","pollfd"],"kind":"struct"},"1:14566:10649":{"crate_id":1,"path":["std","sys","unix","fs","FileAttr"],"kind":"struct"},"1:14239:6061":{"crate_id":1,"path":["std","sys","unix","stdio","Stdout"],"kind":"struct"},"5:7257:7723":{"crate_id":5,"path":["alloc","vec","drain","drop","DropGuard"],"kind":"struct"},"6:6852:10544":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_mutexattr_t"],"kind":"struct"},"1:16023:4454":{"crate_id":1,"path":["std","u16"],"kind":"primitive"},"5:3488:5446":{"crate_id":5,"path":["alloc","collections","btree","set","DrainFilter"],"kind":"struct"},"1:15976:15068":{"crate_id":1,"path":["std","backtrace_rs","types","BytesOrWideString"],"kind":"enum"},"22:153:4787":{"crate_id":22,"path":["memchr","memchr","iter","Memchr2"],"kind":"struct"},"20:1870:4617":{"crate_id":20,"path":["regex_syntax","utf8","ScalarRange"],"kind":"struct"},"21:1764:7928":{"crate_id":21,"path":["aho_corasick","packed","teddy","runtime","TeddySlim2Mask128"],"kind":"struct"},"5:1597:3396":{"crate_id":5,"path":["alloc","collections","btree","map","Iter"],"kind":"struct"},"1:6963:5989":{"crate_id":1,"path":["std","os","fd","owned","AsFd"],"kind":"trait"},"2:24032:6579":{"crate_id":2,"path":["core","num","dec2flt","common","BiasedFp"],"kind":"struct"},"1:5651:6096":{"crate_id":1,"path":["std","os","unix","ffi","os_str","OsStringExt"],"kind":"trait"},"17:9034:49917":{"crate_id":17,"path":["object","common","SymbolKind"],"kind":"enum"},"21:1358:7903":{"crate_id":21,"path":["aho_corasick","classes","ByteClassBuilder"],"kind":"struct"},"17:11993:8397":{"crate_id":17,"path":["object","macho","MachHeader32"],"kind":"struct"},"2:50448:5497":{"crate_id":2,"path":["core","alloc","AllocError"],"kind":"struct"},"17:9296:8067":{"crate_id":17,"path":["object","endian","U16Bytes"],"kind":"struct"},"2:51121:6449":{"crate_id":2,"path":["core","core_arch","simd","i8x4"],"kind":"struct"},"16:7250:7145":{"crate_id":16,"path":["gimli","read","rnglists","DebugRngLists"],"kind":"struct"},"6:4494:10165":{"crate_id":6,"path":["libc","unix","linux_like","linux","af_alg_iv"],"kind":"struct"},"20:2602:7517":{"crate_id":20,"path":["regex_syntax","ast","Assertion"],"kind":"struct"},"2:56322:236":{"crate_id":2,"path":["core","core_simd","fmt","fmt","Wrapper"],"kind":"struct"},"9:469:10771":{"crate_id":9,"path":["miniz_oxide","inflate","core","DecompressorOxide"],"kind":"struct"},"6:5371:10319":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","Elf64_Chdr"],"kind":"struct"},"12:815:6185":{"crate_id":12,"path":["hashbrown","map","IntoValues"],"kind":"struct"},"6:6051:10446":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statfs64"],"kind":"struct"},"6:4511:10173":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_txtime"],"kind":"struct"},"17:9332:7459":{"crate_id":17,"path":["object","endian","U32Bytes"],"kind":"struct"},"17:10962:8248":{"crate_id":17,"path":["object","read","pe","section","PeSegmentIterator"],"kind":"struct"},"17:10458:8119":{"crate_id":17,"path":["object","read","elf","note","Note"],"kind":"struct"},"17:9574:7380":{"crate_id":17,"path":["object","read","util","StringTable"],"kind":"struct"},"1:11313:57043":{"crate_id":1,"path":["std","net","parser","AddrKind"],"kind":"enum"},"2:3351:4836":{"crate_id":2,"path":["core","ops","arith","Div"],"kind":"trait"},"6:6068:10448":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statvfs64"],"kind":"struct"},"6:6870:10547":{"crate_id":6,"path":["libc","unix","linux_like","linux","fanotify_event_metadata"],"kind":"struct"},"1:12199:6220":{"crate_id":1,"path":["std","sync","mpsc","TrySendError"],"kind":"enum"},"6:1602:9793":{"crate_id":6,"path":["libc","unix","linux_like","tm"],"kind":"struct"},"12:940:6187":{"crate_id":12,"path":["hashbrown","map","RawEntryMut"],"kind":"enum"},"2:24103:6575":{"crate_id":2,"path":["core","num","dec2flt","FloatErrorKind"],"kind":"enum"},"12:979:6190":{"crate_id":12,"path":["hashbrown","map","RawEntryBuilder"],"kind":"struct"},"1:1419:3396":{"crate_id":1,"path":["std","collections","hash","map","Iter"],"kind":"struct"},"20:3333:2016":{"crate_id":20,"path":["regex_syntax","hir","RepetitionKind"],"kind":"enum"},"5:4599:7725":{"crate_id":5,"path":["alloc","collections","vec_deque","spec_extend","spec_extend","WrapAddOnDrop"],"kind":"struct"},"1:9631:11570":{"crate_id":1,"path":["std","sys_common","mutex","StaticMutex"],"kind":"struct"},"1:12079:10648":{"crate_id":1,"path":["std","sync","mpsc","cache_aligned","CacheAligned"],"kind":"struct"},"21:703:978":{"crate_id":21,"path":["aho_corasick","packed"],"kind":"module"},"1:8414:6771":{"crate_id":1,"path":["std","sync","mpsc","sync","Node"],"kind":"struct"},"17:13540:8799":{"crate_id":17,"path":["object","pe","ImageResourceDirectoryString"],"kind":"struct"},"17:11045:49922":{"crate_id":17,"path":["object","read","FileKind"],"kind":"enum"},"16:7185:7139":{"crate_id":16,"path":["gimli","read","pubnames","DebugPubNames"],"kind":"struct"},"17:13746:8867":{"crate_id":17,"path":["object","pe","ImageHotPatchBase"],"kind":"struct"},"2:12794:6604":{"crate_id":2,"path":["core","str","iter","MatchIndicesInternal"],"kind":"struct"},"6:1563:9768":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_in6"],"kind":"struct"},"2:51898:9395":{"crate_id":2,"path":["core","core_arch","simd","m32x4"],"kind":"struct"},"17:11015:8252":{"crate_id":17,"path":["object","read","pe","section","PeRelocationIterator"],"kind":"struct"},"2:38805:5744":{"crate_id":2,"path":["core","convert","Infallible"],"kind":"enum"},"16:7226:7143":{"crate_id":16,"path":["gimli","read","pubtypes","PubTypesEntryIter"],"kind":"struct"},"2:46548:7741":{"crate_id":2,"path":["core","ffi","VaListImpl"],"kind":"struct"},"6:5241:10245":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","mallinfo"],"kind":"struct"},"1:2401:9464":{"crate_id":1,"path":["std","env","VarsOs"],"kind":"struct"},"1:10862:6255":{"crate_id":1,"path":["std","io","buffered","linewritershim","LineWriterShim"],"kind":"struct"},"2:8106:1958":{"crate_id":2,"path":["core","iter","sources","empty","Empty"],"kind":"struct"},"20:3094:1956":{"crate_id":20,"path":["regex_syntax","hir","HirKind"],"kind":"enum"},"6:5420:10338":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_seccomp"],"kind":"struct"},"21:1940:7958":{"crate_id":21,"path":["aho_corasick","prefilter","StartBytesTwo"],"kind":"struct"},"16:5632:7101":{"crate_id":16,"path":["gimli","read","cfi","PartialFrameDescriptionEntry"],"kind":"struct"},"6:5312:10286":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","timex"],"kind":"struct"},"6:1729:6287":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_un"],"kind":"struct"},"1:5731:6003":{"crate_id":1,"path":["std","os","unix","fs","PermissionsExt"],"kind":"trait"},"2:24065:3005":{"crate_id":2,"path":["core","num","dec2flt","number","Number"],"kind":"struct"},"22:843:5906":{"crate_id":22,"path":["memchr","memmem","rabinkarp","NeedleHash"],"kind":"struct"},"1:6463:6022":{"crate_id":1,"path":["std","os","unix","process","ExitStatusExt"],"kind":"trait"},"2:46789:4686":{"crate_id":2,"path":["core","iter","adapters","take_while","TakeWhile"],"kind":"struct"},"16:2843:7301":{"crate_id":16,"path":["gimli","common","DebugAddrBase"],"kind":"struct"},"1:4477:6062":{"crate_id":1,"path":["std","io","stdio","StdoutLock"],"kind":"struct"},"21:1894:7948":{"crate_id":21,"path":["aho_corasick","prefilter","RareByteOffset"],"kind":"struct"},"2:49713:4893":{"crate_id":2,"path":["core","str","iter","Lines"],"kind":"struct"},"17:13296:8732":{"crate_id":17,"path":["object","pe","ImageSymbolExBytes"],"kind":"struct"},"2:9258:3249":{"crate_id":2,"path":["core","panic","unwind_safe","UnwindSafe"],"kind":"trait"},"2:14:2634":{"crate_id":2,"path":["core","write"],"kind":"macro"},"1:10836:129":{"crate_id":1,"path":["std","fs","FileType"],"kind":"struct"},"1:10701:6792":{"crate_id":1,"path":["std","error","private","Internal"],"kind":"struct"},"17:10377:7395":{"crate_id":17,"path":["object","read","elf","symbol","ElfSymbol"],"kind":"struct"},"2:23673:61680":{"crate_id":2,"path":["core","core_simd","vector","splat","Splat"],"kind":"struct"},"14:0:4418":{"crate_id":14,"path":["rustc_demangle"],"kind":"module"},"6:610:9733":{"crate_id":6,"path":["libc","unix","itimerval"],"kind":"struct"},"12:933:6186":{"crate_id":12,"path":["hashbrown","map","RawEntryBuilderMut"],"kind":"struct"},"2:53425:9439":{"crate_id":2,"path":["core","core_arch","x86","__m256i"],"kind":"struct"},"2:47965:83":{"crate_id":2,"path":["core","sync","atomic","AtomicI64"],"kind":"struct"},"16:5488:7096":{"crate_id":16,"path":["gimli","read","cfi","SectionBaseAddresses"],"kind":"struct"},"6:4272:10067":{"crate_id":6,"path":["libc","unix","linux_like","linux","posix_spawn_file_actions_t"],"kind":"struct"},"1:9347:6073":{"crate_id":1,"path":["std","std_float","StdFloat"],"kind":"trait"},"20:2309:1966":{"crate_id":20,"path":["regex_syntax","ast","Class"],"kind":"enum"},"17:10571:8197":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldCacheImage"],"kind":"struct"},"2:50436:5745":{"crate_id":2,"path":["core","alloc","layout","LayoutError"],"kind":"struct"},"22:292:3131":{"crate_id":22,"path":["memchr","memchr","memchr3"],"kind":"function"},"5:3038:3779":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Owned"],"kind":"enum"},"16:2912:7303":{"crate_id":16,"path":["gimli","common","DebugInfoOffset"],"kind":"struct"},"9:686:6817":{"crate_id":9,"path":["miniz_oxide","deflate","core","SymFreq"],"kind":"struct"},"1:11681:6148":{"crate_id":1,"path":["std","path","StripPrefixError"],"kind":"struct"},"18:783:7878":{"crate_id":18,"path":["memchr","memmem","x86","sse","Forward"],"kind":"struct"},"1:2399:9463":{"crate_id":1,"path":["std","env","Vars"],"kind":"struct"},"17:10028:8176":{"crate_id":17,"path":["object","read","archive","ArchiveFile"],"kind":"struct"},"1:4643:6029":{"crate_id":1,"path":["std","io","Guard"],"kind":"struct"},"2:46417:5836":{"crate_id":2,"path":["core","char","ToLowercase"],"kind":"struct"},"12:2036:3395":{"crate_id":12,"path":["hashbrown","set","IntoIter"],"kind":"struct"},"1:10680:16047":{"crate_id":1,"path":["std","env","VarError"],"kind":"enum"},"2:53416:9438":{"crate_id":2,"path":["core","core_arch","x86","__m128d"],"kind":"struct"},"17:2512:7390":{"crate_id":17,"path":["object","read","elf","relocation","ElfDynamicRelocationIterator"],"kind":"struct"},"21:1663:4876":{"crate_id":21,"path":["aho_corasick","packed","pattern","Pattern"],"kind":"struct"},"12:2045:5446":{"crate_id":12,"path":["hashbrown","set","DrainFilter"],"kind":"struct"},"2:49276:5965":{"crate_id":2,"path":["core","slice","iter","ChunksExact"],"kind":"struct"},"1:5739:6004":{"crate_id":1,"path":["std","os","unix","fs","OpenOptionsExt"],"kind":"trait"},"6:6200:10518":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","shmid_ds"],"kind":"struct"},"2:11205:4882":{"crate_id":2,"path":["core","slice","iter","SplitInclusive"],"kind":"struct"},"5:8160:3395":{"crate_id":5,"path":["alloc","collections","btree","set","IntoIter"],"kind":"struct"},"1:7633:6160":{"crate_id":1,"path":["std","process","ChildStdin"],"kind":"struct"},"1:5789:6007":{"crate_id":1,"path":["std","os","unix","fs","DirEntryExt"],"kind":"trait"},"21:1451:127":{"crate_id":21,"path":["aho_corasick","error","Error"],"kind":"struct"},"16:4762:8971":{"crate_id":16,"path":["gimli","constants","DwOrd"],"kind":"struct"},"1:2598:9467":{"crate_id":1,"path":["std","error","from","StringError"],"kind":"struct"},"1:11405:6326":{"crate_id":1,"path":["std","os","unix","net","ancillary","SocketCred"],"kind":"struct"},"2:50020:6391":{"crate_id":2,"path":["core","str","pattern","StrSearcher"],"kind":"struct"},"12:952:6188":{"crate_id":12,"path":["hashbrown","map","RawOccupiedEntryMut"],"kind":"struct"},"21:1607:5858":{"crate_id":21,"path":["aho_corasick","packed","api","Builder"],"kind":"struct"},"1:13782:6172":{"crate_id":1,"path":["std","sys","unix","pipe","AnonPipe"],"kind":"struct"},"1:12769:9549":{"crate_id":1,"path":["std","sys","unix","fs","TimespecDebugAdapter"],"kind":"struct"},"1:9598:7765":{"crate_id":1,"path":["std","sys_common","lazy_box","LazyBox"],"kind":"struct"},"17:10403:7402":{"crate_id":17,"path":["object","read","elf","relocation","RelocationSections"],"kind":"struct"},"1:12112:3396":{"crate_id":1,"path":["std","sync","mpsc","Iter"],"kind":"struct"},"5:8280:101":{"crate_id":5,"path":["alloc","ffi","c_str","CString"],"kind":"struct"},"1:16024:4455":{"crate_id":1,"path":["std","u32"],"kind":"primitive"},"16:7843:7149":{"crate_id":16,"path":["gimli","read","unit","EntriesTreeNode"],"kind":"struct"},"6:4325:10093":{"crate_id":6,"path":["libc","unix","linux_like","linux","fanotify_response"],"kind":"struct"},"1:14822:6168":{"crate_id":1,"path":["std","sys","unix","process","process_common","ExitCode"],"kind":"struct"},"2:3103:6349":{"crate_id":2,"path":["core","convert","num","FloatToInt"],"kind":"trait"},"17:12182:8429":{"crate_id":17,"path":["object","macho","DylibCommand"],"kind":"struct"},"16:7549:7056":{"crate_id":16,"path":["gimli","read","unit","DebuggingInformationEntry"],"kind":"struct"},"2:53405:9437":{"crate_id":2,"path":["core","core_arch","x86","__m128"],"kind":"struct"},"20:2669:2016":{"crate_id":20,"path":["regex_syntax","ast","RepetitionKind"],"kind":"enum"},"21:1403:7905":{"crate_id":21,"path":["aho_corasick","dfa","Premultiplied"],"kind":"struct"},"17:11678:8327":{"crate_id":17,"path":["object","elf","ProgramHeader32"],"kind":"struct"},"6:5197:10225":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","glob64_t"],"kind":"struct"},"16:5407:7091":{"crate_id":16,"path":["gimli","read","cfi","ParsedEhFrameHdr"],"kind":"struct"},"2:10446:9325":{"crate_id":2,"path":["core","fmt","fmt","BorrowedPlaceholder"],"kind":"struct"},"17:13331:8742":{"crate_id":17,"path":["object","pe","ImageAuxSymbolFunctionBeginEnd"],"kind":"struct"},"17:13154:8698":{"crate_id":17,"path":["object","pe","ImageNtHeaders64"],"kind":"struct"},"6:3972:9965":{"crate_id":6,"path":["libc","unix","linux_like","linux","if_nameindex"],"kind":"struct"},"5:3951:5446":{"crate_id":5,"path":["alloc","collections","linked_list","DrainFilter"],"kind":"struct"},"2:46296:5841":{"crate_id":2,"path":["core","char","convert","ParseCharError"],"kind":"struct"},"17:11981:8395":{"crate_id":17,"path":["object","macho","FatArch64"],"kind":"struct"},"17:542:7020":{"crate_id":17,"path":["object","read","any","Section"],"kind":"struct"},"6:6893:10553":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_rwlock_t"],"kind":"struct"},"2:11396:1599":{"crate_id":2,"path":["core","slice","iter","SplitN"],"kind":"struct"},"6:1665:9841":{"crate_id":6,"path":["libc","unix","linux_like","ifaddrs"],"kind":"struct"},"20:3168:4600":{"crate_id":20,"path":["regex_syntax","hir","ClassUnicode"],"kind":"struct"},"5:8330:6768":{"crate_id":5,"path":["alloc","ffi","c_str","FromVecWithNulError"],"kind":"struct"},"12:895:6948":{"crate_id":12,"path":["hashbrown","map","ConsumeAllOnDrop"],"kind":"struct"},"17:11962:8390":{"crate_id":17,"path":["object","macho","FatHeader"],"kind":"struct"},"16:6413:6969":{"crate_id":16,"path":["gimli","read","line","LineSequence"],"kind":"struct"},"16:6166:7116":{"crate_id":16,"path":["gimli","read","aranges","ArangeHeaderIter"],"kind":"struct"},"21:1239:4755":{"crate_id":21,"path":["aho_corasick","ahocorasick","FindIter"],"kind":"struct"},"17:13547:8800":{"crate_id":17,"path":["object","pe","ImageResourceDirStringU"],"kind":"struct"},"17:12431:8485":{"crate_id":17,"path":["object","macho","DylibReference"],"kind":"struct"},"6:3978:9968":{"crate_id":6,"path":["libc","unix","linux_like","linux","msginfo"],"kind":"struct"},"6:5987:10418":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","siginfo_t"],"kind":"struct"},"2:47679:3395":{"crate_id":2,"path":["core","result","IntoIter"],"kind":"struct"},"2:51543:6466":{"crate_id":2,"path":["core","core_arch","simd","u64x2"],"kind":"struct"},"17:9186:7432":{"crate_id":17,"path":["object","common","SectionFlags"],"kind":"enum"},"16:2733:7278":{"crate_id":16,"path":["gimli","common","Format"],"kind":"enum"},"16:7514:7068":{"crate_id":16,"path":["gimli","read","unit","UnitHeader"],"kind":"struct"},"22:853:142":{"crate_id":22,"path":["memchr","memmem","rabinkarp","Hash"],"kind":"struct"},"1:8807:162":{"crate_id":1,"path":["std","sync","mutex","Mutex"],"kind":"struct"},"2:51375:6427":{"crate_id":2,"path":["core","core_arch","simd","f32x2"],"kind":"struct"},"17:11304:49924":{"crate_id":17,"path":["object","read","RelocationTarget"],"kind":"enum"},"6:537:9688":{"crate_id":6,"path":["libc","unix","rlimit"],"kind":"struct"},"1:2192:6107":{"crate_id":1,"path":["std","collections","hash","set","Union"],"kind":"struct"},"5:2777:6788":{"crate_id":5,"path":["alloc","collections","btree","node","Handle"],"kind":"struct"},"2:47525:2027":{"crate_id":2,"path":["core","option","Item"],"kind":"struct"},"22:1005:5895":{"crate_id":22,"path":["memchr","memmem","FinderBuilder"],"kind":"struct"},"22:1013:3152":{"crate_id":22,"path":["memchr","memmem","Searcher"],"kind":"struct"},"21:1457:4599":{"crate_id":21,"path":["aho_corasick","error","ErrorKind"],"kind":"enum"},"2:3346:4837":{"crate_id":2,"path":["core","ops","arith","Mul"],"kind":"trait"},"2:32331:4636":{"crate_id":2,"path":["core","mem","maybe_uninit","MaybeUninit"],"kind":"union"},"1:15499:6981":{"crate_id":1,"path":["std","backtrace_rs","backtrace","Frame"],"kind":"struct"},"1:14576:6014":{"crate_id":1,"path":["std","sys","unix","fs","OpenOptions"],"kind":"struct"},"17:13598:8811":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation32V2"],"kind":"struct"},"1:12072:57039":{"crate_id":1,"path":["std","sync","mpsc","sync","Failure"],"kind":"enum"},"20:2878:127":{"crate_id":20,"path":["regex_syntax","error","Error"],"kind":"enum"},"17:11147:8258":{"crate_id":17,"path":["object","read","SymbolMap"],"kind":"struct"},"20:2938:2649":{"crate_id":20,"path":["regex_syntax","hir","literal","Literals"],"kind":"struct"},"22:870:5907":{"crate_id":22,"path":["memchr","memmem","rarebytes","RareNeedleBytes"],"kind":"struct"},"1:7796:6169":{"crate_id":1,"path":["std","process","exit"],"kind":"function"},"12:843:6181":{"crate_id":12,"path":["hashbrown","map","Keys"],"kind":"struct"},"12:0:4417":{"crate_id":12,"path":["hashbrown"],"kind":"module"},"1:10795:6078":{"crate_id":1,"path":["std","fs","Metadata"],"kind":"struct"},"2:48255:5345":{"crate_id":2,"path":["core","fmt","num","Binary"],"kind":"struct"},"6:3966:9963":{"crate_id":6,"path":["libc","unix","linux_like","linux","cpu_set_t"],"kind":"struct"},"21:1467:7532":{"crate_id":21,"path":["aho_corasick","nfa","NFA"],"kind":"struct"},"1:16017:4448":{"crate_id":1,"path":["std","i8"],"kind":"primitive"},"1:4670:6018":{"crate_id":1,"path":["std","io","Read"],"kind":"trait"},"20:3246:1975":{"crate_id":20,"path":["regex_syntax","hir","Anchor"],"kind":"enum"},"2:12056:7747":{"crate_id":2,"path":["core","slice","sort","CopyOnDrop"],"kind":"struct"},"16:4790:8972":{"crate_id":16,"path":["gimli","constants","DwDsc"],"kind":"struct"},"2:10241:5339":{"crate_id":2,"path":["core","fmt","Write"],"kind":"trait"},"17:11847:8373":{"crate_id":17,"path":["object","elf","GnuHashHeader"],"kind":"struct"},"22:1072:5900":{"crate_id":22,"path":["memchr","memmem","SearcherRevKind"],"kind":"enum"},"16:3195:7308":{"crate_id":16,"path":["gimli","common","DebugRngListsIndex"],"kind":"struct"},"18:678:142":{"crate_id":18,"path":["memchr","memmem","rabinkarp","Hash"],"kind":"struct"},"1:6441:6019":{"crate_id":1,"path":["std","os","unix","process","CommandExt"],"kind":"trait"},"1:10570:5938":{"crate_id":1,"path":["std","thread","local","AccessError"],"kind":"struct"},"5:5788:7723":{"crate_id":5,"path":["alloc","slice","hack","to_vec","DropGuard"],"kind":"struct"},"17:11915:8375":{"crate_id":17,"path":["object","macho","DyldCacheHeader"],"kind":"struct"},"1:9143:4575":{"crate_id":1,"path":["std","sync","rwlock","RwLock"],"kind":"struct"},"5:1653:6183":{"crate_id":5,"path":["alloc","collections","btree","map","ValuesMut"],"kind":"struct"},"5:8146:62828":{"crate_id":5,"path":["alloc","collections","btree","merge_iter","Peeked"],"kind":"enum"},"17:12659:8526":{"crate_id":17,"path":["object","macho","IdentCommand"],"kind":"struct"},"1:10948:6202":{"crate_id":1,"path":["std","io","error","SimpleMessage"],"kind":"struct"},"17:11809:8365":{"crate_id":17,"path":["object","elf","NoteHeader32"],"kind":"struct"},"17:11186:8260":{"crate_id":17,"path":["object","read","ObjectMap"],"kind":"struct"},"6:6239:10533":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","ucontext_t"],"kind":"struct"},"2:47663:3396":{"crate_id":2,"path":["core","result","Iter"],"kind":"struct"},"21:1670:7548":{"crate_id":21,"path":["aho_corasick","packed","rabinkarp","RabinKarp"],"kind":"struct"},"2:49862:6381":{"crate_id":2,"path":["core","str","pattern","CharSearcher"],"kind":"struct"},"17:9896:64161":{"crate_id":17,"path":["object","read","any","SymbolIteratorInternal"],"kind":"enum"},"16:7216:7142":{"crate_id":16,"path":["gimli","read","pubtypes","DebugPubTypes"],"kind":"struct"},"20:1921:2650":{"crate_id":20,"path":["regex_syntax","ast","parse","ParserBuilder"],"kind":"struct"},"17:13370:8752":{"crate_id":17,"path":["object","pe","ImageAuxSymbolCrc"],"kind":"struct"},"5:3044:62818":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Mut"],"kind":"struct"},"1:12049:6168":{"crate_id":1,"path":["std","process","ExitCode"],"kind":"struct"},"1:11073:6064":{"crate_id":1,"path":["std","io","util","Sink"],"kind":"struct"},"17:13258:8726":{"crate_id":17,"path":["object","pe","ImageSymbol"],"kind":"struct"},"6:1723:9876":{"crate_id":6,"path":["libc","unix","linux_like","epoll_event"],"kind":"struct"},"17:510:8075":{"crate_id":17,"path":["object","read","any","Segment"],"kind":"struct"},"2:45988:4539":{"crate_id":2,"path":["core","ops","range","Bound"],"kind":"enum"},"2:50199:6611":{"crate_id":2,"path":["core","str","UnsafeBytesToStr"],"kind":"struct"},"21:1503:2196":{"crate_id":21,"path":["aho_corasick","nfa","Transitions"],"kind":"enum"},"1:10870:6051":{"crate_id":1,"path":["std","io","buffered","IntoInnerError"],"kind":"struct"},"21:1444:5858":{"crate_id":21,"path":["aho_corasick","dfa","Builder"],"kind":"struct"},"5:3341:6731":{"crate_id":5,"path":["alloc","collections","btree","set","DifferenceInner"],"kind":"enum"},"6:5228:10236":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","termios"],"kind":"struct"},"18:169:4788":{"crate_id":18,"path":["memchr","memchr","iter","Memchr3"],"kind":"struct"},"18:838:3152":{"crate_id":18,"path":["memchr","memmem","Searcher"],"kind":"struct"},"2:3395:4846":{"crate_id":2,"path":["core","ops","bit","BitAnd"],"kind":"trait"},"2:22546:61677":{"crate_id":2,"path":["core","core_simd","swizzle","rotate_lanes_left","Rotate"],"kind":"struct"},"17:10001:49968":{"crate_id":17,"path":["object","read","archive","ArchiveKind"],"kind":"enum"},"18:651:5901":{"crate_id":18,"path":["memchr","memmem","prefilter","Prefilter"],"kind":"enum"},"1:4036:6205":{"crate_id":1,"path":["std","io","error","repr_bitpacked","Repr"],"kind":"struct"},"6:1527:9752":{"crate_id":6,"path":["libc","unix","linux_like","ip_mreq"],"kind":"struct"},"17:13119:8697":{"crate_id":17,"path":["object","pe","ImageOptionalHeader64"],"kind":"struct"},"1:14805:9481":{"crate_id":1,"path":["std","sys","unix","os","JoinPathsError"],"kind":"struct"},"2:52243:6452":{"crate_id":2,"path":["core","core_arch","simd","i8x32"],"kind":"struct"},"2:48558:127":{"crate_id":2,"path":["core","fmt","Error"],"kind":"struct"},"16:6208:7118":{"crate_id":16,"path":["gimli","read","aranges","ArangeEntryIter"],"kind":"struct"},"17:11835:8370":{"crate_id":17,"path":["object","elf","HashHeader"],"kind":"struct"},"17:10468:7463":{"crate_id":17,"path":["object","read","elf","hash","HashTable"],"kind":"struct"},"17:13163:8702":{"crate_id":17,"path":["object","pe","ImageNtHeaders32"],"kind":"struct"},"17:4008:8082":{"crate_id":17,"path":["object","read","macho","symbol","MachOSymbolIterator"],"kind":"struct"},"2:46578:4663":{"crate_id":2,"path":["core","iter","adapters","by_ref_sized","ByRefSized"],"kind":"struct"},"16:3429:7034":{"crate_id":16,"path":["gimli","common","SectionId"],"kind":"enum"},"10:0:4415":{"crate_id":10,"path":["rustc_std_workspace_alloc"],"kind":"module"},"20:3188:1974":{"crate_id":20,"path":["regex_syntax","hir","ClassUnicodeRange"],"kind":"struct"},"2:4782:5492":{"crate_id":2,"path":["core","async_iter","async_iter","AsyncIterator"],"kind":"trait"},"1:3355:6248":{"crate_id":1,"path":["std","fs","read_dir"],"kind":"function"},"2:49197:6600":{"crate_id":2,"path":["core","slice","iter","GenericSplitN"],"kind":"struct"},"17:2314:7396":{"crate_id":17,"path":["object","read","elf","symbol","ElfSymbolIterator"],"kind":"struct"},"17:9933:8170":{"crate_id":17,"path":["object","read","any","DynamicRelocationIterator"],"kind":"struct"},"22:966:4755":{"crate_id":22,"path":["memchr","memmem","FindIter"],"kind":"struct"},"5:8138:6776":{"crate_id":5,"path":["alloc","collections","binary_heap","DrainSorted"],"kind":"struct"},"6:599:9728":{"crate_id":6,"path":["libc","unix","linger"],"kind":"struct"},"1:12740:7774":{"crate_id":1,"path":["std","sys","unix","fs","Dir"],"kind":"struct"},"2:3363:4838":{"crate_id":2,"path":["core","ops","arith","Neg"],"kind":"trait"},"9:692:6819":{"crate_id":9,"path":["miniz_oxide","deflate","core","CompressionStrategy"],"kind":"enum"},"20:2655:7519":{"crate_id":20,"path":["regex_syntax","ast","RepetitionOp"],"kind":"struct"},"2:46063:3004":{"crate_id":2,"path":["core","any","tags","Ref"],"kind":"struct"},"12:869:5448":{"crate_id":12,"path":["hashbrown","map","Drain"],"kind":"struct"},"16:2754:7294":{"crate_id":16,"path":["gimli","common","Encoding"],"kind":"struct"},"20:2100:4606":{"crate_id":20,"path":["regex_syntax","ast","Span"],"kind":"struct"},"16:3800:8955":{"crate_id":16,"path":["gimli","constants","DwChildren"],"kind":"struct"},"2:46628:4129":{"crate_id":2,"path":["core","iter","adapters","enumerate","Enumerate"],"kind":"struct"},"2:46108:6537":{"crate_id":2,"path":["core","array","TryFromSliceError"],"kind":"struct"},"21:1225:7527":{"crate_id":21,"path":["aho_corasick","ahocorasick","Imp"],"kind":"enum"},"2:3518:130":{"crate_id":2,"path":["core","ops","function","Fn"],"kind":"trait"},"16:3320:7365":{"crate_id":16,"path":["gimli","common","DebugTypeSignature"],"kind":"struct"},"2:0:488":{"crate_id":2,"path":["core"],"kind":"module"},"21:1537:1622":{"crate_id":21,"path":["aho_corasick","nfa","Compiler"],"kind":"struct"},"2:13063:4876":{"crate_id":2,"path":["core","str","pattern","Pattern"],"kind":"trait"},"17:11665:8326":{"crate_id":17,"path":["object","elf","Rela64"],"kind":"struct"},"1:4082:205":{"crate_id":1,"path":["std","io","error","Result"],"kind":"typedef"},"2:10251:134":{"crate_id":2,"path":["core","fmt","Formatter"],"kind":"struct"},"2:32156:6682":{"crate_id":2,"path":["core","num","FpCategory"],"kind":"enum"},"2:24496:173":{"crate_id":2,"path":["core","num","nonzero","NonZeroU8"],"kind":"struct"},"1:10456:7772":{"crate_id":1,"path":["std","backtrace_rs","Bomb"],"kind":"struct"},"6:1522:9750":{"crate_id":6,"path":["libc","unix","linux_like","in_addr"],"kind":"struct"},"20:1958:7489":{"crate_id":20,"path":["regex_syntax","ast","parse","GroupState"],"kind":"enum"},"2:23771:6421":{"crate_id":2,"path":["core","core_simd","vector","SimdElement"],"kind":"trait"},"20:0:1634":{"crate_id":20,"path":["regex_syntax"],"kind":"module"},"17:12155:8425":{"crate_id":17,"path":["object","macho","FvmlibCommand"],"kind":"struct"},"1:4736:56970":{"crate_id":1,"path":["std","io","Write","write_fmt","Adapter"],"kind":"struct"},"6:6910:10558":{"crate_id":6,"path":["libc","unix","linux_like","linux","canfd_frame"],"kind":"struct"},"7:85:47596":{"crate_id":7,"path":["unwind","libunwind","_Unwind_Action"],"kind":"enum"},"6:5953:10399":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statfs"],"kind":"struct"},"2:56400:236":{"crate_id":2,"path":["core","core_simd","fmt","fmt","Wrapper"],"kind":"struct"},"1:14030:6164":{"crate_id":1,"path":["std","sys","unix","process","process_common","CommandArgs"],"kind":"struct"},"2:50187:6615":{"crate_id":2,"path":["core","str","IsAsciiWhitespace"],"kind":"struct"},"1:3196:128":{"crate_id":1,"path":["std","fs","File"],"kind":"struct"},"2:14078:6622":{"crate_id":2,"path":["core","task","wake","Waker"],"kind":"struct"},"2:10306:5347":{"crate_id":2,"path":["core","fmt","UpperHex"],"kind":"trait"},"20:2503:7512":{"crate_id":20,"path":["regex_syntax","ast","ClassSetItem"],"kind":"enum"},"5:8379:6721":{"crate_id":5,"path":["alloc","string","FromUtf8Error"],"kind":"struct"}},"external_crates":{"21":{"name":"aho_corasick","html_root_url":null},"15":{"name":"addr2line","html_root_url":"https://doc.rust-lang.org/nightly/"},"9":{"name":"miniz_oxide","html_root_url":"https://doc.rust-lang.org/nightly/"},"22":{"name":"memchr","html_root_url":null},"8":{"name":"cfg_if","html_root_url":"https://docs.rs/cfg-if/"},"6":{"name":"libc","html_root_url":"https://doc.rust-lang.org/nightly/"},"18":{"name":"memchr","html_root_url":"https://doc.rust-lang.org/nightly/"},"17":{"name":"object","html_root_url":"https://doc.rust-lang.org/nightly/"},"5":{"name":"alloc","html_root_url":"https://doc.rust-lang.org/nightly/"},"13":{"name":"std_detect","html_root_url":"https://doc.rust-lang.org/nightly/"},"20":{"name":"regex_syntax","html_root_url":null},"7":{"name":"unwind","html_root_url":"https://doc.rust-lang.org/nightly/"},"14":{"name":"rustc_demangle","html_root_url":"https://doc.rust-lang.org/nightly/"},"4":{"name":"rustc_std_workspace_core","html_root_url":"https://doc.rust-lang.org/nightly/"},"10":{"name":"rustc_std_workspace_alloc","html_root_url":"https://doc.rust-lang.org/nightly/"},"2":{"name":"core","html_root_url":"https://doc.rust-lang.org/nightly/"},"12":{"name":"hashbrown","html_root_url":"https://doc.rust-lang.org/nightly/"},"3":{"name":"compiler_builtins","html_root_url":"https://doc.rust-lang.org/nightly/"},"16":{"name":"gimli","html_root_url":"https://doc.rust-lang.org/nightly/"},"11":{"name":"adler","html_root_url":"https://docs.rs/adler/0.2.3/"},"19":{"name":"panic_unwind","html_root_url":"https://doc.rust-lang.org/nightly/"},"1":{"name":"std","html_root_url":"https://doc.rust-lang.org/nightly/"}},"format_version":16}