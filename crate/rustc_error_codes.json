{"root":"0:0","crate_version":"1.58.0-dev","includes_private":true,"index":{"2:12346":{"id":"2:12346","crate_id":2,"name":"split_whitespace","span":null,"visibility":"public","docs":"Splits a string slice by whitespace.\n\nThe iterator returned will return string slices that are sub-slices of\nthe original string slice, separated by any amount of whitespace.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`. If you only want to split on ASCII whitespace\ninstead, use [`split_ascii_whitespace`].\n\n[`split_ascii_whitespace`]: str::split_ascii_whitespace\n\n# Examples\n\nBasic usage:\n\n```\nlet mut iter = \"A few words\".split_whitespace();\n\nassert_eq!(Some(\"A\"), iter.next());\nassert_eq!(Some(\"few\"), iter.next());\nassert_eq!(Some(\"words\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\nAll kinds of whitespace are considered:\n\n```\nlet mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\nassert_eq!(Some(\"Mary\"), iter.next());\nassert_eq!(Some(\"had\"), iter.next());\nassert_eq!(Some(\"a\"), iter.next());\nassert_eq!(Some(\"little\"), iter.next());\nassert_eq!(Some(\"lamb\"), iter.next());\n\nassert_eq!(None, iter.next());\n```","links":{"str::split_ascii_whitespace":"1:15265"},"attrs":["#[must_use =\n  \"this returns the split string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"SplitWhitespace","id":"2:45541","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:9929":{"id":"2:9929","crate_id":2,"name":"SliceIndex","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":["2:9931","2:9932","2:9933","2:9934","2:9935","2:9936","2:9937"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"T"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"2:9920","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:3665":{"id":"2:3665","crate_id":2,"name":"Any","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3666"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"outlives":"'static"}],"implementors":[]}},"2:3045":{"id":"2:3045","crate_id":2,"name":"Unpin","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":true,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:7874":{"id":"2:7874","crate_id":2,"name":"FusedIterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Iterator","id":"2:7606","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:3300":{"id":"2:3300","crate_id":2,"name":"Index","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3302","2:3303"],"generics":{"params":[{"name":"Idx","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"Idx"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[],"implementors":[]}},"2:12331":{"id":"2:12331","crate_id":2,"name":"get","span":null,"visibility":"public","docs":"Returns a subslice of `str`.\n\nThis is the non-panicking alternative to indexing the `str`. Returns\n[`None`] whenever equivalent indexing operation would panic.\n\n# Examples\n\n```\nlet v = String::from(\"üóª‚ààüåè\");\n\nassert_eq!(Some(\"üóª\"), v.get(0..4));\n\n// indices not on UTF-8 sequence boundaries\nassert!(v.get(1..).is_none());\nassert!(v.get(..8).is_none());\n\n// out of bounds\nassert!(v.get(..42).is_none());\n```","links":{"`None`":"2:43419"},"attrs":["#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["i",{"kind":"generic","inner":"I"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:43419","args":{"angle_bracketed":{"args":[{"type":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"qualified_path","inner":{"name":"Output","self_type":{"kind":"generic","inner":"I"},"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:9929","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}}}}}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"I"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:9929","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3004":{"id":"2:3004","crate_id":2,"name":"Send","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":true,"is_unsafe":true,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"1:5394":{"id":"1:5394","crate_id":1,"name":"OsStrExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5395","1:5396"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10173","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"0:4":{"id":"0:4","crate_id":0,"name":"error_codes","span":{"filename":"compiler/rustc_error_codes/src/error_codes.rs","begin":[10,0],"end":[645,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"module","inner":{"is_crate":false,"items":["0:8"]}},"1:6603":{"id":"1:6603","crate_id":1,"name":"FromRawFd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6604"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12330":{"id":"2:12330","crate_id":2,"name":"as_mut_ptr","span":null,"visibility":"public","docs":"Converts a mutable string slice to a raw pointer.\n\nAs string slices are a slice of bytes, the raw pointer points to a\n[`u8`]. This pointer will be pointing to the first byte of the string\nslice.\n\nIt is your responsibility to make sure that the string slice only gets\nmodified in a way that it remains valid UTF-8.","links":{"`u8`":"1:15274"},"attrs":["#[stable(feature = \"str_as_mut_ptr\", since = \"1.36.0\")]","#[must_use]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"raw_pointer","inner":{"mutable":true,"type":{"kind":"primitive","inner":"u8"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"1:7475":{"id":"1:7475","crate_id":1,"name":"Termination","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:7476"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"5:5152":{"id":"5:5152","crate_id":5,"name":"Concat","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["5:5154","5:5155"],"generics":{"params":[{"name":"Item","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"Item"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[],"implementors":[]}},"2:12350":{"id":"2:12350","crate_id":2,"name":"encode_utf16","span":null,"visibility":"public","docs":"Returns an iterator of `u16` over the string encoded as UTF-16.\n\n# Examples\n\nBasic usage:\n\n```\nlet text = \"Za≈º√≥≈Çƒá gƒô≈õlƒÖ ja≈∫≈Ñ\";\n\nlet utf8_len = text.len();\nlet utf16_len = text.encode_utf16().count();\n\nassert!(utf16_len <= utf8_len);\n```","links":{},"attrs":["#[must_use =\n  \"this returns the encoded string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"EncodeUtf16","id":"2:45559","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"1:5538":{"id":"1:5538","crate_id":1,"name":"DirBuilderExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5539"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2904":{"id":"2:2904","crate_id":2,"name":"AsMut","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2906"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"T"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[],"implementors":[]}},"2:12401":{"id":"2:12401","crate_id":2,"name":"match_indices","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within this string\nslice as well as the index that the match starts at.\n\nFor matches of `pat` within `self` that overlap, only the indices\ncorresponding to the first match are returned.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rmatch_indices`] method can be used.\n\n[`rmatch_indices`]: str::rmatch_indices\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\nassert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n\nlet v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\nassert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n\nlet v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\nassert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n```","links":{"str::rmatch_indices":"1:15265","self::pattern":"2:11957","prim@char":"1:15260","`DoubleEndedIterator`":"2:7470"},"attrs":["#[stable(feature = \"str_match_indices\", since = \"1.5.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"MatchIndices","id":"2:45417","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3215":{"id":"2:3215","crate_id":2,"name":"Deref","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3216","2:3217"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12344":{"id":"2:12344","crate_id":2,"name":"char_indices","span":null,"visibility":"public","docs":"Returns an iterator over the [`char`]s of a string slice, and their\npositions.\n\nAs a string slice consists of valid UTF-8, we can iterate through a\nstring slice by [`char`]. This method returns an iterator of both\nthese [`char`]s, as well as their byte positions.\n\nThe iterator yields tuples. The position is first, the [`char`] is\nsecond.\n\n# Examples\n\nBasic usage:\n\n```\nlet word = \"goodbye\";\n\nlet count = word.char_indices().count();\nassert_eq!(7, count);\n\nlet mut char_indices = word.char_indices();\n\nassert_eq!(Some((0, 'g')), char_indices.next());\nassert_eq!(Some((1, 'o')), char_indices.next());\nassert_eq!(Some((2, 'o')), char_indices.next());\nassert_eq!(Some((3, 'd')), char_indices.next());\nassert_eq!(Some((4, 'b')), char_indices.next());\nassert_eq!(Some((5, 'y')), char_indices.next());\nassert_eq!(Some((6, 'e')), char_indices.next());\n\nassert_eq!(None, char_indices.next());\n```\n\nRemember, [`char`]s might not match your intuition about characters:\n\n[`char`]: prim@char\n\n```\nlet yes = \"yÃÜes\";\n\nlet mut char_indices = yes.char_indices();\n\nassert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'yÃÜ')\nassert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n\n// note the 3 here - the last character took up two bytes\nassert_eq!(Some((3, 'e')), char_indices.next());\nassert_eq!(Some((4, 's')), char_indices.next());\n\nassert_eq!(None, char_indices.next());\n```","links":{"prim@char":"1:15260"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"CharIndices","id":"2:45243","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12323":{"id":"2:12323","crate_id":2,"name":null,"span":null,"visibility":{"restricted":{"parent":"2:11428","path":"::str"}},"docs":null,"links":{},"attrs":["#[lang = \"str\"]","#[cfg(not(test))]"],"deprecation":null,"kind":"impl","inner":{"is_unsafe":false,"generics":{"params":[],"where_predicates":[]},"provided_trait_methods":[],"trait":null,"for":{"kind":"primitive","inner":"str"},"items":["2:12324","2:12325","2:12326","2:12327","2:12328","2:12329","2:12330","2:12331","2:12333","2:12335","2:12337","2:12339","2:12340","2:12341","2:12342","2:12343","2:12344","2:12345","2:12346","2:12347","2:12348","2:12349","2:12350","2:12351","2:12354","2:12357","2:12360","2:12364","2:12368","2:12371","2:12374","2:12377","2:12380","2:12383","2:12386","2:12389","2:12392","2:12395","2:12398","2:12401","2:12404","2:12407","2:12409","2:12411","2:12413","2:12414","2:12415","2:12418","2:12421","2:12424","2:12427","2:12430","2:12433","2:12436","2:12438","2:12439","2:12440","2:12441","2:12442","2:12444","2:12445"],"negative":false,"synthetic":false,"blanket_impl":null}},"2:12424":{"id":"2:12424","crate_id":2,"name":"strip_suffix","span":null,"visibility":"public","docs":"Returns a string slice with the suffix removed.\n\nIf the string ends with the pattern `suffix`, returns the substring before the suffix,\nwrapped in `Some`.  Unlike `trim_end_matches`, this method removes the suffix exactly once.\n\nIf the string does not end with `suffix`, returns `None`.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\n```\nassert_eq!(\"bar:foo\".strip_suffix(\":foo\"), Some(\"bar\"));\nassert_eq!(\"bar:foo\".strip_suffix(\"bar\"), None);\nassert_eq!(\"foofoo\".strip_suffix(\"foo\"), Some(\"foo\"));\n```","links":{"self::pattern":"2:11957","prim@char":"1:15260"},"attrs":["#[must_use =\n  \"this returns the remaining substring as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"str_strip\", since = \"1.45.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["suffix",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:43419","args":{"angle_bracketed":{"args":[{"type":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12418":{"id":"2:12418","crate_id":2,"name":"trim_start_matches","span":null,"visibility":"public","docs":"Returns a string slice with all prefixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. `start` in this context means the first\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be left side, and for right-to-left languages like\nArabic or Hebrew, this will be the right side.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(\"11foo1bar11\".trim_start_matches('1'), \"foo1bar11\");\nassert_eq!(\"123foo1bar123\".trim_start_matches(char::is_numeric), \"foo1bar123\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_start_matches(x), \"foo1bar12\");\n```","links":{"self::pattern":"2:11957","prim@char":"1:15260"},"attrs":["#[must_use =\n  \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"trim_direction\", since = \"1.30.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"5:5721":{"id":"5:5721","crate_id":5,"name":"ToString","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["5:5722"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:9363":{"id":"2:9363","crate_id":2,"name":"Octal","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9364"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3148":{"id":"2:3148","crate_id":2,"name":"Shr","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3150","2:3151"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"5:5407":{"id":"5:5407","crate_id":5,"name":"to_lowercase","span":null,"visibility":"public","docs":"Returns the lowercase equivalent of this string slice, as a new [`String`].\n\n'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n`Lowercase`.\n\nSince some characters can expand into multiple characters when changing\nthe case, this function returns a [`String`] instead of modifying the\nparameter in-place.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"HELLO\";\n\nassert_eq!(\"hello\", s.to_lowercase());\n```\n\nA tricky example, with sigma:\n\n```\nlet sigma = \"Œ£\";\n\nassert_eq!(\"œÉ\", sigma.to_lowercase());\n\n// but at the end of a word, it's œÇ, not œÉ:\nlet odysseus = \"·ΩàŒîŒ•Œ£Œ£ŒïŒéŒ£\";\n\nassert_eq!(\"·ΩÄŒ¥œÖœÉœÉŒµœçœÇ\", odysseus.to_lowercase());\n```\n\nLanguages without case are not changed:\n\n```\nlet new_year = \"ÂÜúÂéÜÊñ∞Âπ¥\";\n\nassert_eq!(new_year, new_year.to_lowercase());\n```","links":{"`String`":"5:7602"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n  \"this returns the lowercase string as a new String, \\\n                  without modifying the original\"]","#[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:7602","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3071":{"id":"2:3071","crate_id":2,"name":"Add","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3073","2:3074"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2625":{"id":"2:2625","crate_id":2,"name":"Clone","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2626","2:2627"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"5:5156":{"id":"5:5156","crate_id":5,"name":"Join","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["5:5158","5:5159"],"generics":{"params":[{"name":"Separator","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12377":{"id":"2:12377","crate_id":2,"name":"split_terminator","span":null,"visibility":"public","docs":"An iterator over substrings of the given string slice, separated by\ncharacters matched by a pattern.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\nEquivalent to [`split`], except that the trailing substring\nis skipped if empty.\n\n[`split`]: str::split\n\nThis method can be used for string data that is _terminated_,\nrather than _separated_ by a pattern.\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rsplit_terminator`] method can be used.\n\n[`rsplit_terminator`]: str::rsplit_terminator\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\nassert_eq!(v, [\"A\", \"B\"]);\n\nlet v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\nassert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n\nlet v: Vec<&str> = \"A.B:C.D\".split_terminator(&['.', ':'][..]).collect();\nassert_eq!(v, [\"A\", \"B\", \"C\", \"D\"]);\n```","links":{"str::rsplit_terminator":"1:15265","self::pattern":"2:11957","prim@char":"1:15260","str::split":"1:15265","`DoubleEndedIterator`":"2:7470"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"SplitTerminator","id":"2:45317","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12374":{"id":"2:12374","crate_id":2,"name":"rsplit","span":null,"visibility":"public","docs":"An iterator over substrings of the given string slice, separated by\ncharacters matched by a pattern and yielded in reverse order.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse\nsearch, and it will be a [`DoubleEndedIterator`] if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`split`] method can be used.\n\n[`split`]: str::split\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\nassert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n\nlet v: Vec<&str> = \"\".rsplit('X').collect();\nassert_eq!(v, [\"\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n```","links":{"`DoubleEndedIterator`":"2:7470","str::split":"1:15265","self::pattern":"2:11957","prim@char":"1:15260"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"RSplit","id":"2:45285","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12354":{"id":"2:12354","crate_id":2,"name":"starts_with","span":null,"visibility":"public","docs":"Returns `true` if the given pattern matches a prefix of this\nstring slice.\n\nReturns `false` if it does not.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nBasic usage:\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.starts_with(\"bana\"));\nassert!(!bananas.starts_with(\"nana\"));\n```","links":{"self::pattern":"2:11957","prim@char":"1:15260"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12668":{"id":"2:12668","crate_id":2,"name":"Future","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:12669","2:12670"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12329":{"id":"2:12329","crate_id":2,"name":"as_ptr","span":null,"visibility":"public","docs":"Converts a string slice to a raw pointer.\n\nAs string slices are a slice of bytes, the raw pointer points to a\n[`u8`]. This pointer will be pointing to the first byte of the string\nslice.\n\nThe caller must ensure that the returned pointer is never written to.\nIf you need to mutate the contents of the string slice, use [`as_mut_ptr`].\n\n[`as_mut_ptr`]: str::as_mut_ptr\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"Hello\";\nlet ptr = s.as_ptr();\n```","links":{"`u8`":"1:15274","str::as_mut_ptr":"1:15265"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_const_stable(feature = \"rustc_str_as_ptr\", since = \"1.32.0\")]","#[must_use]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"raw_pointer","inner":{"mutable":false,"type":{"kind":"primitive","inner":"u8"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":["const"],"abi":"\"Rust\"","has_body":true}},"2:3228":{"id":"2:3228","crate_id":2,"name":"DerefMut","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3229"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Deref","id":"2:3215","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:9570":{"id":"2:9570","crate_id":2,"name":"Hasher","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9571","2:9572","2:9573","2:9574","2:9575","2:9576","2:9577","2:9578","2:9579","2:9580","2:9581","2:9582","2:9583","2:9584"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"5:5400":{"id":"5:5400","crate_id":5,"name":"into_boxed_bytes","span":null,"visibility":"public","docs":"Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"this is a string\";\nlet boxed_str = s.to_owned().into_boxed_str();\nlet boxed_bytes = boxed_str.into_boxed_bytes();\nassert_eq!(*boxed_bytes, *s.as_bytes());\n```","links":{},"attrs":["#[stable(feature = \"str_box_extras\", since = \"1.20.0\")]","#[must_use = \"`self` will be dropped if the result is not used\"]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"resolved_path","inner":{"name":"Box","id":"5:196","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}},{"type":{"kind":"resolved_path","inner":{"name":"Global","id":"5:7385","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}}]],"output":{"kind":"resolved_path","inner":{"name":"Box","id":"5:196","args":{"angle_bracketed":{"args":[{"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}},{"type":{"kind":"resolved_path","inner":{"name":"Global","id":"5:7385","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:7422":{"id":"2:7422","crate_id":2,"name":"FromIterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:7424"],"generics":{"params":[{"name":"A","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:9375":{"id":"2:9375","crate_id":2,"name":"UpperExp","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9376"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"5:5419":{"id":"5:5419","crate_id":5,"name":"to_uppercase","span":null,"visibility":"public","docs":"Returns the uppercase equivalent of this string slice, as a new [`String`].\n\n'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n`Uppercase`.\n\nSince some characters can expand into multiple characters when changing\nthe case, this function returns a [`String`] instead of modifying the\nparameter in-place.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"hello\";\n\nassert_eq!(\"HELLO\", s.to_uppercase());\n```\n\nScripts without case are not changed:\n\n```\nlet new_year = \"ÂÜúÂéÜÊñ∞Âπ¥\";\n\nassert_eq!(new_year, new_year.to_uppercase());\n```\n\nOne character can become multiple:\n```\nlet s = \"tsch√º√ü\";\n\nassert_eq!(\"TSCH√úSS\", s.to_uppercase());\n```","links":{"`String`":"5:7602"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n  \"this returns the uppercase string as a new String, \\\n                  without modifying the original\"]","#[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:7602","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3076":{"id":"2:3076","crate_id":2,"name":"Sub","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3078","2:3079"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3282":{"id":"2:3282","crate_id":2,"name":"Generator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3284","2:3285","2:3286"],"generics":{"params":[{"name":"R","kind":{"type":{"bounds":[],"default":{"kind":"tuple","inner":[]}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"1:858":{"id":"1:858","crate_id":1,"name":"AsciiExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:859","1:860","1:861","1:862","1:863","1:864","1:865"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"1:5482":{"id":"1:5482","crate_id":1,"name":"MetadataExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5483","1:5484","1:5485","1:5486","1:5487","1:5488","1:5489","1:5490","1:5491","1:5492","1:5493","1:5494","1:5495","1:5496","1:5497","1:5498"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:9354":{"id":"2:9354","crate_id":2,"name":"Debug","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9355"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2660":{"id":"2:2660","crate_id":2,"name":"Eq","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"PartialEq","id":"2:2655","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:7881":{"id":"2:7881","crate_id":2,"name":"TrustedStep","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Step","id":"2:6975","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:3444":{"id":"2:3444","crate_id":2,"name":"Try","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3445","2:3446","2:3447","2:3448"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"FromResidual","id":"2:3449","args":{"angle_bracketed":{"args":[{"type":{"kind":"qualified_path","inner":{"name":"Residual","self_type":{"kind":"generic","inner":"Self"},"trait":{"kind":"resolved_path","inner":{"name":"Try","id":"2:3444","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"1:4713":{"id":"1:4713","crate_id":1,"name":"ToSocketAddrs","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:4714","1:4715"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"5:5423":{"id":"5:5423","crate_id":5,"name":"to_ascii_lowercase","span":null,"visibility":"public","docs":"Returns a copy of this string where each character is mapped to its\nASCII lower case equivalent.\n\nASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\nbut non-ASCII letters are unchanged.\n\nTo lowercase the value in-place, use [`make_ascii_lowercase`].\n\nTo lowercase ASCII characters in addition to non-ASCII characters, use\n[`to_lowercase`].\n\n# Examples\n\n```\nlet s = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert_eq!(\"gr√º√üe, j√ºrgen ‚ù§\", s.to_ascii_lowercase());\n```\n\n[`make_ascii_lowercase`]: str::make_ascii_lowercase\n[`to_lowercase`]: #method.to_lowercase","links":{"str::make_ascii_lowercase":"1:15265"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use = \"to lowercase the value in-place, use `make_ascii_lowercase()`\"]","#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:7602","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"1:6427":{"id":"1:6427","crate_id":1,"name":"MetadataExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6428","1:6429","1:6430","1:6431","1:6432","1:6433","1:6434","1:6435","1:6436","1:6437","1:6438","1:6439","1:6440","1:6441","1:6442","1:6443","1:6444"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3118":{"id":"2:3118","crate_id":2,"name":"RemAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3120"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:11967":{"id":"2:11967","crate_id":2,"name":"Pattern","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:11969","2:11970","2:11971","2:11972","2:11973","2:11974","2:11975"],"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12335":{"id":"2:12335","crate_id":2,"name":"get_unchecked","span":null,"visibility":"public","docs":"Returns an unchecked subslice of `str`.\n\nThis is the unchecked alternative to indexing the `str`.\n\n# Safety\n\nCallers of this function are responsible that these preconditions are\nsatisfied:\n\n* The starting index must not exceed the ending index;\n* Indexes must be within bounds of the original slice;\n* Indexes must lie on UTF-8 sequence boundaries.\n\nFailing that, the returned string slice may reference invalid memory or\nviolate the invariants communicated by the `str` type.\n\n# Examples\n\n```\nlet v = \"üóª‚ààüåè\";\nunsafe {\n    assert_eq!(\"üóª\", v.get_unchecked(0..4));\n    assert_eq!(\"‚àà\", v.get_unchecked(4..7));\n    assert_eq!(\"üåè\", v.get_unchecked(7..11));\n}\n```","links":{},"attrs":["#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["i",{"kind":"generic","inner":"I"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"qualified_path","inner":{"name":"Output","self_type":{"kind":"generic","inner":"I"},"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:9929","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}}}}}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"I"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:9929","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":["unsafe"],"abi":"\"Rust\"","has_body":true}},"2:3081":{"id":"2:3081","crate_id":2,"name":"Mul","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3083","2:3084"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"1:4346":{"id":"1:4346","crate_id":1,"name":"Read","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:4347","1:4348","1:4350","1:4351","1:4352","1:4353","1:4354","1:4355","1:4356","1:4357","1:4359"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:11894":{"id":"2:11894","crate_id":2,"name":"FromStr","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:11895","2:11896"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12380":{"id":"2:12380","crate_id":2,"name":"rsplit_terminator","span":null,"visibility":"public","docs":"An iterator over substrings of `self`, separated by characters\nmatched by a pattern and yielded in reverse order.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\nEquivalent to [`split`], except that the trailing substring is\nskipped if empty.\n\n[`split`]: str::split\n\nThis method can be used for string data that is _terminated_,\nrather than _separated_ by a pattern.\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a\nreverse search, and it will be double ended if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`split_terminator`] method can be\nused.\n\n[`split_terminator`]: str::split_terminator\n\n# Examples\n\n```\nlet v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\nassert_eq!(v, [\"B\", \"A\"]);\n\nlet v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\nassert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n\nlet v: Vec<&str> = \"A.B:C.D\".rsplit_terminator(&['.', ':'][..]).collect();\nassert_eq!(v, [\"D\", \"C\", \"B\", \"A\"]);\n```","links":{"str::split":"1:15265","self::pattern":"2:11957","str::split_terminator":"1:15265","prim@char":"1:15260"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"RSplitTerminator","id":"2:45335","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:2691":{"id":"2:2691","crate_id":2,"name":"Ord","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2692","2:2693","2:2694","2:2695"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Eq","id":"2:2660","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"PartialOrd","id":"2:2702","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:12383":{"id":"2:12383","crate_id":2,"name":"splitn","span":null,"visibility":"public","docs":"An iterator over substrings of the given string slice, separated by a\npattern, restricted to returning at most `n` items.\n\nIf `n` substrings are returned, the last substring (the `n`th substring)\nwill contain the remainder of the string.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will not be double ended, because it is\nnot efficient to support.\n\nIf the pattern allows a reverse search, the [`rsplitn`] method can be\nused.\n\n[`rsplitn`]: str::rsplitn\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\nassert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\nassert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n\nlet v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\nassert_eq!(v, [\"abcXdef\"]);\n\nlet v: Vec<&str> = \"\".splitn(1, 'X').collect();\nassert_eq!(v, [\"\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"abc\", \"defXghi\"]);\n```","links":{"self::pattern":"2:11957","prim@char":"1:15260","str::rsplitn":"1:15265"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["n",{"kind":"primitive","inner":"usize"}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"SplitN","id":"2:45371","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:7426":{"id":"2:7426","crate_id":2,"name":"IntoIterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:7427","2:7428","2:7429"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3132":{"id":"2:3132","crate_id":2,"name":"BitOr","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3134","2:3135"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:9369":{"id":"2:9369","crate_id":2,"name":"UpperHex","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9370"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:7495":{"id":"2:7495","crate_id":2,"name":"ExactSizeIterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:7496","2:7497"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Iterator","id":"2:7606","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"1:4424":{"id":"1:4424","crate_id":1,"name":"Seek","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:4425","1:4426","1:4427","1:4428"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12441":{"id":"2:12441","crate_id":2,"name":"make_ascii_lowercase","span":null,"visibility":"public","docs":"Converts this string to its ASCII lower case equivalent in-place.\n\nASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\nbut non-ASCII letters are unchanged.\n\nTo return a new lowercased value without modifying the existing one, use\n[`to_ascii_lowercase()`].\n\n[`to_ascii_lowercase()`]: #method.to_ascii_lowercase\n\n# Examples\n\n```\nlet mut s = String::from(\"GR√ú√üE, J√úRGEN ‚ù§\");\n\ns.make_ascii_lowercase();\n\nassert_eq!(\"gr√ú√üe, j√úrgen ‚ù§\", s);\n```","links":{},"attrs":["#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"tuple","inner":[]},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12439":{"id":"2:12439","crate_id":2,"name":"eq_ignore_ascii_case","span":null,"visibility":"public","docs":"Checks that two strings are an ASCII case-insensitive match.\n\nSame as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\nbut without allocating and copying temporaries.\n\n# Examples\n\n```\nassert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\nassert!(\"Ferr√∂s\".eq_ignore_ascii_case(\"FERR√∂S\"));\nassert!(!\"Ferr√∂s\".eq_ignore_ascii_case(\"FERR√ñS\"));\n```","links":{},"attrs":["#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]","#[must_use]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["other",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:7385":{"id":"2:7385","crate_id":2,"name":"Sum","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:7387"],"generics":{"params":[{"name":"A","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2982":{"id":"2:2982","crate_id":2,"name":"Default","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2983"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"1:2338":{"id":"1:2338","crate_id":1,"name":"Error","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:2339","1:2341","1:2342","1:2343"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Debug","id":"2:9354","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Display","id":"2:9361","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:3242":{"id":"2:3242","crate_id":2,"name":"Fn","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3244"],"generics":{"params":[{"name":"Args","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"FnMut","id":"2:3245","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Args"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:3166":{"id":"2:3166","crate_id":2,"name":"ShlAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3168"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12349":{"id":"2:12349","crate_id":2,"name":"lines_any","span":null,"visibility":"public","docs":"An iterator over the lines of a string.","links":{},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")]","#[inline]","#[allow(deprecated)]"],"deprecation":{"since":"1.4.0","note":"use lines() instead now"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"LinesAny","id":"2:45531","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12333":{"id":"2:12333","crate_id":2,"name":"get_mut","span":null,"visibility":"public","docs":"Returns a mutable subslice of `str`.\n\nThis is the non-panicking alternative to indexing the `str`. Returns\n[`None`] whenever equivalent indexing operation would panic.\n\n# Examples\n\n```\nlet mut v = String::from(\"hello\");\n// correct length\nassert!(v.get_mut(0..5).is_some());\n// out of bounds\nassert!(v.get_mut(..42).is_none());\nassert_eq!(Some(\"he\"), v.get_mut(0..2).map(|v| &*v));\n\nassert_eq!(\"hello\", v);\n{\n    let s = v.get_mut(0..2);\n    let s = s.map(|s| {\n        s.make_ascii_uppercase();\n        &*s\n    });\n    assert_eq!(Some(\"HE\"), s);\n}\nassert_eq!(\"HEllo\", v);\n```","links":{"`None`":"2:43419"},"attrs":["#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}],["i",{"kind":"generic","inner":"I"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:43419","args":{"angle_bracketed":{"args":[{"type":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"qualified_path","inner":{"name":"Output","self_type":{"kind":"generic","inner":"I"},"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:9929","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}}}}}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"I"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:9929","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:7606":{"id":"2:7606","crate_id":2,"name":"Iterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:7607","2:7608","2:7609","2:7610","2:7612","2:7615","2:7616","2:7617","2:7618","2:7620","2:7622","2:7623","2:7625","2:7628","2:7635","2:7637","2:7640","2:7641","2:7642","2:7644","2:7646","2:7649","2:7650","2:7651","2:7655","2:7658","2:7659","2:7660","2:7662","2:7663","2:7665","2:7675","2:7690","2:7692","2:7696","2:7705","2:7708","2:7710","2:7717","2:7724","2:7731","2:7740","2:7751","2:7758","2:7765","2:7766","2:7767","2:7779","2:7786","2:7798","2:7805","2:7806","2:7811","2:7814","2:7817","2:7818","2:7820","2:7822","2:7825","2:7828","2:7831","2:7834","2:7837","2:7840","2:7842","2:7844","2:7846","2:7848","2:7850","2:7851","2:7859"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12430":{"id":"2:12430","crate_id":2,"name":"trim_left_matches","span":null,"visibility":"public","docs":"Returns a string slice with all prefixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. 'Left' in this context means the first\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _right_ side, not the left.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\nassert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n```","links":{"prim@char":"1:15260","self::pattern":"2:11957"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_deprecated(since = \"1.33.0\", reason =\n                   \"superseded by `trim_start_matches`\", suggestion =\n                   \"trim_start_matches\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_start_matches`"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12351":{"id":"2:12351","crate_id":2,"name":"contains","span":null,"visibility":"public","docs":"Returns `true` if the given pattern matches a sub-slice of\nthis string slice.\n\nReturns `false` if it does not.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nBasic usage:\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.contains(\"nana\"));\nassert!(!bananas.contains(\"apples\"));\n```","links":{"self::pattern":"2:11957","prim@char":"1:15260"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12345":{"id":"2:12345","crate_id":2,"name":"bytes","span":null,"visibility":"public","docs":"An iterator over the bytes of a string slice.\n\nAs a string slice consists of a sequence of bytes, we can iterate\nthrough a string slice by byte. This method returns such an iterator.\n\n# Examples\n\nBasic usage:\n\n```\nlet mut bytes = \"bors\".bytes();\n\nassert_eq!(Some(b'b'), bytes.next());\nassert_eq!(Some(b'o'), bytes.next());\nassert_eq!(Some(b'r'), bytes.next());\nassert_eq!(Some(b's'), bytes.next());\n\nassert_eq!(None, bytes.next());\n```","links":{},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"Bytes","id":"2:45253","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3456":{"id":"2:3456","crate_id":2,"name":"CoerceUnsized","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"T"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[],"implementors":[]}},"1:6529":{"id":"1:6529","crate_id":1,"name":"ChildExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6530","1:6531"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10173","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:9305":{"id":"2:9305","crate_id":2,"name":"Write","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9306","2:9307","2:9309"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12364":{"id":"2:12364","crate_id":2,"name":"rfind","span":null,"visibility":"public","docs":"Returns the byte index for the first character of the rightmost match of the pattern in\nthis string slice.\n\nReturns [`None`] if the pattern doesn't match.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nSimple patterns:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard Gepardi\";\n\nassert_eq!(s.rfind('L'), Some(13));\nassert_eq!(s.rfind('√©'), Some(14));\nassert_eq!(s.rfind(\"pard\"), Some(24));\n```\n\nMore complex patterns with closures:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\n\nassert_eq!(s.rfind(char::is_whitespace), Some(12));\nassert_eq!(s.rfind(char::is_lowercase), Some(20));\n```\n\nNot finding the pattern:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\nlet x: &[_] = &['1', '2'];\n\nassert_eq!(s.rfind(x), None);\n```","links":{"prim@char":"1:15260","`None`":"2:43419","self::pattern":"2:11957"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:43419","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"usize"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"1:5388":{"id":"1:5388","crate_id":1,"name":"OsStringExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5389","1:5390"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10173","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:3102":{"id":"2:3102","crate_id":2,"name":"AddAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3104"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2907":{"id":"2:2907","crate_id":2,"name":"Into","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2909"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3016":{"id":"2:3016","crate_id":2,"name":"Sync","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":true,"is_unsafe":true,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:13020":{"id":"2:13020","crate_id":2,"name":"GlobalAlloc","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":["2:13021","2:13022","2:13023","2:13024"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"1:5530":{"id":"1:5530","crate_id":1,"name":"DirEntryExt2","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5531"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10173","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"1:6688":{"id":"1:6688","crate_id":1,"name":"AsFd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6689"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12395":{"id":"2:12395","crate_id":2,"name":"matches","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within the given string\nslice.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rmatches`] method can be used.\n\n[`rmatches`]: str::matches\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\nassert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n\nlet v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\nassert_eq!(v, [\"1\", \"2\", \"3\"]);\n```","links":{"`DoubleEndedIterator`":"2:7470","self::pattern":"2:11957","str::matches":"1:15265","prim@char":"1:15260"},"attrs":["#[stable(feature = \"str_matches\", since = \"1.2.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Matches","id":"2:45471","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12324":{"id":"2:12324","crate_id":2,"name":"len","span":null,"visibility":"public","docs":"Returns the length of `self`.\n\nThis length is in bytes, not [`char`]s or graphemes. In other words,\nit might not be what a human considers the length of the string.\n\n[`char`]: prim@char\n\n# Examples\n\nBasic usage:\n\n```\nlet len = \"foo\".len();\nassert_eq!(3, len);\n\nassert_eq!(\"∆íoo\".len(), 4); // fancy f!\nassert_eq!(\"∆íoo\".chars().count(), 3);\n```","links":{"prim@char":"1:15260"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_const_stable(feature = \"const_str_len\", since = \"1.39.0\")]","#[must_use]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"primitive","inner":"usize"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":["const"],"abi":"\"Rust\"","has_body":true}},"5:5420":{"id":"5:5420","crate_id":5,"name":"into_string","span":null,"visibility":"public","docs":"Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n\n# Examples\n\nBasic usage:\n\n```\nlet string = String::from(\"birthday gift\");\nlet boxed_str = string.clone().into_boxed_str();\n\nassert_eq!(boxed_str.into_string(), string);\n```","links":{"`String`":"5:7602","`Box<str>`":"5:196"},"attrs":["#[stable(feature = \"box_str\", since = \"1.4.0\")]","#[must_use = \"`self` will be dropped if the result is not used\"]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"resolved_path","inner":{"name":"Box","id":"5:196","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}},{"type":{"kind":"resolved_path","inner":{"name":"Global","id":"5:7385","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}],"bindings":[]}},"param_names":[]}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:7602","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12339":{"id":"2:12339","crate_id":2,"name":"slice_unchecked","span":null,"visibility":"public","docs":"Creates a string slice from another string slice, bypassing safety\nchecks.\n\nThis is generally not recommended, use with caution! For a safe\nalternative see [`str`] and [`Index`].\n\n[`Index`]: crate::ops::Index\n\nThis new slice goes from `begin` to `end`, including `begin` but\nexcluding `end`.\n\nTo get a mutable string slice instead, see the\n[`slice_mut_unchecked`] method.\n\n[`slice_mut_unchecked`]: str::slice_mut_unchecked\n\n# Safety\n\nCallers of this function are responsible that three preconditions are\nsatisfied:\n\n* `begin` must not exceed `end`.\n* `begin` and `end` must be byte positions within the string slice.\n* `begin` and `end` must lie on UTF-8 sequence boundaries.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\n\nunsafe {\n    assert_eq!(\"L√∂we ËÄÅËôé L√©opard\", s.slice_unchecked(0, 21));\n}\n\nlet s = \"Hello, world!\";\n\nunsafe {\n    assert_eq!(\"world\", s.slice_unchecked(7, 12));\n}\n```","links":{"`str`":"1:15265","crate::ops::Index":"2:3300","str::slice_mut_unchecked":"1:15265"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_deprecated(since = \"1.29.0\", reason =\n                   \"use `get_unchecked(begin..end)` instead\")]","#[must_use]","#[inline]"],"deprecation":{"since":"1.29.0","note":"use `get_unchecked(begin..end)` instead"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["begin",{"kind":"primitive","inner":"usize"}],["end",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":["unsafe"],"abi":"\"Rust\"","has_body":true}},"2:9371":{"id":"2:9371","crate_id":2,"name":"Pointer","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9372"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12325":{"id":"2:12325","crate_id":2,"name":"is_empty","span":null,"visibility":"public","docs":"Returns `true` if `self` has a length of zero bytes.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"\";\nassert!(s.is_empty());\n\nlet s = \"not empty\";\nassert!(!s.is_empty());\n```","links":{},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_const_stable(feature = \"const_str_is_empty\", since = \"1.39.0\")]","#[must_use]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":["const"],"abi":"\"Rust\"","has_body":true}},"2:12427":{"id":"2:12427","crate_id":2,"name":"trim_end_matches","span":null,"visibility":"public","docs":"Returns a string slice with all suffixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. `end` in this context means the last\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be right side, and for right-to-left languages like\nArabic or Hebrew, this will be the left side.\n\n# Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_end_matches('1'), \"11foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_end_matches(char::is_numeric), \"123foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_end_matches(x), \"12foo1bar\");\n```\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1fooX\".trim_end_matches(|c| c == '1' || c == 'X'), \"1foo\");\n```","links":{"self::pattern":"2:11957","prim@char":"1:15260"},"attrs":["#[must_use =\n  \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"trim_direction\", since = \"1.30.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12389":{"id":"2:12389","crate_id":2,"name":"split_once","span":null,"visibility":"public","docs":"Splits the string on the first occurrence of the specified delimiter and\nreturns prefix before delimiter and suffix after delimiter.\n\n# Examples\n\n```\nassert_eq!(\"cfg\".split_once('='), None);\nassert_eq!(\"cfg=foo\".split_once('='), Some((\"cfg\", \"foo\")));\nassert_eq!(\"cfg=foo=bar\".split_once('='), Some((\"cfg\", \"foo=bar\")));\n```","links":{},"attrs":["#[stable(feature = \"str_split_once\", since = \"1.52.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["delimiter",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:43419","args":{"angle_bracketed":{"args":[{"type":{"kind":"tuple","inner":[{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}}]}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:2606":{"id":"2:2606","crate_id":2,"name":"BorrowMut","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2608"],"generics":{"params":[{"name":"Borrowed","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"Borrowed"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Borrow","id":"2:2603","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Borrowed"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:12360":{"id":"2:12360","crate_id":2,"name":"find","span":null,"visibility":"public","docs":"Returns the byte index of the first character of this string slice that\nmatches the pattern.\n\nReturns [`None`] if the pattern doesn't match.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nSimple patterns:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard Gepardi\";\n\nassert_eq!(s.find('L'), Some(0));\nassert_eq!(s.find('√©'), Some(14));\nassert_eq!(s.find(\"pard\"), Some(17));\n```\n\nMore complex patterns using point-free style and closures:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\n\nassert_eq!(s.find(char::is_whitespace), Some(5));\nassert_eq!(s.find(char::is_lowercase), Some(1));\nassert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\nassert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));\n```\n\nNot finding the pattern:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\nlet x: &[_] = &['1', '2'];\n\nassert_eq!(s.find(x), None);\n```","links":{"prim@char":"1:15260","`None`":"2:43419","self::pattern":"2:11957"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:43419","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"usize"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"1:6601":{"id":"1:6601","crate_id":1,"name":"AsRawFd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6602"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:11415":{"id":"2:11415","crate_id":2,"name":"SlicePattern","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:11416","2:11417"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2901":{"id":"2:2901","crate_id":2,"name":"AsRef","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2903"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"T"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[],"implementors":[]}},"2:3304":{"id":"2:3304","crate_id":2,"name":"IndexMut","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3306"],"generics":{"params":[{"name":"Idx","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"Idx"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Index","id":"2:3300","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Idx"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"5:5401":{"id":"5:5401","crate_id":5,"name":"replace","span":null,"visibility":"public","docs":"Replaces all matches of a pattern with another string.\n\n`replace` creates a new [`String`], and copies the data from this string slice into it.\nWhile doing so, it attempts to find matches of a pattern. If it finds any, it\nreplaces them with the replacement string slice.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"this is old\";\n\nassert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\n```\n\nWhen the pattern doesn't match:\n\n```\nlet s = \"this is old\";\nassert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n```","links":{"`String`":"5:7602"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n  \"this returns the replaced string as a new allocation, \\\n                  without modifying the original\"]","#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["from",{"kind":"generic","inner":"P"}],["to",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:7602","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3137":{"id":"2:3137","crate_id":2,"name":"BitXor","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3139","2:3140"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12407":{"id":"2:12407","crate_id":2,"name":"trim","span":null,"visibility":"public","docs":"Returns a string slice with leading and trailing whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \" Hello\\tworld\\t\";\n\nassert_eq!(\"Hello\\tworld\", s.trim());\n```","links":{},"attrs":["#[inline]","#[must_use =\n  \"this returns the trimmed string as a slice, \\\n                  without modifying the original\"]","#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"1:6532":{"id":"1:6532","crate_id":1,"name":"CommandExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6533"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10173","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:12327":{"id":"2:12327","crate_id":2,"name":"as_bytes","span":null,"visibility":"public","docs":"Converts a string slice to a byte slice. To convert the byte slice back\ninto a string slice, use the [`from_utf8`] function.\n\n# Examples\n\nBasic usage:\n\n```\nlet bytes = \"bors\".as_bytes();\nassert_eq!(b\"bors\", bytes);\n```","links":{"`from_utf8`":"2:11439"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_const_stable(feature = \"str_as_bytes\", since = \"1.39.0\")]","#[must_use]","#[inline(always)]","#[allow(unused_attributes)]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":["const"],"abi":"\"Rust\"","has_body":true}},"2:12409":{"id":"2:12409","crate_id":2,"name":"trim_start","span":null,"visibility":"public","docs":"Returns a string slice with leading whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`.\n\n# Text directionality\n\nA string is a sequence of bytes. `start` in this context means the first\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be left side, and for right-to-left languages like\nArabic or Hebrew, this will be the right side.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \" Hello\\tworld\\t\";\nassert_eq!(\"Hello\\tworld\\t\", s.trim_start());\n```\n\nDirectionality:\n\n```\nlet s = \"  English  \";\nassert!(Some('E') == s.trim_start().chars().next());\n\nlet s = \"  ◊¢◊ë◊®◊ô◊™  \";\nassert!(Some('◊¢') == s.trim_start().chars().next());\n```","links":{},"attrs":["#[inline]","#[must_use =\n  \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"trim_direction\", since = \"1.30.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:9601":{"id":"2:9601","crate_id":2,"name":"BuildHasher","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9602","2:9603","2:9604"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"1:6181":{"id":"1:6181","crate_id":1,"name":"CommandExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6182","1:6183","1:6184","1:6185","1:6187","1:6189","1:6190"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10173","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:2702":{"id":"2:2702","crate_id":2,"name":"PartialOrd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2704","2:2705","2:2706","2:2707","2:2708"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"Rhs"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"PartialEq","id":"2:2655","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Rhs"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:3114":{"id":"2:3114","crate_id":2,"name":"DivAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3116"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12368":{"id":"2:12368","crate_id":2,"name":"split","span":null,"visibility":"public","docs":"An iterator over substrings of this string slice, separated by\ncharacters matched by a pattern.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rsplit`] method can be used.\n\n[`rsplit`]: str::rsplit\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\nassert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n\nlet v: Vec<&str> = \"\".split('X').collect();\nassert_eq!(v, [\"\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\nassert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\nassert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n\nlet v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\nassert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n\nlet v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\nassert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n```\n\nIf the pattern is a slice of chars, split on each occurrence of any of the characters:\n\n```\nlet v: Vec<&str> = \"2020-11-03 23:59\".split(&['-', ' ', ':', '@'][..]).collect();\nassert_eq!(v, [\"2020\", \"11\", \"03\", \"23\", \"59\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n```\n\nIf a string contains multiple contiguous separators, you will end up\nwith empty strings in the output:\n\n```\nlet x = \"||||a||b|c\".to_string();\nlet d: Vec<_> = x.split('|').collect();\n\nassert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n```\n\nContiguous separators are separated by the empty string.\n\n```\nlet x = \"(///)\".to_string();\nlet d: Vec<_> = x.split('/').collect();\n\nassert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n```\n\nSeparators at the start or end of a string are neighbored\nby empty strings.\n\n```\nlet d: Vec<_> = \"010\".split(\"0\").collect();\nassert_eq!(d, &[\"\", \"1\", \"\"]);\n```\n\nWhen the empty string is used as a separator, it separates\nevery character in the string, along with the beginning\nand end of the string.\n\n```\nlet f: Vec<_> = \"rust\".split(\"\").collect();\nassert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n```\n\nContiguous separators can lead to possibly surprising behavior\nwhen whitespace is used as the separator. This code is correct:\n\n```\nlet x = \"    a  b c\".to_string();\nlet d: Vec<_> = x.split(' ').collect();\n\nassert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n```\n\nIt does _not_ give you:\n\n```,ignore\nassert_eq!(d, &[\"a\", \"b\", \"c\"]);\n```\n\nUse [`split_whitespace`] for this behavior.\n\n[`split_whitespace`]: str::split_whitespace","links":{"prim@char":"1:15260","str::split_whitespace":"1:15265","self::pattern":"2:11957","`DoubleEndedIterator`":"2:7470","str::rsplit":"1:15265"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Split","id":"2:45267","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:9560":{"id":"2:9560","crate_id":2,"name":"Hash","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9561","2:9563"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12341":{"id":"2:12341","crate_id":2,"name":"split_at","span":null,"visibility":"public","docs":"Divide one string slice into two at an index.\n\nThe argument, `mid`, should be a byte offset from the start of the\nstring. It must also be on the boundary of a UTF-8 code point.\n\nThe two slices returned go from the start of the string slice to `mid`,\nand from `mid` to the end of the string slice.\n\nTo get mutable string slices instead, see the [`split_at_mut`]\nmethod.\n\n[`split_at_mut`]: str::split_at_mut\n\n# Panics\n\nPanics if `mid` is not on a UTF-8 code point boundary, or if it is\npast the end of the last code point of the string slice.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"Per Martin-L√∂f\";\n\nlet (first, last) = s.split_at(3);\n\nassert_eq!(\"Per\", first);\nassert_eq!(\" Martin-L√∂f\", last);\n```","links":{"str::split_at_mut":"1:15265"},"attrs":["#[inline]","#[must_use]","#[stable(feature = \"str_split_at\", since = \"1.4.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["mid",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"tuple","inner":[{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}}]},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3449":{"id":"2:3449","crate_id":2,"name":"FromResidual","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3451"],"generics":{"params":[{"name":"R","kind":{"type":{"bounds":[],"default":{"kind":"qualified_path","inner":{"name":"Residual","self_type":{"kind":"generic","inner":"Self"},"trait":{"kind":"resolved_path","inner":{"name":"Try","id":"2:3444","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12411":{"id":"2:12411","crate_id":2,"name":"trim_end","span":null,"visibility":"public","docs":"Returns a string slice with trailing whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`.\n\n# Text directionality\n\nA string is a sequence of bytes. `end` in this context means the last\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be right side, and for right-to-left languages like\nArabic or Hebrew, this will be the left side.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \" Hello\\tworld\\t\";\nassert_eq!(\" Hello\\tworld\", s.trim_end());\n```\n\nDirectionality:\n\n```\nlet s = \"  English  \";\nassert!(Some('h') == s.trim_end().chars().rev().next());\n\nlet s = \"  ◊¢◊ë◊®◊ô◊™  \";\nassert!(Some('◊™') == s.trim_end().chars().rev().next());\n```","links":{},"attrs":["#[inline]","#[must_use =\n  \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"trim_direction\", since = \"1.30.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12357":{"id":"2:12357","crate_id":2,"name":"ends_with","span":null,"visibility":"public","docs":"Returns `true` if the given pattern matches a suffix of this\nstring slice.\n\nReturns `false` if it does not.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nBasic usage:\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.ends_with(\"anas\"));\nassert!(!bananas.ends_with(\"nana\"));\n```","links":{"self::pattern":"2:11957","prim@char":"1:15260"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"1:4431":{"id":"1:4431","crate_id":1,"name":"BufRead","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:4432","1:4433","1:4434","1:4436","1:4437","1:4439","1:4440"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Read","id":"1:4346","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"5:5421":{"id":"5:5421","crate_id":5,"name":"repeat","span":null,"visibility":"public","docs":"Creates a new [`String`] by repeating a string `n` times.\n\n# Panics\n\nThis function will panic if the capacity would overflow.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n```\n\nA panic upon overflow:\n\n```should_panic\n// this will panic at runtime\nlet huge = \"0123456789abcdef\".repeat(usize::MAX);\n```","links":{"`String`":"5:7602"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use]","#[stable(feature = \"repeat_str\", since = \"1.16.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["n",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:7602","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:7389":{"id":"2:7389","crate_id":2,"name":"Product","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:7391"],"generics":{"params":[{"name":"A","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:8324":{"id":"2:8324","crate_id":2,"name":"UnwindSafe","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":true,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"1:6299":{"id":"1:6299","crate_id":1,"name":"JoinHandleExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6300","1:6301"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2839":{"id":"2:2839","crate_id":2,"name":"FloatToInt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[{"name":"Int","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"2:2838","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"1:5516":{"id":"1:5516","crate_id":1,"name":"FileTypeExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5517","1:5518","1:5519","1:5520"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2913":{"id":"2:2913","crate_id":2,"name":"TryInto","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2915","2:2916"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3493":{"id":"2:3493","crate_id":2,"name":"DispatchFromDyn","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12342":{"id":"2:12342","crate_id":2,"name":"split_at_mut","span":null,"visibility":"public","docs":"Divide one mutable string slice into two at an index.\n\nThe argument, `mid`, should be a byte offset from the start of the\nstring. It must also be on the boundary of a UTF-8 code point.\n\nThe two slices returned go from the start of the string slice to `mid`,\nand from `mid` to the end of the string slice.\n\nTo get immutable string slices instead, see the [`split_at`] method.\n\n[`split_at`]: str::split_at\n\n# Panics\n\nPanics if `mid` is not on a UTF-8 code point boundary, or if it is\npast the end of the last code point of the string slice.\n\n# Examples\n\nBasic usage:\n\n```\nlet mut s = \"Per Martin-L√∂f\".to_string();\n{\n    let (first, last) = s.split_at_mut(3);\n    first.make_ascii_uppercase();\n    assert_eq!(\"PER\", first);\n    assert_eq!(\" Martin-L√∂f\", last);\n}\nassert_eq!(\"PER Martin-L√∂f\", s);\n```","links":{"str::split_at":"1:15265"},"attrs":["#[inline]","#[must_use]","#[stable(feature = \"str_split_at\", since = \"1.4.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}],["mid",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"tuple","inner":[{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"primitive","inner":"str"}}},{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"primitive","inner":"str"}}}]},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3092":{"id":"2:3092","crate_id":2,"name":"Rem","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3094","2:3095"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3013":{"id":"2:3013","crate_id":2,"name":"StructuralEq","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12445":{"id":"2:12445","crate_id":2,"name":"escape_unicode","span":null,"visibility":"public","docs":"Return an iterator that escapes each char in `self` with [`char::escape_unicode`].\n\n# Examples\n\nAs an iterator:\n\n```\nfor c in \"‚ù§\\n!\".escape_unicode() {\n    print!(\"{}\", c);\n}\nprintln!();\n```\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"‚ù§\\n!\".escape_unicode());\n```\n\n\nBoth are equivalent to:\n\n```\nprintln!(\"\\\\u{{2764}}\\\\u{{a}}\\\\u{{21}}\");\n```\n\nUsing `to_string`:\n\n```\nassert_eq!(\"‚ù§\\n!\".escape_unicode().to_string(), \"\\\\u{2764}\\\\u{a}\\\\u{21}\");\n```","links":{"`char::escape_unicode`":"1:15260"},"attrs":["#[must_use =\n  \"this returns the escaped string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"str_escape\", since = \"1.34.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"EscapeUnicode","id":"2:45584","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12340":{"id":"2:12340","crate_id":2,"name":"slice_mut_unchecked","span":null,"visibility":"public","docs":"Creates a string slice from another string slice, bypassing safety\nchecks.\nThis is generally not recommended, use with caution! For a safe\nalternative see [`str`] and [`IndexMut`].\n\n[`IndexMut`]: crate::ops::IndexMut\n\nThis new slice goes from `begin` to `end`, including `begin` but\nexcluding `end`.\n\nTo get an immutable string slice instead, see the\n[`slice_unchecked`] method.\n\n[`slice_unchecked`]: str::slice_unchecked\n\n# Safety\n\nCallers of this function are responsible that three preconditions are\nsatisfied:\n\n* `begin` must not exceed `end`.\n* `begin` and `end` must be byte positions within the string slice.\n* `begin` and `end` must lie on UTF-8 sequence boundaries.","links":{"crate::ops::IndexMut":"2:3304","`str`":"1:15265","str::slice_unchecked":"1:15265"},"attrs":["#[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]","#[rustc_deprecated(since = \"1.29.0\", reason =\n                   \"use `get_unchecked_mut(begin..end)` instead\")]","#[inline]"],"deprecation":{"since":"1.29.0","note":"use `get_unchecked_mut(begin..end)` instead"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}],["begin",{"kind":"primitive","inner":"usize"}],["end",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":["unsafe"],"abi":"\"Rust\"","has_body":true}},"0:8":{"id":"0:8","crate_id":0,"name":"DIAGNOSTICS","span":{"filename":"compiler/rustc_error_codes/src/error_codes.rs","begin":[10,0],"end":[645,1]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"static","inner":{"type":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"slice","inner":{"kind":"tuple","inner":[{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},{"kind":"resolved_path","inner":{"name":"Option","id":"2:43419","args":{"angle_bracketed":{"args":[{"type":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}}}],"bindings":[]}},"param_names":[]}}]}}}},"mutable":false,"expr":"&[(\"E0001\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThis error suggests that the expression arm corresponding to the noted pattern\\nwill never be reached as for all possible values of the expression being\\nmatched, one of the preceding patterns will match.\\n\\nThis means that perhaps some of the preceding patterns are too general, this\\none is too specific or the ordering is incorrect.\\n\\nFor example, the following `match` block has too many arms:\\n\\n```\\nmatch Some(0) {\\n    Some(bar) => {/* ... */}\\n    x => {/* ... */} // This handles the `None` case\\n    _ => {/* ... */} // All possible cases have already been handled\\n}\\n```\\n\\n`match` blocks have their patterns matched in order, so, for example, putting\\na wildcard arm above a more specific arm will make the latter arm irrelevant.\\n\\nEnsure the ordering of the match arm is correct and remove any superfluous\\narms.\\n\")),\n  (\"E0002\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThis error indicates that an empty match expression is invalid because the type\\nit is matching on is non-empty (there exist values of this type). In safe code\\nit is impossible to create an instance of an empty type, so empty match\\nexpressions are almost never desired. This error is typically fixed by adding\\none or more cases to the match expression.\\n\\nAn example of an empty type is `enum Empty { }`. So, the following will work:\\n\\n```\\nenum Empty {}\\n\\nfn foo(x: Empty) {\\n    match x {\\n        // empty\\n    }\\n}\\n```\\n\\nHowever, this won\\'t:\\n\\n```compile_fail\\nfn foo(x: Option<String>) {\\n    match x {\\n        // empty\\n    }\\n}\\n```\\n\")),\n  (\"E0004\",\n   Some(\"This error indicates that the compiler cannot guarantee a matching pattern for\\none or more possible inputs to a match expression. Guaranteed matches are\\nrequired in order to assign values to match expressions, or alternatively,\\ndetermine the flow of execution.\\n\\nErroneous code example:\\n\\n```compile_fail,E0004\\nenum Terminator {\\n    HastaLaVistaBaby,\\n    TalkToMyHand,\\n}\\n\\nlet x = Terminator::HastaLaVistaBaby;\\n\\nmatch x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\\n    Terminator::TalkToMyHand => {}\\n}\\n```\\n\\nIf you encounter this error you must alter your patterns so that every possible\\nvalue of the input type is matched. For types with a small number of variants\\n(like enums) you should probably cover all cases explicitly. Alternatively, the\\nunderscore `_` wildcard pattern can be added after all other patterns to match\\n\\\"anything else\\\". Example:\\n\\n```\\nenum Terminator {\\n    HastaLaVistaBaby,\\n    TalkToMyHand,\\n}\\n\\nlet x = Terminator::HastaLaVistaBaby;\\n\\nmatch x {\\n    Terminator::TalkToMyHand => {}\\n    Terminator::HastaLaVistaBaby => {}\\n}\\n\\n// or:\\n\\nmatch x {\\n    Terminator::TalkToMyHand => {}\\n    _ => {}\\n}\\n```\\n\")),\n  (\"E0005\",\n   Some(\"Patterns used to bind names must be irrefutable, that is, they must guarantee\\nthat a name will be extracted in all cases.\\n\\nErroneous code example:\\n\\n```compile_fail,E0005\\nlet x = Some(1);\\nlet Some(y) = x;\\n// error: refutable pattern in local binding: `None` not covered\\n```\\n\\nIf you encounter this error you probably need to use a `match` or `if let` to\\ndeal with the possibility of failure. Example:\\n\\n```\\nlet x = Some(1);\\n\\nmatch x {\\n    Some(y) => {\\n        // do something\\n    },\\n    None => {}\\n}\\n\\n// or:\\n\\nif let Some(y) = x {\\n    // do something\\n}\\n```\\n\")),\n  (\"E0007\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThis error indicates that the bindings in a match arm would require a value to\\nbe moved into more than one location, thus violating unique ownership. Code\\nlike the following is invalid as it requires the entire `Option<String>` to be\\nmoved into a variable called `op_string` while simultaneously requiring the\\ninner `String` to be moved into a variable called `s`.\\n\\nErroneous code example:\\n\\n```compile_fail,E0382\\n#![feature(bindings_after_at)]\\n\\nlet x = Some(\\\"s\\\".to_string());\\n\\nmatch x {\\n    op_string @ Some(s) => {}, // error: use of moved value\\n    None => {},\\n}\\n```\\n\\nSee also the error E0303.\\n\")),\n  (\"E0009\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nIn a pattern, all values that don\\'t implement the `Copy` trait have to be bound\\nthe same way. The goal here is to avoid binding simultaneously by-move and\\nby-ref.\\n\\nThis limitation may be removed in a future version of Rust.\\n\\nErroneous code example:\\n\\n```\\n#![feature(move_ref_pattern)]\\n\\nstruct X { x: (), }\\n\\nlet x = Some((X { x: () }, X { x: () }));\\nmatch x {\\n    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the\\n                            //        same pattern\\n    None => panic!()\\n}\\n```\\n\\nYou have two solutions:\\n\\nSolution #1: Bind the pattern\\'s values the same way.\\n\\n```\\nstruct X { x: (), }\\n\\nlet x = Some((X { x: () }, X { x: () }));\\nmatch x {\\n    Some((ref y, ref z)) => {},\\n    // or Some((y, z)) => {}\\n    None => panic!()\\n}\\n```\\n\\nSolution #2: Implement the `Copy` trait for the `X` structure.\\n\\nHowever, please keep in mind that the first solution should be preferred.\\n\\n```\\n#[derive(Clone, Copy)]\\nstruct X { x: (), }\\n\\nlet x = Some((X { x: () }, X { x: () }));\\nmatch x {\\n    Some((y, ref z)) => {},\\n    None => panic!()\\n}\\n```\\n\")),\n  (\"E0010\",\n   Some(\"The value of statics and constants must be known at compile time, and they live\\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\\nthe heap at runtime, and therefore cannot be done at compile time.\\n\\nErroneous code example:\\n\\n```compile_fail,E0010\\n#![feature(box_syntax)]\\n\\nconst CON : Box<i32> = box 0;\\n```\\n\")),\n  (\"E0013\",\n   Some(\"Static and const variables can refer to other const variables. But a const\\nvariable cannot refer to a static variable.\\n\\nErroneous code example:\\n\\n```compile_fail,E0013\\nstatic X: i32 = 42;\\nconst Y: i32 = X;\\n```\\n\\nIn this example, `Y` cannot refer to `X`. To fix this, the value can be\\nextracted as a const and then used:\\n\\n```\\nconst A: i32 = 42;\\nstatic X: i32 = A;\\nconst Y: i32 = A;\\n```\\n\")),\n  (\"E0014\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nConstants can only be initialized by a constant value or, in a future\\nversion of Rust, a call to a const function. This error indicates the use\\nof a path (like a::b, or x) denoting something other than one of these\\nallowed items.\\n\\nErroneous code example:\\n\\n```\\nconst FOO: i32 = { let x = 0; x }; // \\'x\\' isn\\'t a constant nor a function!\\n```\\n\\nTo avoid it, you have to replace the non-constant value:\\n\\n```\\nconst FOO: i32 = { const X : i32 = 0; X };\\n// or even:\\nconst FOO2: i32 = { 0 }; // but brackets are useless here\\n```\\n\")),\n  (\"E0015\",\n   Some(\"A constant item was initialized with something that is not a constant\\nexpression.\\n\\nErroneous code example:\\n\\n```compile_fail,E0015\\nfn create_some() -> Option<u8> {\\n    Some(1)\\n}\\n\\nconst FOO: Option<u8> = create_some(); // error!\\n```\\n\\nThe only functions that can be called in static or constant expressions are\\n`const` functions, and struct/enum constructors.\\n\\nTo fix this error, you can declare `create_some` as a constant function:\\n\\n```\\nconst fn create_some() -> Option<u8> { // declared as a const function\\n    Some(1)\\n}\\n\\nconst FOO: Option<u8> = create_some(); // ok!\\n\\n// These are also working:\\nstruct Bar {\\n    x: u8,\\n}\\n\\nconst OTHER_FOO: Option<u8> = Some(1);\\nconst BAR: Bar = Bar {x: 1};\\n```\\n\")),\n  (\"E0023\",\n   Some(\"A pattern attempted to extract an incorrect number of fields from a variant.\\n\\nErroneous code example:\\n\\n```compile_fail,E0023\\nenum Fruit {\\n    Apple(String, String),\\n    Pear(u32),\\n}\\n\\nlet x = Fruit::Apple(String::new(), String::new());\\n\\nmatch x {\\n    Fruit::Apple(a) => {}, // error!\\n    _ => {}\\n}\\n```\\n\\nA pattern used to match against an enum variant must provide a sub-pattern for\\neach field of the enum variant.\\n\\nHere the `Apple` variant has two fields, and should be matched against like so:\\n\\n```\\nenum Fruit {\\n    Apple(String, String),\\n    Pear(u32),\\n}\\n\\nlet x = Fruit::Apple(String::new(), String::new());\\n\\n// Correct.\\nmatch x {\\n    Fruit::Apple(a, b) => {},\\n    _ => {}\\n}\\n```\\n\\nMatching with the wrong number of fields has no sensible interpretation:\\n\\n```compile_fail,E0023\\nenum Fruit {\\n    Apple(String, String),\\n    Pear(u32),\\n}\\n\\nlet x = Fruit::Apple(String::new(), String::new());\\n\\n// Incorrect.\\nmatch x {\\n    Fruit::Apple(a) => {},\\n    Fruit::Apple(a, b, c) => {},\\n}\\n```\\n\\nCheck how many fields the enum was declared with and ensure that your pattern\\nuses the same number.\\n\")),\n  (\"E0025\",\n   Some(\"Each field of a struct can only be bound once in a pattern.\\n\\nErroneous code example:\\n\\n```compile_fail,E0025\\nstruct Foo {\\n    a: u8,\\n    b: u8,\\n}\\n\\nfn main(){\\n    let x = Foo { a:1, b:2 };\\n\\n    let Foo { a: x, a: y } = x;\\n    // error: field `a` bound multiple times in the pattern\\n}\\n```\\n\\nEach occurrence of a field name binds the value of that field, so to fix this\\nerror you will have to remove or alter the duplicate uses of the field name.\\nPerhaps you misspelled another field name? Example:\\n\\n```\\nstruct Foo {\\n    a: u8,\\n    b: u8,\\n}\\n\\nfn main(){\\n    let x = Foo { a:1, b:2 };\\n\\n    let Foo { a: x, b: y } = x; // ok!\\n}\\n```\\n\")),\n  (\"E0026\",\n   Some(\"A struct pattern attempted to extract a non-existent field from a struct.\\n\\nErroneous code example:\\n\\n```compile_fail,E0026\\nstruct Thing {\\n    x: u32,\\n    y: u32,\\n}\\n\\nlet thing = Thing { x: 0, y: 0 };\\n\\nmatch thing {\\n    Thing { x, z } => {} // error: `Thing::z` field doesn\\'t exist\\n}\\n```\\n\\nIf you are using shorthand field patterns but want to refer to the struct field\\nby a different name, you should rename it explicitly. Struct fields are\\nidentified by the name used before the colon `:` so struct patterns should\\nresemble the declaration of the struct type being matched.\\n\\n```\\nstruct Thing {\\n    x: u32,\\n    y: u32,\\n}\\n\\nlet thing = Thing { x: 0, y: 0 };\\n\\nmatch thing {\\n    Thing { x, y: z } => {} // we renamed `y` to `z`\\n}\\n```\\n\")),\n  (\"E0027\",\n   Some(\"A pattern for a struct fails to specify a sub-pattern for every one of the\\nstruct\\'s fields.\\n\\nErroneous code example:\\n\\n```compile_fail,E0027\\nstruct Dog {\\n    name: String,\\n    age: u32,\\n}\\n\\nlet d = Dog { name: \\\"Rusty\\\".to_string(), age: 8 };\\n\\n// This is incorrect.\\nmatch d {\\n    Dog { age: x } => {}\\n}\\n```\\n\\nTo fix this error, ensure that each field from the struct\\'s definition is\\nmentioned in the pattern, or use `..` to ignore unwanted fields. Example:\\n\\n```\\nstruct Dog {\\n    name: String,\\n    age: u32,\\n}\\n\\nlet d = Dog { name: \\\"Rusty\\\".to_string(), age: 8 };\\n\\nmatch d {\\n    Dog { name: ref n, age: x } => {}\\n}\\n\\n// This is also correct (ignore unused fields).\\nmatch d {\\n    Dog { age: x, .. } => {}\\n}\\n```\\n\")),\n  (\"E0029\",\n   Some(\"Something other than numbers and characters has been used for a range.\\n\\nErroneous code example:\\n\\n```compile_fail,E0029\\nlet string = \\\"salutations !\\\";\\n\\n// The ordering relation for strings cannot be evaluated at compile time,\\n// so this doesn\\'t work:\\nmatch string {\\n    \\\"hello\\\" ..= \\\"world\\\" => {}\\n    _ => {}\\n}\\n\\n// This is a more general version, using a guard:\\nmatch string {\\n    s if s >= \\\"hello\\\" && s <= \\\"world\\\" => {}\\n    _ => {}\\n}\\n```\\n\\nIn a match expression, only numbers and characters can be matched against a\\nrange. This is because the compiler checks that the range is non-empty at\\ncompile-time, and is unable to evaluate arbitrary comparison functions. If you\\nwant to capture values of an orderable type between two end-points, you can use\\na guard.\\n\")),\n  (\"E0030\",\n   Some(\"When matching against a range, the compiler verifies that the range is\\nnon-empty. Range patterns include both end-points, so this is equivalent to\\nrequiring the start of the range to be less than or equal to the end of the\\nrange.\\n\\nErroneous code example:\\n\\n```compile_fail,E0030\\nmatch 5u32 {\\n    // This range is ok, albeit pointless.\\n    1 ..= 1 => {}\\n    // This range is empty, and the compiler can tell.\\n    1000 ..= 5 => {}\\n}\\n```\\n\")),\n  (\"E0033\",\n   Some(\"A trait type has been dereferenced.\\n\\nErroneous code example:\\n\\n```compile_fail,E0033\\n# trait SomeTrait { fn method_one(&self){} fn method_two(&self){} }\\n# impl<T> SomeTrait for T {}\\nlet trait_obj: &SomeTrait = &\\\"some_value\\\";\\n\\n// This tries to implicitly dereference to create an unsized local variable.\\nlet &invalid = trait_obj;\\n\\n// You can call methods without binding to the value being pointed at.\\ntrait_obj.method_one();\\ntrait_obj.method_two();\\n```\\n\\nA pointer to a trait type cannot be implicitly dereferenced by a pattern. Every\\ntrait defines a type, but because the size of trait implementers isn\\'t fixed,\\nthis type has no compile-time size. Therefore, all accesses to trait types must\\nbe through pointers. If you encounter this error you should try to avoid\\ndereferencing the pointer.\\n\\nYou can read more about trait objects in the [Trait Objects] section of the\\nReference.\\n\\n[Trait Objects]: https://doc.rust-lang.org/reference/types.html#trait-objects\\n\")),\n  (\"E0034\",\n   Some(\"The compiler doesn\\'t know what method to call because more than one method\\nhas the same prototype.\\n\\nErroneous code example:\\n\\n```compile_fail,E0034\\nstruct Test;\\n\\ntrait Trait1 {\\n    fn foo();\\n}\\n\\ntrait Trait2 {\\n    fn foo();\\n}\\n\\nimpl Trait1 for Test { fn foo() {} }\\nimpl Trait2 for Test { fn foo() {} }\\n\\nfn main() {\\n    Test::foo() // error, which foo() to call?\\n}\\n```\\n\\nTo avoid this error, you have to keep only one of them and remove the others.\\nSo let\\'s take our example and fix it:\\n\\n```\\nstruct Test;\\n\\ntrait Trait1 {\\n    fn foo();\\n}\\n\\nimpl Trait1 for Test { fn foo() {} }\\n\\nfn main() {\\n    Test::foo() // and now that\\'s good!\\n}\\n```\\n\\nHowever, a better solution would be using fully explicit naming of type and\\ntrait:\\n\\n```\\nstruct Test;\\n\\ntrait Trait1 {\\n    fn foo();\\n}\\n\\ntrait Trait2 {\\n    fn foo();\\n}\\n\\nimpl Trait1 for Test { fn foo() {} }\\nimpl Trait2 for Test { fn foo() {} }\\n\\nfn main() {\\n    <Test as Trait1>::foo()\\n}\\n```\\n\\nOne last example:\\n\\n```\\ntrait F {\\n    fn m(&self);\\n}\\n\\ntrait G {\\n    fn m(&self);\\n}\\n\\nstruct X;\\n\\nimpl F for X { fn m(&self) { println!(\\\"I am F\\\"); } }\\nimpl G for X { fn m(&self) { println!(\\\"I am G\\\"); } }\\n\\nfn main() {\\n    let f = X;\\n\\n    F::m(&f); // it displays \\\"I am F\\\"\\n    G::m(&f); // it displays \\\"I am G\\\"\\n}\\n```\\n\")),\n  (\"E0038\",\n   Some(\"Trait objects like `Box<Trait>` can only be constructed when certain\\nrequirements are satisfied by the trait in question.\\n\\nTrait objects are a form of dynamic dispatch and use a dynamically sized type\\nfor the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\\ntype, as in `Box<Trait>`, the inner type is \\'unsized\\'. In such cases the boxed\\npointer is a \\'fat pointer\\' that contains an extra pointer to a table of methods\\n(among other things) for dynamic dispatch. This design mandates some\\nrestrictions on the types of traits that are allowed to be used in trait\\nobjects, which are collectively termed as \\'object safety\\' rules.\\n\\nAttempting to create a trait object for a non object-safe trait will trigger\\nthis error.\\n\\nThere are various rules:\\n\\n### The trait cannot require `Self: Sized`\\n\\nWhen `Trait` is treated as a type, the type does not implement the special\\n`Sized` trait, because the type does not have a known size at compile time and\\ncan only be accessed behind a pointer. Thus, if we have a trait like the\\nfollowing:\\n\\n```\\ntrait Foo where Self: Sized {\\n\\n}\\n```\\n\\nWe cannot create an object of type `Box<Foo>` or `&Foo` since in this case\\n`Self` would not be `Sized`.\\n\\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\\nas a trait object. If the trait comes from your own crate, consider removing\\nthis restriction.\\n\\n### Method references the `Self` type in its parameters or return type\\n\\nThis happens when a trait has a method like the following:\\n\\n```\\ntrait Trait {\\n    fn foo(&self) -> Self;\\n}\\n\\nimpl Trait for String {\\n    fn foo(&self) -> Self {\\n        \\\"hi\\\".to_owned()\\n    }\\n}\\n\\nimpl Trait for u8 {\\n    fn foo(&self) -> Self {\\n        1\\n    }\\n}\\n```\\n\\n(Note that `&self` and `&mut self` are okay, it\\'s additional `Self` types which\\ncause this problem.)\\n\\nIn such a case, the compiler cannot predict the return type of `foo()` in a\\nsituation like the following:\\n\\n```compile_fail,E0038\\ntrait Trait {\\n    fn foo(&self) -> Self;\\n}\\n\\nfn call_foo(x: Box<Trait>) {\\n    let y = x.foo(); // What type is y?\\n    // ...\\n}\\n```\\n\\nIf only some methods aren\\'t object-safe, you can add a `where Self: Sized` bound\\non them to mark them as explicitly unavailable to trait objects. The\\nfunctionality will still be available to all other implementers, including\\n`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`).\\n\\n```\\ntrait Trait {\\n    fn foo(&self) -> Self where Self: Sized;\\n    // more functions\\n}\\n```\\n\\nNow, `foo()` can no longer be called on a trait object, but you will now be\\nallowed to make a trait object, and that will be able to call any object-safe\\nmethods. With such a bound, one can still call `foo()` on types implementing\\nthat trait that aren\\'t behind trait objects.\\n\\n### Method has generic type parameters\\n\\nAs mentioned before, trait objects contain pointers to method tables. So, if we\\nhave:\\n\\n```\\ntrait Trait {\\n    fn foo(&self);\\n}\\n\\nimpl Trait for String {\\n    fn foo(&self) {\\n        // implementation 1\\n    }\\n}\\n\\nimpl Trait for u8 {\\n    fn foo(&self) {\\n        // implementation 2\\n    }\\n}\\n// ...\\n```\\n\\nAt compile time each implementation of `Trait` will produce a table containing\\nthe various methods (and other items) related to the implementation.\\n\\nThis works fine, but when the method gains generic parameters, we can have a\\nproblem.\\n\\nUsually, generic parameters get _monomorphized_. For example, if I have\\n\\n```\\nfn foo<T>(x: T) {\\n    // ...\\n}\\n```\\n\\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\\nother type substitution is different. Hence the compiler generates the\\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\\ncompiler will only generate code for `foo::<bool>()`. When we have additional\\ntype parameters, the number of monomorphized implementations the compiler\\ngenerates does not grow drastically, since the compiler will only generate an\\nimplementation if the function is called with unparametrized substitutions\\n(i.e., substitutions where none of the substituted types are themselves\\nparameterized).\\n\\nHowever, with trait objects we have to make a table containing _every_ object\\nthat implements the trait. Now, if it has type parameters, we need to add\\nimplementations for every type that implements the trait, and there could\\ntheoretically be an infinite number of types.\\n\\nFor example, with:\\n\\n```\\ntrait Trait {\\n    fn foo<T>(&self, on: T);\\n    // more methods\\n}\\n\\nimpl Trait for String {\\n    fn foo<T>(&self, on: T) {\\n        // implementation 1\\n    }\\n}\\n\\nimpl Trait for u8 {\\n    fn foo<T>(&self, on: T) {\\n        // implementation 2\\n    }\\n}\\n\\n// 8 more implementations\\n```\\n\\nNow, if we have the following code:\\n\\n```compile_fail,E0038\\n# trait Trait { fn foo<T>(&self, on: T); }\\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\\n# // etc.\\nfn call_foo(thing: Box<Trait>) {\\n    thing.foo(true); // this could be any one of the 8 types above\\n    thing.foo(1);\\n    thing.foo(\\\"hello\\\");\\n}\\n```\\n\\nWe don\\'t just need to create a table of all implementations of all methods of\\n`Trait`, we need to create such a table, for each different type fed to\\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\\\*(3\\ntypes being fed to `foo()`) = 30 implementations!\\n\\nWith real world traits these numbers can grow drastically.\\n\\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\\nfix for the sub-error above if you do not intend to call the method with type\\nparameters:\\n\\n```\\ntrait Trait {\\n    fn foo<T>(&self, on: T) where Self: Sized;\\n    // more methods\\n}\\n```\\n\\nIf this is not an option, consider replacing the type parameter with another\\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the\\nnumber of types you intend to feed to this method is limited, consider manually\\nlisting out the methods of different types.\\n\\n### Method has no receiver\\n\\nMethods that do not take a `self` parameter can\\'t be called since there won\\'t be\\na way to get a pointer to the method table for them.\\n\\n```\\ntrait Foo {\\n    fn foo() -> u8;\\n}\\n```\\n\\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\\nan implementation.\\n\\nAdding a `Self: Sized` bound to these methods will generally make this compile.\\n\\n```\\ntrait Foo {\\n    fn foo() -> u8 where Self: Sized;\\n}\\n```\\n\\n### The trait cannot contain associated constants\\n\\nJust like static functions, associated constants aren\\'t stored on the method\\ntable. If the trait or any subtrait contain an associated constant, they cannot\\nbe made into an object.\\n\\n```compile_fail,E0038\\ntrait Foo {\\n    const X: i32;\\n}\\n\\nimpl Foo {}\\n```\\n\\nA simple workaround is to use a helper method instead:\\n\\n```\\ntrait Foo {\\n    fn x(&self) -> i32;\\n}\\n```\\n\\n### The trait cannot use `Self` as a type parameter in the supertrait listing\\n\\nThis is similar to the second sub-error, but subtler. It happens in situations\\nlike the following:\\n\\n```compile_fail,E0038\\ntrait Super<A: ?Sized> {}\\n\\ntrait Trait: Super<Self> {\\n}\\n\\nstruct Foo;\\n\\nimpl Super<Foo> for Foo{}\\n\\nimpl Trait for Foo {}\\n\\nfn main() {\\n    let x: Box<dyn Trait>;\\n}\\n```\\n\\nHere, the supertrait might have methods as follows:\\n\\n```\\ntrait Super<A: ?Sized> {\\n    fn get_a(&self) -> &A; // note that this is object safe!\\n}\\n```\\n\\nIf the trait `Trait` was deriving from something like `Super<String>` or\\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\\n`get_a()` will definitely return an object of that type.\\n\\nHowever, if it derives from `Super<Self>`, even though `Super` is object safe,\\nthe method `get_a()` would return an object of unknown type when called on the\\nfunction. `Self` type parameters let us make object safe traits no longer safe,\\nso they are forbidden when specifying supertraits.\\n\\nThere\\'s no easy fix for this. Generally, code will need to be refactored so that\\nyou no longer need to derive from `Super<Self>`.\\n\")),\n  (\"E0040\",\n   Some(\"It is not allowed to manually call destructors in Rust.\\n\\nErroneous code example:\\n\\n```compile_fail,E0040\\nstruct Foo {\\n    x: i32,\\n}\\n\\nimpl Drop for Foo {\\n    fn drop(&mut self) {\\n        println!(\\\"kaboom\\\");\\n    }\\n}\\n\\nfn main() {\\n    let mut x = Foo { x: -7 };\\n    x.drop(); // error: explicit use of destructor method\\n}\\n```\\n\\nIt is unnecessary to do this since `drop` is called automatically whenever a\\nvalue goes out of scope. However, if you really need to drop a value by hand,\\nyou can use the `std::mem::drop` function:\\n\\n```\\nstruct Foo {\\n    x: i32,\\n}\\nimpl Drop for Foo {\\n    fn drop(&mut self) {\\n        println!(\\\"kaboom\\\");\\n    }\\n}\\nfn main() {\\n    let mut x = Foo { x: -7 };\\n    drop(x); // ok!\\n}\\n```\\n\")),\n  (\"E0044\",\n   Some(\"You cannot use type or const parameters on foreign items.\\n\\nExample of erroneous code:\\n\\n```compile_fail,E0044\\nextern \\\"C\\\" { fn some_func<T>(x: T); }\\n```\\n\\nTo fix this, replace the generic parameter with the specializations that you\\nneed:\\n\\n```\\nextern \\\"C\\\" { fn some_func_i32(x: i32); }\\nextern \\\"C\\\" { fn some_func_i64(x: i64); }\\n```\\n\")),\n  (\"E0045\",\n   Some(\"Variadic parameters have been used on a non-C ABI function.\\n\\nErroneous code example:\\n\\n```compile_fail,E0045\\n#![feature(unboxed_closures)]\\n\\nextern \\\"rust-call\\\" {\\n    fn foo(x: u8, ...); // error!\\n}\\n```\\n\\nRust only supports variadic parameters for interoperability with C code in its\\nFFI. As such, variadic parameters can only be used with functions which are\\nusing the C ABI. To fix such code, put them in an extern \\\"C\\\" block:\\n\\n```\\nextern \\\"C\\\" {\\n    fn foo (x: u8, ...);\\n}\\n```\\n\")),\n  (\"E0046\",\n   Some(\"Items are missing in a trait implementation.\\n\\nErroneous code example:\\n\\n```compile_fail,E0046\\ntrait Foo {\\n    fn foo();\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {}\\n// error: not all trait items implemented, missing: `foo`\\n```\\n\\nWhen trying to make some type implement a trait `Foo`, you must, at minimum,\\nprovide implementations for all of `Foo`\\'s required methods (meaning the\\nmethods that do not have default implementations), as well as any required\\ntrait items like associated types or constants. Example:\\n\\n```\\ntrait Foo {\\n    fn foo();\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    fn foo() {} // ok!\\n}\\n```\\n\")),\n  (\"E0049\",\n   Some(\"An attempted implementation of a trait method has the wrong number of type or\\nconst parameters.\\n\\nErroneous code example:\\n\\n```compile_fail,E0049\\ntrait Foo {\\n    fn foo<T: Default>(x: T) -> Self;\\n}\\n\\nstruct Bar;\\n\\n// error: method `foo` has 0 type parameters but its trait declaration has 1\\n// type parameter\\nimpl Foo for Bar {\\n    fn foo(x: bool) -> Self { Bar }\\n}\\n```\\n\\nFor example, the `Foo` trait has a method `foo` with a type parameter `T`,\\nbut the implementation of `foo` for the type `Bar` is missing this parameter.\\nTo fix this error, they must have the same type parameters:\\n\\n```\\ntrait Foo {\\n    fn foo<T: Default>(x: T) -> Self;\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    fn foo<T: Default>(x: T) -> Self { // ok!\\n        Bar\\n    }\\n}\\n```\\n\")),\n  (\"E0050\",\n   Some(\"An attempted implementation of a trait method has the wrong number of function\\nparameters.\\n\\nErroneous code example:\\n\\n```compile_fail,E0050\\ntrait Foo {\\n    fn foo(&self, x: u8) -> bool;\\n}\\n\\nstruct Bar;\\n\\n// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`\\n// has 2\\nimpl Foo for Bar {\\n    fn foo(&self) -> bool { true }\\n}\\n```\\n\\nFor example, the `Foo` trait has a method `foo` with two function parameters\\n(`&self` and `u8`), but the implementation of `foo` for the type `Bar` omits\\nthe `u8` parameter. To fix this error, they must have the same parameters:\\n\\n```\\ntrait Foo {\\n    fn foo(&self, x: u8) -> bool;\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    fn foo(&self, x: u8) -> bool { // ok!\\n        true\\n    }\\n}\\n```\\n\")),\n  (\"E0053\",\n   Some(\"The parameters of any trait method must match between a trait implementation\\nand the trait definition.\\n\\nErroneous code example:\\n\\n```compile_fail,E0053\\ntrait Foo {\\n    fn foo(x: u16);\\n    fn bar(&self);\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    // error, expected u16, found i16\\n    fn foo(x: i16) { }\\n\\n    // error, types differ in mutability\\n    fn bar(&mut self) { }\\n}\\n```\\n\")),\n  (\"E0054\",\n   Some(\"It is not allowed to cast to a bool.\\n\\nErroneous code example:\\n\\n```compile_fail,E0054\\nlet x = 5;\\n\\n// Not allowed, won\\'t compile\\nlet x_is_nonzero = x as bool;\\n```\\n\\nIf you are trying to cast a numeric type to a bool, you can compare it with\\nzero instead:\\n\\n```\\nlet x = 5;\\n\\n// Ok\\nlet x_is_nonzero = x != 0;\\n```\\n\")),\n  (\"E0055\",\n   Some(\"During a method call, a value is automatically dereferenced as many times as\\nneeded to make the value\\'s type match the method\\'s receiver. The catch is that\\nthe compiler will only attempt to dereference a number of times up to the\\nrecursion limit (which can be set via the `recursion_limit` attribute).\\n\\nFor a somewhat artificial example:\\n\\n```compile_fail,E0055\\n#![recursion_limit=\\\"4\\\"]\\n\\nstruct Foo;\\n\\nimpl Foo {\\n    fn foo(&self) {}\\n}\\n\\nfn main() {\\n    let foo = Foo;\\n    let ref_foo = &&&&&Foo;\\n\\n    // error, reached the recursion limit while auto-dereferencing `&&&&&Foo`\\n    ref_foo.foo();\\n}\\n```\\n\\nOne fix may be to increase the recursion limit. Note that it is possible to\\ncreate an infinite recursion of dereferencing, in which case the only fix is to\\nsomehow break the recursion.\\n\")),\n  (\"E0057\",\n   Some(\"An invalid number of arguments was given when calling a closure.\\n\\nErroneous code example:\\n\\n```compile_fail,E0057\\nlet f = |x| x * 3;\\nlet a = f();        // invalid, too few parameters\\nlet b = f(4);       // this works!\\nlet c = f(2, 3);    // invalid, too many parameters\\n```\\n\\nWhen invoking closures or other implementations of the function traits `Fn`,\\n`FnMut` or `FnOnce` using call notation, the number of parameters passed to the\\nfunction must match its definition.\\n\\nA generic function must be treated similarly:\\n\\n```\\nfn foo<F: Fn()>(f: F) {\\n    f(); // this is valid, but f(3) would not work\\n}\\n```\\n\")),\n  (\"E0059\",\n   Some(\"The built-in function traits are generic over a tuple of the function arguments.\\nIf one uses angle-bracket notation (`Fn<(T,), Output=U>`) instead of parentheses\\n(`Fn(T) -> U`) to denote the function trait, the type parameter should be a\\ntuple. Otherwise function call notation cannot be used and the trait will not be\\nimplemented by closures.\\n\\nThe most likely source of this error is using angle-bracket notation without\\nwrapping the function argument type into a tuple, for example:\\n\\n```compile_fail,E0059\\n#![feature(unboxed_closures)]\\n\\nfn foo<F: Fn<i32>>(f: F) -> F::Output { f(3) }\\n```\\n\\nIt can be fixed by adjusting the trait bound like this:\\n\\n```\\n#![feature(unboxed_closures)]\\n\\nfn foo<F: Fn<(i32,)>>(f: F) -> F::Output { f(3) }\\n```\\n\\nNote that `(T,)` always denotes the type of a 1-tuple containing an element of\\ntype `T`. The comma is necessary for syntactic disambiguation.\\n\")),\n  (\"E0060\",\n   Some(\"External C functions are allowed to be variadic. However, a variadic function\\ntakes a minimum number of arguments. For example, consider C\\'s variadic `printf`\\nfunction:\\n\\n```compile_fail,E0060\\nuse std::os::raw::{c_char, c_int};\\n\\nextern \\\"C\\\" {\\n    fn printf(_: *const c_char, ...) -> c_int;\\n}\\n\\nunsafe { printf(); } // error!\\n```\\n\\nUsing this declaration, it must be called with at least one argument, so\\nsimply calling `printf()` is invalid. But the following uses are allowed:\\n\\n```\\n# #![feature(static_nobundle)]\\n# use std::os::raw::{c_char, c_int};\\n# #[cfg_attr(all(windows, target_env = \\\"msvc\\\"),\\n#            link(name = \\\"legacy_stdio_definitions\\\", kind = \\\"static-nobundle\\\"))]\\n# extern \\\"C\\\" { fn printf(_: *const c_char, ...) -> c_int; }\\n# fn main() {\\nunsafe {\\n    use std::ffi::CString;\\n\\n    let fmt = CString::new(\\\"test\\\\n\\\").unwrap();\\n    printf(fmt.as_ptr());\\n\\n    let fmt = CString::new(\\\"number = %d\\\\n\\\").unwrap();\\n    printf(fmt.as_ptr(), 3);\\n\\n    let fmt = CString::new(\\\"%d, %d\\\\n\\\").unwrap();\\n    printf(fmt.as_ptr(), 10, 5);\\n}\\n# }\\n```\\n\")),\n  (\"E0061\",\n   Some(\"An invalid number of arguments was passed when calling a function.\\n\\nErroneous code example:\\n\\n```compile_fail,E0061\\nfn f(u: i32) {}\\n\\nf(); // error!\\n```\\n\\nThe number of arguments passed to a function must match the number of arguments\\nspecified in the function signature.\\n\\nFor example, a function like:\\n\\n```\\nfn f(a: u16, b: &str) {}\\n```\\n\\nMust always be called with exactly two arguments, e.g., `f(2, \\\"test\\\")`.\\n\\nNote that Rust does not have a notion of optional function arguments or\\nvariadic functions (except for its C-FFI).\\n\")),\n  (\"E0062\",\n   Some(\"A struct\\'s or struct-like enum variant\\'s field was specified more than once.\\n\\nErroneous code example:\\n\\n```compile_fail,E0062\\nstruct Foo {\\n    x: i32,\\n}\\n\\nfn main() {\\n    let x = Foo {\\n                x: 0,\\n                x: 0, // error: field `x` specified more than once\\n            };\\n}\\n```\\n\\nThis error indicates that during an attempt to build a struct or struct-like\\nenum variant, one of the fields was specified more than once. Each field should\\nbe specified exactly one time. Example:\\n\\n```\\nstruct Foo {\\n    x: i32,\\n}\\n\\nfn main() {\\n    let x = Foo { x: 0 }; // ok!\\n}\\n```\\n\")),\n  (\"E0063\",\n   Some(\"A struct\\'s or struct-like enum variant\\'s field was not provided.\\n\\nErroneous code example:\\n\\n```compile_fail,E0063\\nstruct Foo {\\n    x: i32,\\n    y: i32,\\n}\\n\\nfn main() {\\n    let x = Foo { x: 0 }; // error: missing field: `y`\\n}\\n```\\n\\nEach field should be specified exactly once. Example:\\n\\n```\\nstruct Foo {\\n    x: i32,\\n    y: i32,\\n}\\n\\nfn main() {\\n    let x = Foo { x: 0, y: 0 }; // ok!\\n}\\n```\\n\")),\n  (\"E0067\",\n   Some(\"An invalid left-hand side expression was used on an assignment operation.\\n\\nErroneous code example:\\n\\n```compile_fail,E0067\\n12 += 1; // error!\\n```\\n\\nYou need to have a place expression to be able to assign it something. For\\nexample:\\n\\n```\\nlet mut x: i8 = 12;\\nx += 1; // ok!\\n```\\n\")),\n  (\"E0069\",\n   Some(\"The compiler found a function whose body contains a `return;` statement but\\nwhose return type is not `()`.\\n\\nErroneous code example:\\n\\n```compile_fail,E0069\\n// error\\nfn foo() -> u8 {\\n    return;\\n}\\n```\\n\\nSince `return;` is just like `return ();`, there is a mismatch between the\\nfunction\\'s return type and the value being returned.\\n\")),\n  (\"E0070\",\n   Some(\"An assignment operator was used on a non-place expression.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0070\\nstruct SomeStruct {\\n    x: i32,\\n    y: i32,\\n}\\n\\nconst SOME_CONST: i32 = 12;\\n\\nfn some_other_func() {}\\n\\nfn some_function() {\\n    SOME_CONST = 14; // error: a constant value cannot be changed!\\n    1 = 3; // error: 1 isn\\'t a valid place!\\n    some_other_func() = 4; // error: we cannot assign value to a function!\\n    SomeStruct::x = 12; // error: SomeStruct a structure name but it is used\\n                        //        like a variable!\\n}\\n```\\n\\nThe left-hand side of an assignment operator must be a place expression. A\\nplace expression represents a memory location and can be a variable (with\\noptional namespacing), a dereference, an indexing expression or a field\\nreference.\\n\\nMore details can be found in the [Expressions] section of the Reference.\\n\\n[Expressions]: https://doc.rust-lang.org/reference/expressions.html#places-rvalues-and-temporaries\\n\\nAnd now let\\'s give working examples:\\n\\n```\\nstruct SomeStruct {\\n    x: i32,\\n    y: i32,\\n}\\nlet mut s = SomeStruct { x: 0, y: 0 };\\n\\ns.x = 3; // that\\'s good !\\n\\n// ...\\n\\nfn some_func(x: &mut i32) {\\n    *x = 12; // that\\'s good !\\n}\\n```\\n\")),\n  (\"E0071\",\n   Some(\"A structure-literal syntax was used to create an item that is not a structure\\nor enum variant.\\n\\nExample of erroneous code:\\n\\n```compile_fail,E0071\\ntype U32 = u32;\\nlet t = U32 { value: 4 }; // error: expected struct, variant or union type,\\n                          // found builtin type `u32`\\n```\\n\\nTo fix this, ensure that the name was correctly spelled, and that the correct\\nform of initializer was used.\\n\\nFor example, the code above can be fixed to:\\n\\n```\\ntype U32 = u32;\\nlet t: U32 = 4;\\n```\\n\\nor:\\n\\n```\\nstruct U32 { value: u32 }\\nlet t = U32 { value: 4 };\\n```\\n\")),\n  (\"E0072\",\n   Some(\"A recursive type has infinite size because it doesn\\'t have an indirection.\\n\\nErroneous code example:\\n\\n```compile_fail,E0072\\nstruct ListNode {\\n    head: u8,\\n    tail: Option<ListNode>, // error: no indirection here so impossible to\\n                            //        compute the type\\'s size\\n}\\n```\\n\\nWhen defining a recursive struct or enum, any use of the type being defined\\nfrom inside the definition must occur behind a pointer (like `Box`, `&` or\\n`Rc`). This is because structs and enums must have a well-defined size, and\\nwithout the pointer, the size of the type would need to be unbounded.\\n\\nIn the example, the type cannot have a well-defined size, because it needs to be\\narbitrarily large (since we would be able to nest `ListNode`s to any depth).\\nSpecifically,\\n\\n```plain\\nsize of `ListNode` = 1 byte for `head`\\n                   + 1 byte for the discriminant of the `Option`\\n                   + size of `ListNode`\\n```\\n\\nOne way to fix this is by wrapping `ListNode` in a `Box`, like so:\\n\\n```\\nstruct ListNode {\\n    head: u8,\\n    tail: Option<Box<ListNode>>,\\n}\\n```\\n\\nThis works because `Box` is a pointer, so its size is well-known.\\n\")),\n  (\"E0073\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nYou cannot define a struct (or enum) `Foo` that requires an instance of `Foo`\\nin order to make a new `Foo` value. This is because there would be no way a\\nfirst instance of `Foo` could be made to initialize another instance!\\n\\nHere\\'s an example of a struct that has this problem:\\n\\n```\\nstruct Foo { x: Box<Foo> } // error\\n```\\n\\nOne fix is to use `Option`, like so:\\n\\n```\\nstruct Foo { x: Option<Box<Foo>> }\\n```\\n\\nNow it\\'s possible to create at least one instance of `Foo`: `Foo { x: None }`.\\n\")),\n  (\"E0074\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nWhen using the `#[simd]` attribute on a tuple struct, the components of the\\ntuple struct must all be of a concrete, nongeneric type so the compiler can\\nreason about how to use SIMD with them. This error will occur if the types\\nare generic.\\n\\nThis will cause an error:\\n\\n```\\n#![feature(repr_simd)]\\n\\n#[repr(simd)]\\nstruct Bad<T>(T, T, T, T);\\n```\\n\\nThis will not:\\n\\n```\\n#![feature(repr_simd)]\\n\\n#[repr(simd)]\\nstruct Good(u32, u32, u32, u32);\\n```\\n\")),\n  (\"E0075\",\n   Some(\"A `#[simd]` attribute was applied to an empty tuple struct.\\n\\nErroneous code example:\\n\\n```compile_fail,E0075\\n#![feature(repr_simd)]\\n\\n#[repr(simd)]\\nstruct Bad; // error!\\n```\\n\\nThe `#[simd]` attribute can only be applied to non empty tuple structs, because\\nit doesn\\'t make sense to try to use SIMD operations when there are no values to\\noperate on.\\n\\nFixed example:\\n\\n```\\n#![feature(repr_simd)]\\n\\n#[repr(simd)]\\nstruct Good(u32); // ok!\\n```\\n\")),\n  (\"E0076\",\n   Some(\"All types in a tuple struct aren\\'t the same when using the `#[simd]`\\nattribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0076\\n#![feature(repr_simd)]\\n\\n#[repr(simd)]\\nstruct Bad(u16, u32, u32 u32); // error!\\n```\\n\\nWhen using the `#[simd]` attribute to automatically use SIMD operations in tuple\\nstruct, the types in the struct must all be of the same type, or the compiler\\nwill trigger this error.\\n\\nFixed example:\\n\\n```\\n#![feature(repr_simd)]\\n\\n#[repr(simd)]\\nstruct Good(u32, u32, u32, u32); // ok!\\n```\\n\")),\n  (\"E0077\",\n   Some(\"A tuple struct\\'s element isn\\'t a machine type when using the `#[simd]`\\nattribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0077\\n#![feature(repr_simd)]\\n\\n#[repr(simd)]\\nstruct Bad(String); // error!\\n```\\n\\nWhen using the `#[simd]` attribute on a tuple struct, the elements in the tuple\\nmust be machine types so SIMD operations can be applied to them.\\n\\nFixed example:\\n\\n```\\n#![feature(repr_simd)]\\n\\n#[repr(simd)]\\nstruct Good(u32, u32, u32, u32); // ok!\\n```\\n\")),\n  (\"E0080\",\n   Some(\"A constant value failed to get evaluated.\\n\\nErroneous code example:\\n\\n```compile_fail,E0080\\nenum Enum {\\n    X = (1 << 500),\\n    Y = (1 / 0),\\n}\\n```\\n\\nThis error indicates that the compiler was unable to sensibly evaluate a\\nconstant expression that had to be evaluated. Attempting to divide by 0\\nor causing an integer overflow are two ways to induce this error.\\n\\nEnsure that the expressions given can be evaluated as the desired integer type.\\n\\nSee the [Custom Discriminants][custom-discriminants] section of the Reference\\nfor more information about setting custom integer types on fieldless enums\\nusing the [`repr` attribute][repr-attribute].\\n\\n[custom-discriminants]: https://doc.rust-lang.org/reference/items/enumerations.html#custom-discriminant-values-for-field-less-enumerations\\n[repr-attribute]: https://doc.rust-lang.org/reference/type-layout.html#reprc-enums\\n\")),\n  (\"E0081\",\n   Some(\"A discriminant value is present more than once.\\n\\nErroneous code example:\\n\\n```compile_fail,E0081\\nenum Enum {\\n    P = 3,\\n    X = 3, // error!\\n    Y = 5,\\n}\\n```\\n\\nEnum discriminants are used to differentiate enum variants stored in memory.\\nThis error indicates that the same value was used for two or more variants,\\nmaking it impossible to distinguish them.\\n\\n```\\nenum Enum {\\n    P,\\n    X = 3, // ok!\\n    Y = 5,\\n}\\n```\\n\\nNote that variants without a manually specified discriminant are numbered from\\ntop to bottom starting from 0, so clashes can occur with seemingly unrelated\\nvariants.\\n\\n```compile_fail,E0081\\nenum Bad {\\n    X,\\n    Y = 0, // error!\\n}\\n```\\n\\nHere `X` will have already been specified the discriminant 0 by the time `Y` is\\nencountered, so a conflict occurs.\\n\")),\n  (\"E0084\",\n   Some(\"An unsupported representation was attempted on a zero-variant enum.\\n\\nErroneous code example:\\n\\n```compile_fail,E0084\\n#[repr(i32)]\\nenum NightsWatch {} // error: unsupported representation for zero-variant enum\\n```\\n\\nIt is impossible to define an integer type to be used to represent zero-variant\\nenum values because there are no zero-variant enum values. There is no way to\\nconstruct an instance of the following type using only safe code. So you have\\ntwo solutions. Either you add variants in your enum:\\n\\n```\\n#[repr(i32)]\\nenum NightsWatch {\\n    JonSnow,\\n    Commander,\\n}\\n```\\n\\nor you remove the integer representation of your enum:\\n\\n```\\nenum NightsWatch {}\\n```\\n\")),\n  (\"E0087\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nToo many type arguments were supplied for a function. For example:\\n\\n```compile_fail,E0107\\nfn foo<T>() {}\\n\\nfn main() {\\n    foo::<f64, bool>(); // error: wrong number of type arguments:\\n                        //        expected 1, found 2\\n}\\n```\\n\\nThe number of supplied arguments must exactly match the number of defined type\\nparameters.\\n\")),\n  (\"E0088\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nYou gave too many lifetime arguments. Erroneous code example:\\n\\n```compile_fail,E0107\\nfn f() {}\\n\\nfn main() {\\n    f::<\\'static>() // error: wrong number of lifetime arguments:\\n                   //        expected 0, found 1\\n}\\n```\\n\\nPlease check you give the right number of lifetime arguments. Example:\\n\\n```\\nfn f() {}\\n\\nfn main() {\\n    f() // ok!\\n}\\n```\\n\\nIt\\'s also important to note that the Rust compiler can generally\\ndetermine the lifetime by itself. Example:\\n\\n```\\nstruct Foo {\\n    value: String\\n}\\n\\nimpl Foo {\\n    // it can be written like this\\n    fn get_value<\\'a>(&\\'a self) -> &\\'a str { &self.value }\\n    // but the compiler works fine with this too:\\n    fn without_lifetime(&self) -> &str { &self.value }\\n}\\n\\nfn main() {\\n    let f = Foo { value: \\\"hello\\\".to_owned() };\\n\\n    println!(\\\"{}\\\", f.get_value());\\n    println!(\\\"{}\\\", f.without_lifetime());\\n}\\n```\\n\")),\n  (\"E0089\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nToo few type arguments were supplied for a function. For example:\\n\\n```compile_fail,E0107\\nfn foo<T, U>() {}\\n\\nfn main() {\\n    foo::<f64>(); // error: wrong number of type arguments: expected 2, found 1\\n}\\n```\\n\\nNote that if a function takes multiple type arguments but you want the compiler\\nto infer some of them, you can use type placeholders:\\n\\n```compile_fail,E0107\\nfn foo<T, U>(x: T) {}\\n\\nfn main() {\\n    let x: bool = true;\\n    foo::<f64>(x);    // error: wrong number of type arguments:\\n                      //        expected 2, found 1\\n    foo::<_, f64>(x); // same as `foo::<bool, f64>(x)`\\n}\\n```\\n\")),\n  (\"E0090\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nYou gave too few lifetime arguments. Example:\\n\\n```compile_fail,E0107\\nfn foo<\\'a: \\'b, \\'b: \\'a>() {}\\n\\nfn main() {\\n    foo::<\\'static>(); // error: wrong number of lifetime arguments:\\n                      //        expected 2, found 1\\n}\\n```\\n\\nPlease check you give the right number of lifetime arguments. Example:\\n\\n```\\nfn foo<\\'a: \\'b, \\'b: \\'a>() {}\\n\\nfn main() {\\n    foo::<\\'static, \\'static>();\\n}\\n```\\n\")),\n  (\"E0091\",\n   Some(\"An unnecessary type or const parameter was given in a type alias.\\n\\nErroneous code example:\\n\\n```compile_fail,E0091\\ntype Foo<T> = u32; // error: type parameter `T` is unused\\n// or:\\ntype Foo<A,B> = Box<A>; // error: type parameter `B` is unused\\n```\\n\\nPlease check you didn\\'t write too many parameters. Example:\\n\\n```\\ntype Foo = u32; // ok!\\ntype Foo2<A> = Box<A>; // ok!\\n```\\n\")),\n  (\"E0092\",\n   Some(\"An undefined atomic operation function was declared.\\n\\nErroneous code example:\\n\\n```compile_fail,E0092\\n#![feature(intrinsics)]\\n\\nextern \\\"rust-intrinsic\\\" {\\n    fn atomic_foo(); // error: unrecognized atomic operation\\n                     //        function\\n}\\n```\\n\\nPlease check you didn\\'t make a mistake in the function\\'s name. All intrinsic\\nfunctions are defined in `compiler/rustc_codegen_llvm/src/intrinsic.rs` and in\\n`library/core/src/intrinsics.rs` in the Rust source code. Example:\\n\\n```\\n#![feature(intrinsics)]\\n\\nextern \\\"rust-intrinsic\\\" {\\n    fn atomic_fence(); // ok!\\n}\\n```\\n\")),\n  (\"E0093\",\n   Some(\"An unknown intrinsic function was declared.\\n\\nErroneous code example:\\n\\n```compile_fail,E0093\\n#![feature(intrinsics)]\\n\\nextern \\\"rust-intrinsic\\\" {\\n    fn foo(); // error: unrecognized intrinsic function: `foo`\\n}\\n\\nfn main() {\\n    unsafe {\\n        foo();\\n    }\\n}\\n```\\n\\nPlease check you didn\\'t make a mistake in the function\\'s name. All intrinsic\\nfunctions are defined in `compiler/rustc_codegen_llvm/src/intrinsic.rs` and in\\n`library/core/src/intrinsics.rs` in the Rust source code. Example:\\n\\n```\\n#![feature(intrinsics)]\\n\\nextern \\\"rust-intrinsic\\\" {\\n    fn atomic_fence(); // ok!\\n}\\n\\nfn main() {\\n    unsafe {\\n        atomic_fence();\\n    }\\n}\\n```\\n\")),\n  (\"E0094\",\n   Some(\"An invalid number of generic parameters was passed to an intrinsic function.\\n\\nErroneous code example:\\n\\n```compile_fail,E0094\\n#![feature(intrinsics)]\\n\\nextern \\\"rust-intrinsic\\\" {\\n    fn size_of<T, U>() -> usize; // error: intrinsic has wrong number\\n                                 //        of type parameters\\n}\\n```\\n\\nPlease check that you provided the right number of type parameters\\nand verify with the function declaration in the Rust source code.\\nExample:\\n\\n```\\n#![feature(intrinsics)]\\n\\nextern \\\"rust-intrinsic\\\" {\\n    fn size_of<T>() -> usize; // ok!\\n}\\n```\\n\")),\n  (\"E0106\",\n   Some(\"This error indicates that a lifetime is missing from a type. If it is an error\\ninside a function signature, the problem may be with failing to adhere to the\\nlifetime elision rules (see below).\\n\\nErroneous code examples:\\n\\n```compile_fail,E0106\\nstruct Foo1 { x: &bool }\\n              // ^ expected lifetime parameter\\nstruct Foo2<\\'a> { x: &\\'a bool } // correct\\n\\nstruct Bar1 { x: Foo2 }\\n              // ^^^^ expected lifetime parameter\\nstruct Bar2<\\'a> { x: Foo2<\\'a> } // correct\\n\\nenum Baz1 { A(u8), B(&bool), }\\n                  // ^ expected lifetime parameter\\nenum Baz2<\\'a> { A(u8), B(&\\'a bool), } // correct\\n\\ntype MyStr1 = &str;\\n           // ^ expected lifetime parameter\\ntype MyStr2<\\'a> = &\\'a str; // correct\\n```\\n\\nLifetime elision is a special, limited kind of inference for lifetimes in\\nfunction signatures which allows you to leave out lifetimes in certain cases.\\nFor more background on lifetime elision see [the book][book-le].\\n\\nThe lifetime elision rules require that any function signature with an elided\\noutput lifetime must either have:\\n\\n - exactly one input lifetime\\n - or, multiple input lifetimes, but the function must also be a method with a\\n   `&self` or `&mut self` receiver\\n\\nIn the first case, the output lifetime is inferred to be the same as the unique\\ninput lifetime. In the second case, the lifetime is instead inferred to be the\\nsame as the lifetime on `&self` or `&mut self`.\\n\\nHere are some examples of elision errors:\\n\\n```compile_fail,E0106\\n// error, no input lifetimes\\nfn foo() -> &str { }\\n\\n// error, `x` and `y` have distinct lifetimes inferred\\nfn bar(x: &str, y: &str) -> &str { }\\n\\n// error, `y`\\'s lifetime is inferred to be distinct from `x`\\'s\\nfn baz<\\'a>(x: &\\'a str, y: &str) -> &str { }\\n```\\n\\n[book-le]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\\n\")),\n  (\"E0107\",\n   Some(\"An incorrect number of generic arguments was provided.\\n\\nErroneous code example:\\n\\n```compile_fail,E0107\\nstruct Foo<T> { x: T }\\n\\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\\n                                  //        expected 1, found 0\\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\\n                                  //        expected 1, found 2\\n\\nfn foo<T, U>(x: T, y: U) {}\\nfn f() {}\\n\\nfn main() {\\n    let x: bool = true;\\n    foo::<bool>(x);                 // error: wrong number of type arguments:\\n                                    //        expected 2, found 1\\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\\n                                    //        expected 2, found 3\\n    f::<\\'static>();                 // error: wrong number of lifetime arguments\\n                                    //        expected 0, found 1\\n}\\n```\\n\\nWhen using/declaring an item with generic arguments, you must provide the exact\\nsame number:\\n\\n```\\nstruct Foo<T> { x: T }\\n\\nstruct Bar<T> { x: Foo<T> }               // ok!\\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\\n\\nfn foo<T, U>(x: T, y: U) {}\\nfn f() {}\\n\\nfn main() {\\n    let x: bool = true;\\n    foo::<bool, u32>(x, 12);              // ok!\\n    f();                                  // ok!\\n}\\n```\\n\")),\n  (\"E0109\",\n   Some(\"You tried to provide a generic argument to a type which doesn\\'t need it.\\n\\nErroneous code example:\\n\\n```compile_fail,E0109\\ntype X = u32<i32>; // error: type arguments are not allowed for this type\\ntype Y = bool<\\'static>; // error: lifetime parameters are not allowed on\\n                        //        this type\\n```\\n\\nCheck that you used the correct argument and that the definition is correct.\\n\\nExample:\\n\\n```\\ntype X = u32; // ok!\\ntype Y = bool; // ok!\\n```\\n\\nNote that generic arguments for enum variant constructors go after the variant,\\nnot after the enum. For example, you would write `Option::None::<u32>`,\\nrather than `Option::<u32>::None`.\\n\")),\n  (\"E0110\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nYou tried to provide a lifetime to a type which doesn\\'t need it.\\nSee `E0109` for more details.\\n\")),\n  (\"E0116\",\n   Some(\"An inherent implementation was defined for a type outside the current crate.\\n\\nErroneous code example:\\n\\n```compile_fail,E0116\\nimpl Vec<u8> { } // error\\n```\\n\\nYou can only define an inherent implementation for a type in the same crate\\nwhere the type was defined. For example, an `impl` block as above is not allowed\\nsince `Vec` is defined in the standard library.\\n\\nTo fix this problem, you can either:\\n\\n - define a trait that has the desired associated functions/types/constants and\\n   implement the trait for the type in question\\n - define a new type wrapping the type and define an implementation on the new\\n   type\\n\\nNote that using the `type` keyword does not work here because `type` only\\nintroduces a type alias:\\n\\n```compile_fail,E0116\\ntype Bytes = Vec<u8>;\\n\\nimpl Bytes { } // error, same as above\\n```\\n\")),\n  (\"E0117\",\n   Some(\"Only traits defined in the current crate can be implemented for arbitrary types.\\n\\nErroneous code example:\\n\\n```compile_fail,E0117\\nimpl Drop for u32 {}\\n```\\n\\nThis error indicates a violation of one of Rust\\'s orphan rules for trait\\nimplementations. The rule prohibits any implementation of a foreign trait (a\\ntrait defined in another crate) where\\n\\n - the type that is implementing the trait is foreign\\n - all of the parameters being passed to the trait (if there are any) are also\\n   foreign.\\n\\nTo avoid this kind of error, ensure that at least one local type is referenced\\nby the `impl`:\\n\\n```\\npub struct Foo; // you define your type in your crate\\n\\nimpl Drop for Foo { // and you can implement the trait on it!\\n    // code of trait implementation here\\n#   fn drop(&mut self) { }\\n}\\n\\nimpl From<Foo> for i32 { // or you use a type from your crate as\\n                         // a type parameter\\n    fn from(i: Foo) -> i32 {\\n        0\\n    }\\n}\\n```\\n\\nAlternatively, define a trait locally and implement that instead:\\n\\n```\\ntrait Bar {\\n    fn get(&self) -> usize;\\n}\\n\\nimpl Bar for u32 {\\n    fn get(&self) -> usize { 0 }\\n}\\n```\\n\\nFor information on the design of the orphan rules, see [RFC 1023].\\n\\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\\n\")),\n  (\"E0118\",\n   Some(\"An inherent implementation was defined for something which isn\\'t a struct,\\nenum, union, or trait object.\\n\\nErroneous code example:\\n\\n```compile_fail,E0118\\nimpl (u8, u8) { // error: no nominal type found for inherent implementation\\n    fn get_state(&self) -> String {\\n        // ...\\n    }\\n}\\n```\\n\\nTo fix this error, please implement a trait on the type or wrap it in a struct.\\nExample:\\n\\n```\\n// we create a trait here\\ntrait LiveLongAndProsper {\\n    fn get_state(&self) -> String;\\n}\\n\\n// and now you can implement it on (u8, u8)\\nimpl LiveLongAndProsper for (u8, u8) {\\n    fn get_state(&self) -> String {\\n        \\\"He\\'s dead, Jim!\\\".to_owned()\\n    }\\n}\\n```\\n\\nAlternatively, you can create a newtype. A newtype is a wrapping tuple-struct.\\nFor example, `NewType` is a newtype over `Foo` in `struct NewType(Foo)`.\\nExample:\\n\\n```\\nstruct TypeWrapper((u8, u8));\\n\\nimpl TypeWrapper {\\n    fn get_state(&self) -> String {\\n        \\\"Fascinating!\\\".to_owned()\\n    }\\n}\\n```\\n\\nInstead of defining an inherent implementation on a reference, you could also\\nmove the reference inside the implementation:\\n\\n```compile_fail,E0118\\nstruct Foo;\\n\\nimpl &Foo { // error: no nominal type found for inherent implementation\\n    fn bar(self, other: Self) {}\\n}\\n```\\n\\nbecomes\\n\\n```\\nstruct Foo;\\n\\nimpl Foo {\\n    fn bar(&self, other: &Self) {}\\n}\\n```\\n\")),\n  (\"E0119\",\n   Some(\"There are conflicting trait implementations for the same type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0119\\ntrait MyTrait {\\n    fn get(&self) -> usize;\\n}\\n\\nimpl<T> MyTrait for T {\\n    fn get(&self) -> usize { 0 }\\n}\\n\\nstruct Foo {\\n    value: usize\\n}\\n\\nimpl MyTrait for Foo { // error: conflicting implementations of trait\\n                       //        `MyTrait` for type `Foo`\\n    fn get(&self) -> usize { self.value }\\n}\\n```\\n\\nWhen looking for the implementation for the trait, the compiler finds\\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\\nthis is an error. So, when you write:\\n\\n```\\ntrait MyTrait {\\n    fn get(&self) -> usize;\\n}\\n\\nimpl<T> MyTrait for T {\\n    fn get(&self) -> usize { 0 }\\n}\\n```\\n\\nThis makes the trait implemented on all types in the scope. So if you\\ntry to implement it on another one after that, the implementations will\\nconflict. Example:\\n\\n```\\ntrait MyTrait {\\n    fn get(&self) -> usize;\\n}\\n\\nimpl<T> MyTrait for T {\\n    fn get(&self) -> usize { 0 }\\n}\\n\\nstruct Foo;\\n\\nfn main() {\\n    let f = Foo;\\n\\n    f.get(); // the trait is implemented so we can use it\\n}\\n```\\n\")),\n  (\"E0120\",\n   Some(\"Drop was implemented on a trait, which is not allowed: only structs and\\nenums can implement Drop.\\n\\nErroneous code example:\\n\\n```compile_fail,E0120\\ntrait MyTrait {}\\n\\nimpl Drop for MyTrait {\\n    fn drop(&mut self) {}\\n}\\n```\\n\\nA workaround for this problem is to wrap the trait up in a struct, and implement\\nDrop on that:\\n\\n```\\ntrait MyTrait {}\\nstruct MyWrapper<T: MyTrait> { foo: T }\\n\\nimpl <T: MyTrait> Drop for MyWrapper<T> {\\n    fn drop(&mut self) {}\\n}\\n\\n```\\n\\nAlternatively, wrapping trait objects requires something:\\n\\n```\\ntrait MyTrait {}\\n\\n//or Box<MyTrait>, if you wanted an owned trait object\\nstruct MyWrapper<\\'a> { foo: &\\'a MyTrait }\\n\\nimpl <\\'a> Drop for MyWrapper<\\'a> {\\n    fn drop(&mut self) {}\\n}\\n```\\n\")),\n  (\"E0121\",\n   Some(\"The type placeholder `_` was used within a type on an item\\'s signature.\\n\\nErroneous code example:\\n\\n```compile_fail,E0121\\nfn foo() -> _ { 5 } // error\\n\\nstatic BAR: _ = \\\"test\\\"; // error\\n```\\n\\nIn those cases, you need to provide the type explicitly:\\n\\n```\\nfn foo() -> i32 { 5 } // ok!\\n\\nstatic BAR: &str = \\\"test\\\"; // ok!\\n```\\n\\nThe type placeholder `_` can be used outside item\\'s signature as follows:\\n\\n```\\nlet x = \\\"a4a\\\".split(\\'4\\')\\n    .collect::<Vec<_>>(); // No need to precise the Vec\\'s generic type.\\n```\\n\")),\n  (\"E0124\",\n   Some(\"A struct was declared with two fields having the same name.\\n\\nErroneous code example:\\n\\n```compile_fail,E0124\\nstruct Foo {\\n    field1: i32,\\n    field1: i32, // error: field is already declared\\n}\\n```\\n\\nPlease verify that the field names have been correctly spelled. Example:\\n\\n```\\nstruct Foo {\\n    field1: i32,\\n    field2: i32, // ok!\\n}\\n```\\n\")),\n  (\"E0128\",\n   Some(\"A type parameter with default value is using forward declared identifier.\\n\\nErroneous code example:\\n\\n```compile_fail,E0128\\nstruct Foo<T = U, U = ()> {\\n    field1: T,\\n    field2: U,\\n}\\n// error: generic parameters with a default cannot use forward declared\\n//        identifiers\\n```\\n\\nType parameter defaults can only use parameters that occur before them. Since\\ntype parameters are evaluated in-order, this issue could be fixed by doing:\\n\\n```\\nstruct Foo<U = (), T = U> {\\n    field1: T,\\n    field2: U,\\n}\\n```\\n\\nPlease also verify that this wasn\\'t because of a name-clash and rename the type\\nparameter if so.\\n\")),\n  (\"E0130\",\n   Some(\"A pattern was declared as an argument in a foreign function declaration.\\n\\nErroneous code example:\\n\\n```compile_fail,E0130\\nextern \\\"C\\\" {\\n    fn foo((a, b): (u32, u32)); // error: patterns aren\\'t allowed in foreign\\n                                //        function declarations\\n}\\n```\\n\\nTo fix this error, replace the pattern argument with a regular one. Example:\\n\\n```\\nstruct SomeStruct {\\n    a: u32,\\n    b: u32,\\n}\\n\\nextern \\\"C\\\" {\\n    fn foo(s: SomeStruct); // ok!\\n}\\n```\\n\\nOr:\\n\\n```\\nextern \\\"C\\\" {\\n    fn foo(a: (u32, u32)); // ok!\\n}\\n```\\n\")),\n  (\"E0131\",\n   Some(\"The `main` function was defined with generic parameters.\\n\\nErroneous code example:\\n\\n```compile_fail,E0131\\nfn main<T>() { // error: main function is not allowed to have generic parameters\\n}\\n```\\n\\nIt is not possible to define the `main` function with generic parameters.\\nIt must not take any arguments.\\n\")),\n  (\"E0132\",\n   Some(\"A function with the `start` attribute was declared with type parameters.\\n\\nErroneous code example:\\n\\n```compile_fail,E0132\\n#![feature(start)]\\n\\n#[start]\\nfn f<T>() {}\\n```\\n\\nIt is not possible to declare type parameters on a function that has the `start`\\nattribute. Such a function must have the following type signature (for more\\ninformation, view [the unstable book][1]):\\n\\n[1]: https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib\\n\\n```\\n# let _:\\nfn(isize, *const *const u8) -> isize;\\n```\\n\\nExample:\\n\\n```\\n#![feature(start)]\\n\\n#[start]\\nfn my_start(argc: isize, argv: *const *const u8) -> isize {\\n    0\\n}\\n```\\n\")),\n  (\"E0133\",\n   Some(\"Unsafe code was used outside of an unsafe function or block.\\n\\nErroneous code example:\\n\\n```compile_fail,E0133\\nunsafe fn f() { return; } // This is the unsafe code\\n\\nfn main() {\\n    f(); // error: call to unsafe function requires unsafe function or block\\n}\\n```\\n\\nUsing unsafe functionality is potentially dangerous and disallowed by safety\\nchecks. Examples:\\n\\n* Dereferencing raw pointers\\n* Calling functions via FFI\\n* Calling functions marked unsafe\\n\\nThese safety checks can be relaxed for a section of the code by wrapping the\\nunsafe instructions with an `unsafe` block. For instance:\\n\\n```\\nunsafe fn f() { return; }\\n\\nfn main() {\\n    unsafe { f(); } // ok!\\n}\\n```\\n\\nSee the [unsafe section][unsafe-section] of the Book for more details.\\n\\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\\n\")),\n  (\"E0136\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nMore than one `main` function was found.\\n\\nErroneous code example:\\n\\n```compile_fail\\nfn main() {\\n    // ...\\n}\\n\\n// ...\\n\\nfn main() { // error!\\n    // ...\\n}\\n```\\n\\nA binary can only have one entry point, and by default that entry point is the\\n`main()` function. If there are multiple instances of this function, please\\nrename one of them.\\n\")),\n  (\"E0137\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nMore than one function was declared with the `#[main]` attribute.\\n\\nErroneous code example:\\n\\n```compile_fail\\n#![feature(main)]\\n\\n#[main]\\nfn foo() {}\\n\\n#[main]\\nfn f() {} // error: multiple functions with a `#[main]` attribute\\n```\\n\\nThis error indicates that the compiler found multiple functions with the\\n`#[main]` attribute. This is an error because there must be a unique entry\\npoint into a Rust program. Example:\\n\\n```compile_fail\\n#![feature(main)]\\n\\n#[main]\\nfn f() {} // ok!\\n```\\n\")),\n  (\"E0138\",\n   Some(\"More than one function was declared with the `#[start]` attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0138\\n#![feature(start)]\\n\\n#[start]\\nfn foo(argc: isize, argv: *const *const u8) -> isize {}\\n\\n#[start]\\nfn f(argc: isize, argv: *const *const u8) -> isize {}\\n// error: multiple \\'start\\' functions\\n```\\n\\nThis error indicates that the compiler found multiple functions with the\\n`#[start]` attribute. This is an error because there must be a unique entry\\npoint into a Rust program. Example:\\n\\n```\\n#![feature(start)]\\n\\n#[start]\\nfn foo(argc: isize, argv: *const *const u8) -> isize { 0 } // ok!\\n```\\n\")),\n  (\"E0139\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThere are various restrictions on transmuting between types in Rust; for example\\ntypes being transmuted must have the same size. To apply all these restrictions,\\nthe compiler must know the exact types that may be transmuted. When type\\nparameters are involved, this cannot always be done.\\n\\nSo, for example, the following is not allowed:\\n\\n```\\nuse std::mem::transmute;\\n\\nstruct Foo<T>(Vec<T>);\\n\\nfn foo<T>(x: Vec<T>) {\\n    // we are transmuting between Vec<T> and Foo<F> here\\n    let y: Foo<T> = unsafe { transmute(x) };\\n    // do something with y\\n}\\n```\\n\\nIn this specific case there\\'s a good chance that the transmute is harmless (but\\nthis is not guaranteed by Rust). However, when alignment and enum optimizations\\ncome into the picture, it\\'s quite likely that the sizes may or may not match\\nwith different type parameter substitutions. It\\'s not possible to check this for\\n_all_ possible types, so `transmute()` simply only accepts types without any\\nunsubstituted type parameters.\\n\\nIf you need this, there\\'s a good chance you\\'re doing something wrong. Keep in\\nmind that Rust doesn\\'t guarantee much about the layout of different structs\\n(even two structs with identical declarations may have different layouts). If\\nthere is a solution that avoids the transmute entirely, try it instead.\\n\\nIf it\\'s possible, hand-monomorphize the code by writing the function for each\\npossible type substitution. It\\'s possible to use traits to do this cleanly,\\nfor example:\\n\\n```\\nuse std::mem::transmute;\\n\\nstruct Foo<T>(Vec<T>);\\n\\ntrait MyTransmutableType: Sized {\\n    fn transmute(_: Vec<Self>) -> Foo<Self>;\\n}\\n\\nimpl MyTransmutableType for u8 {\\n    fn transmute(x: Vec<u8>) -> Foo<u8> {\\n        unsafe { transmute(x) }\\n    }\\n}\\n\\nimpl MyTransmutableType for String {\\n    fn transmute(x: Vec<String>) -> Foo<String> {\\n        unsafe { transmute(x) }\\n    }\\n}\\n\\n// ... more impls for the types you intend to transmute\\n\\nfn foo<T: MyTransmutableType>(x: Vec<T>) {\\n    let y: Foo<T> = <T as MyTransmutableType>::transmute(x);\\n    // do something with y\\n}\\n```\\n\\nEach impl will be checked for a size match in the transmute as usual, and since\\nthere are no unbound type parameters involved, this should compile unless there\\nis a size mismatch in one of the impls.\\n\\nIt is also possible to manually transmute:\\n\\n```\\n# use std::ptr;\\n# let v = Some(\\\"value\\\");\\n# type SomeType = &\\'static [u8];\\nunsafe {\\n    ptr::read(&v as *const _ as *const SomeType) // `v` transmuted to `SomeType`\\n}\\n# ;\\n```\\n\\nNote that this does not move `v` (unlike `transmute`), and may need a\\ncall to `mem::forget(v)` in case you want to avoid destructors being called.\\n\")),\n  (\"E0152\",\n   Some(\"A lang item was redefined.\\n\\nErroneous code example:\\n\\n```compile_fail,E0152\\n#![feature(lang_items)]\\n\\n#[lang = \\\"owned_box\\\"]\\nstruct Foo<T>(T); // error: duplicate lang item found: `owned_box`\\n```\\n\\nLang items are already implemented in the standard library. Unless you are\\nwriting a free-standing application (e.g., a kernel), you do not need to provide\\nthem yourself.\\n\\nYou can build a free-standing crate by adding `#![no_std]` to the crate\\nattributes:\\n\\n```ignore (only-for-syntax-highlight)\\n#![no_std]\\n```\\n\\nSee also the [unstable book][1].\\n\\n[1]: https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib\\n\")),\n  (\"E0154\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nImports (`use` statements) are not allowed after non-item statements, such as\\nvariable declarations and expression statements.\\n\\nHere is an example that demonstrates the error:\\n\\n```\\nfn f() {\\n    // Variable declaration before import\\n    let x = 0;\\n    use std::io::Read;\\n    // ...\\n}\\n```\\n\\nThe solution is to declare the imports at the top of the block, function, or\\nfile.\\n\\nHere is the previous example again, with the correct order:\\n\\n```\\nfn f() {\\n    use std::io::Read;\\n    let x = 0;\\n    // ...\\n}\\n```\\n\\nSee the [Declaration Statements][declaration-statements] section of the\\nreference for more information about what constitutes an item declaration\\nand what does not.\\n\\n[declaration-statements]: https://doc.rust-lang.org/reference/statements.html#declaration-statements\\n\")),\n  (\"E0158\",\n   Some(\"An associated const has been referenced in a pattern.\\n\\nErroneous code example:\\n\\n```compile_fail,E0158\\nenum EFoo { A, B, C, D }\\n\\ntrait Foo {\\n    const X: EFoo;\\n}\\n\\nfn test<A: Foo>(arg: EFoo) {\\n    match arg {\\n        A::X => { // error!\\n            println!(\\\"A::X\\\");\\n        }\\n    }\\n}\\n```\\n\\n`const` and `static` mean different things. A `const` is a compile-time\\nconstant, an alias for a literal value. This property means you can match it\\ndirectly within a pattern.\\n\\nThe `static` keyword, on the other hand, guarantees a fixed location in memory.\\nThis does not always mean that the value is constant. For example, a global\\nmutex can be declared `static` as well.\\n\\nIf you want to match against a `static`, consider using a guard instead:\\n\\n```\\nstatic FORTY_TWO: i32 = 42;\\n\\nmatch Some(42) {\\n    Some(x) if x == FORTY_TWO => {}\\n    _ => {}\\n}\\n```\\n\")),\n  (\"E0161\",\n   Some(\"A value was moved whose size was not known at compile time.\\n\\nErroneous code example:\\n\\n```compile_fail,E0161\\n#![feature(box_syntax)]\\ntrait Bar {\\n    fn f(self);\\n}\\n\\nimpl Bar for i32 {\\n    fn f(self) {}\\n}\\n\\nfn main() {\\n    let b: Box<dyn Bar> = box (0 as i32);\\n    b.f();\\n    // error: cannot move a value of type dyn Bar: the size of dyn Bar cannot\\n    //        be statically determined\\n}\\n```\\n\\nIn Rust, you can only move a value when its size is known at compile time.\\n\\nTo work around this restriction, consider \\\"hiding\\\" the value behind a reference:\\neither `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\\nit around as usual. Example:\\n\\n```\\n#![feature(box_syntax)]\\n\\ntrait Bar {\\n    fn f(&self);\\n}\\n\\nimpl Bar for i32 {\\n    fn f(&self) {}\\n}\\n\\nfn main() {\\n    let b: Box<dyn Bar> = box (0 as i32);\\n    b.f();\\n    // ok!\\n}\\n```\\n\")),\n  (\"E0162\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nAn `if let` pattern attempts to match the pattern, and enters the body if the\\nmatch was successful. If the match is irrefutable (when it cannot fail to\\nmatch), use a regular `let`-binding instead. For instance:\\n\\n```\\nstruct Irrefutable(i32);\\nlet irr = Irrefutable(0);\\n\\n// This fails to compile because the match is irrefutable.\\nif let Irrefutable(x) = irr {\\n    // This body will always be executed.\\n    // ...\\n}\\n```\\n\\nTry this instead:\\n\\n```\\nstruct Irrefutable(i32);\\nlet irr = Irrefutable(0);\\n\\nlet Irrefutable(x) = irr;\\nprintln!(\\\"{}\\\", x);\\n```\\n\")),\n  (\"E0164\",\n   Some(\"Something which is neither a tuple struct nor a tuple variant was used as a\\npattern.\\n\\nErroneous code example:\\n\\n```compile_fail,E0164\\nenum A {\\n    B,\\n    C,\\n}\\n\\nimpl A {\\n    fn new() {}\\n}\\n\\nfn bar(foo: A) {\\n    match foo {\\n        A::new() => (), // error!\\n        _ => {}\\n    }\\n}\\n```\\n\\nThis error means that an attempt was made to match something which is neither a\\ntuple struct nor a tuple variant. Only these two elements are allowed as a\\npattern:\\n\\n```\\nenum A {\\n    B,\\n    C,\\n}\\n\\nimpl A {\\n    fn new() {}\\n}\\n\\nfn bar(foo: A) {\\n    match foo {\\n        A::B => (), // ok!\\n        _ => {}\\n    }\\n}\\n```\\n\")),\n  (\"E0165\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nA `while let` pattern attempts to match the pattern, and enters the body if the\\nmatch was successful. If the match is irrefutable (when it cannot fail to\\nmatch), use a regular `let`-binding inside a `loop` instead. For instance:\\n\\n```no_run\\nstruct Irrefutable(i32);\\nlet irr = Irrefutable(0);\\n\\n// This fails to compile because the match is irrefutable.\\nwhile let Irrefutable(x) = irr {\\n    // ...\\n}\\n```\\n\\nTry this instead:\\n\\n```no_run\\nstruct Irrefutable(i32);\\nlet irr = Irrefutable(0);\\n\\nloop {\\n    let Irrefutable(x) = irr;\\n    // ...\\n}\\n```\\n\")),\n  (\"E0170\",\n   Some(\"A pattern binding is using the same name as one of the variants of a type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0170\\n# #![deny(warnings)]\\nenum Method {\\n    GET,\\n    POST,\\n}\\n\\nfn is_empty(s: Method) -> bool {\\n    match s {\\n        GET => true,\\n        _ => false\\n    }\\n}\\n\\nfn main() {}\\n```\\n\\nEnum variants are qualified by default. For example, given this type:\\n\\n```\\nenum Method {\\n    GET,\\n    POST,\\n}\\n```\\n\\nYou would match it using:\\n\\n```\\nenum Method {\\n    GET,\\n    POST,\\n}\\n\\nlet m = Method::GET;\\n\\nmatch m {\\n    Method::GET => {},\\n    Method::POST => {},\\n}\\n```\\n\\nIf you don\\'t qualify the names, the code will bind new variables named \\\"GET\\\" and\\n\\\"POST\\\" instead. This behavior is likely not what you want, so `rustc` warns when\\nthat happens.\\n\\nQualified names are good practice, and most code works well with them. But if\\nyou prefer them unqualified, you can import the variants into scope:\\n\\n```\\nuse Method::*;\\nenum Method { GET, POST }\\n# fn main() {}\\n```\\n\\nIf you want others to be able to import variants from your module directly, use\\n`pub use`:\\n\\n```\\npub use Method::*;\\npub enum Method { GET, POST }\\n# fn main() {}\\n```\\n\")),\n  (\"E0178\",\n   Some(\"The `+` type operator was used in an ambiguous context.\\n\\nErroneous code example:\\n\\n```compile_fail,E0178\\ntrait Foo {}\\n\\nstruct Bar<\\'a> {\\n    x: &\\'a Foo + \\'a,     // error!\\n    y: &\\'a mut Foo + \\'a, // error!\\n    z: fn() -> Foo + \\'a, // error!\\n}\\n```\\n\\nIn types, the `+` type operator has low precedence, so it is often necessary\\nto use parentheses:\\n\\n```\\ntrait Foo {}\\n\\nstruct Bar<\\'a> {\\n    x: &\\'a (Foo + \\'a),     // ok!\\n    y: &\\'a mut (Foo + \\'a), // ok!\\n    z: fn() -> (Foo + \\'a), // ok!\\n}\\n```\\n\\nMore details can be found in [RFC 438].\\n\\n[RFC 438]: https://github.com/rust-lang/rfcs/pull/438\\n\")),\n  (\"E0183\",\n   Some(\"Manual implemetation of a `Fn*` trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0183\\nstruct MyClosure {\\n    foo: i32\\n}\\n\\nimpl FnOnce<()> for MyClosure {  // error\\n    type Output = ();\\n    extern \\\"rust-call\\\" fn call_once(self, args: ()) -> Self::Output {\\n        println!(\\\"{}\\\", self.foo);\\n    }\\n}\\n```\\n\\nManually implementing `Fn`, `FnMut` or `FnOnce` is unstable\\nand requires `#![feature(fn_traits, unboxed_closures)]`.\\n\\n```\\n#![feature(fn_traits, unboxed_closures)]\\n\\nstruct MyClosure {\\n    foo: i32\\n}\\n\\nimpl FnOnce<()> for MyClosure {  // ok!\\n    type Output = ();\\n    extern \\\"rust-call\\\" fn call_once(self, args: ()) -> Self::Output {\\n        println!(\\\"{}\\\", self.foo);\\n    }\\n}\\n```\\n\\nThe argumements must be a tuple representing the argument list.\\nFor more info, see the [tracking issue][iss29625]:\\n\\n[iss29625]: https://github.com/rust-lang/rust/issues/29625\\n\")),\n  (\"E0184\",\n   Some(\"The `Copy` trait was implemented on a type with a `Drop` implementation.\\n\\nErroneous code example:\\n\\n```compile_fail,E0184\\n#[derive(Copy)]\\nstruct Foo; // error!\\n\\nimpl Drop for Foo {\\n    fn drop(&mut self) {\\n    }\\n}\\n```\\n\\nExplicitly implementing both `Drop` and `Copy` trait on a type is currently\\ndisallowed. This feature can make some sense in theory, but the current\\nimplementation is incorrect and can lead to memory unsafety (see\\n[issue #20126][iss20126]), so it has been disabled for now.\\n\\n[iss20126]: https://github.com/rust-lang/rust/issues/20126\\n\")),\n  (\"E0185\",\n   Some(\"An associated function for a trait was defined to be static, but an\\nimplementation of the trait declared the same function to be a method (i.e., to\\ntake a `self` parameter).\\n\\nErroneous code example:\\n\\n```compile_fail,E0185\\ntrait Foo {\\n    fn foo();\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    // error, method `foo` has a `&self` declaration in the impl, but not in\\n    // the trait\\n    fn foo(&self) {}\\n}\\n```\\n\\nWhen a type implements a trait\\'s associated function, it has to use the same\\nsignature. So in this case, since `Foo::foo` does not take any argument and\\ndoes not return anything, its implementation on `Bar` should be the same:\\n\\n```\\ntrait Foo {\\n    fn foo();\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    fn foo() {} // ok!\\n}\\n```\\n\")),\n  (\"E0186\",\n   Some(\"An associated function for a trait was defined to be a method (i.e., to take a\\n`self` parameter), but an implementation of the trait declared the same function\\nto be static.\\n\\nErroneous code example:\\n\\n```compile_fail,E0186\\ntrait Foo {\\n    fn foo(&self);\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    // error, method `foo` has a `&self` declaration in the trait, but not in\\n    // the impl\\n    fn foo() {}\\n}\\n```\\n\\nWhen a type implements a trait\\'s associated function, it has to use the same\\nsignature. So in this case, since `Foo::foo` takes `self` as argument and\\ndoes not return anything, its implementation on `Bar` should be the same:\\n\\n```\\ntrait Foo {\\n    fn foo(&self);\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    fn foo(&self) {} // ok!\\n}\\n```\\n\")),\n  (\"E0191\",\n   Some(\"An associated type wasn\\'t specified for a trait object.\\n\\nErroneous code example:\\n\\n```compile_fail,E0191\\ntrait Trait {\\n    type Bar;\\n}\\n\\ntype Foo = Trait; // error: the value of the associated type `Bar` (from\\n                  //        the trait `Trait`) must be specified\\n```\\n\\nTrait objects need to have all associated types specified. Please verify that\\nall associated types of the trait were specified and the correct trait was used.\\nExample:\\n\\n```\\ntrait Trait {\\n    type Bar;\\n}\\n\\ntype Foo = Trait<Bar=i32>; // ok!\\n```\\n\")),\n  (\"E0193\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\n`where` clauses must use generic type parameters: it does not make sense to use\\nthem otherwise. An example causing this error:\\n\\n```\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n#[derive(Copy,Clone)]\\nstruct Wrapper<T> {\\n    Wrapped: T\\n}\\n\\nimpl Foo for Wrapper<u32> where Wrapper<u32>: Clone {\\n    fn bar(&self) { }\\n}\\n```\\n\\nThis use of a `where` clause is strange - a more common usage would look\\nsomething like the following:\\n\\n```\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n#[derive(Copy,Clone)]\\nstruct Wrapper<T> {\\n    Wrapped: T\\n}\\nimpl <T> Foo for Wrapper<T> where Wrapper<T>: Clone {\\n    fn bar(&self) { }\\n}\\n```\\n\\nHere, we\\'re saying that the implementation exists on Wrapper only when the\\nwrapped type `T` implements `Clone`. The `where` clause is important because\\nsome types will not implement `Clone`, and thus will not get this method.\\n\\nIn our erroneous example, however, we\\'re referencing a single concrete type.\\nSince we know for certain that `Wrapper<u32>` implements `Clone`, there\\'s no\\nreason to also specify it in a `where` clause.\\n\")),\n  (\"E0195\",\n   Some(\"The lifetime parameters of the method do not match the trait declaration.\\n\\nErroneous code example:\\n\\n```compile_fail,E0195\\ntrait Trait {\\n    fn bar<\\'a,\\'b:\\'a>(x: &\\'a str, y: &\\'b str);\\n}\\n\\nstruct Foo;\\n\\nimpl Trait for Foo {\\n    fn bar<\\'a,\\'b>(x: &\\'a str, y: &\\'b str) {\\n    // error: lifetime parameters or bounds on method `bar`\\n    // do not match the trait declaration\\n    }\\n}\\n```\\n\\nThe lifetime constraint `\\'b` for `bar()` implementation does not match the\\ntrait declaration. Ensure lifetime declarations match exactly in both trait\\ndeclaration and implementation. Example:\\n\\n```\\ntrait Trait {\\n    fn t<\\'a,\\'b:\\'a>(x: &\\'a str, y: &\\'b str);\\n}\\n\\nstruct Foo;\\n\\nimpl Trait for Foo {\\n    fn t<\\'a,\\'b:\\'a>(x: &\\'a str, y: &\\'b str) { // ok!\\n    }\\n}\\n```\\n\")),\n  (\"E0197\",\n   Some(\"An inherent implementation was marked unsafe.\\n\\nErroneous code example:\\n\\n```compile_fail,E0197\\nstruct Foo;\\n\\nunsafe impl Foo { } // error!\\n```\\n\\nInherent implementations (one that do not implement a trait but provide\\nmethods associated with a type) are always safe because they are not\\nimplementing an unsafe trait. Removing the `unsafe` keyword from the inherent\\nimplementation will resolve this error.\\n\\n```\\nstruct Foo;\\n\\nimpl Foo { } // ok!\\n```\\n\")),\n  (\"E0198\",\n   Some(\"A negative implementation was marked as unsafe.\\n\\nErroneous code example:\\n\\n```compile_fail,E0198\\nstruct Foo;\\n\\nunsafe impl !Clone for Foo { } // error!\\n```\\n\\nA negative implementation is one that excludes a type from implementing a\\nparticular trait. Not being able to use a trait is always a safe operation,\\nso negative implementations are always safe and never need to be marked as\\nunsafe.\\n\\nThis will compile:\\n\\n```ignore (ignore auto_trait future compatibility warning)\\n#![feature(auto_traits)]\\n\\nstruct Foo;\\n\\nauto trait Enterprise {}\\n\\nimpl !Enterprise for Foo { }\\n```\\n\\nPlease note that negative impls are only allowed for auto traits.\\n\")),\n  (\"E0199\",\n   Some(\"A trait implementation was marked as unsafe while the trait is safe.\\n\\nErroneous code example:\\n\\n```compile_fail,E0199\\nstruct Foo;\\n\\ntrait Bar { }\\n\\nunsafe impl Bar for Foo { } // error!\\n```\\n\\nSafe traits should not have unsafe implementations, therefore marking an\\nimplementation for a safe trait unsafe will cause a compiler error. Removing\\nthe unsafe marker on the trait noted in the error will resolve this problem:\\n\\n```\\nstruct Foo;\\n\\ntrait Bar { }\\n\\nimpl Bar for Foo { } // ok!\\n```\\n\")),\n  (\"E0200\",\n   Some(\"An unsafe trait was implemented without an unsafe implementation.\\n\\nErroneous code example:\\n\\n```compile_fail,E0200\\nstruct Foo;\\n\\nunsafe trait Bar { }\\n\\nimpl Bar for Foo { } // error!\\n```\\n\\nUnsafe traits must have unsafe implementations. This error occurs when an\\nimplementation for an unsafe trait isn\\'t marked as unsafe. This may be resolved\\nby marking the unsafe implementation as unsafe.\\n\\n```\\nstruct Foo;\\n\\nunsafe trait Bar { }\\n\\nunsafe impl Bar for Foo { } // ok!\\n```\\n\")),\n  (\"E0201\",\n   Some(\"Two associated items (like methods, associated types, associated functions,\\netc.) were defined with the same identifier.\\n\\nErroneous code example:\\n\\n```compile_fail,E0201\\nstruct Foo(u8);\\n\\nimpl Foo {\\n    fn bar(&self) -> bool { self.0 > 5 }\\n    fn bar() {} // error: duplicate associated function\\n}\\n\\ntrait Baz {\\n    type Quux;\\n    fn baz(&self) -> bool;\\n}\\n\\nimpl Baz for Foo {\\n    type Quux = u32;\\n\\n    fn baz(&self) -> bool { true }\\n\\n    // error: duplicate method\\n    fn baz(&self) -> bool { self.0 > 5 }\\n\\n    // error: duplicate associated type\\n    type Quux = u32;\\n}\\n```\\n\\nNote, however, that items with the same name are allowed for inherent `impl`\\nblocks that don\\'t overlap:\\n\\n```\\nstruct Foo<T>(T);\\n\\nimpl Foo<u8> {\\n    fn bar(&self) -> bool { self.0 > 5 }\\n}\\n\\nimpl Foo<bool> {\\n    fn bar(&self) -> bool { self.0 }\\n}\\n```\\n\")),\n  (\"E0203\",\n   Some(\"Having multiple relaxed default bounds is unsupported.\\n\\nErroneous code example:\\n\\n```compile_fail,E0203\\nstruct Bad<T: ?Sized + ?Send>{\\n    inner: T\\n}\\n```\\n\\nHere the type `T` cannot have a relaxed bound for multiple default traits\\n(`Sized` and `Send`). This can be fixed by only using one relaxed bound.\\n\\n```\\nstruct Good<T: ?Sized>{\\n    inner: T\\n}\\n```\\n\")),\n  (\"E0204\",\n   Some(\"The `Copy` trait was implemented on a type which contains a field that doesn\\'t\\nimplement the `Copy` trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0204\\nstruct Foo {\\n    foo: Vec<u32>,\\n}\\n\\nimpl Copy for Foo { } // error!\\n```\\n\\nThe `Copy` trait is implemented by default only on primitive types. If your\\ntype only contains primitive types, you\\'ll be able to implement `Copy` on it.\\nOtherwise, it won\\'t be possible.\\n\\nHere\\'s another example that will fail:\\n\\n```compile_fail,E0204\\n#[derive(Copy)] // error!\\nstruct Foo<\\'a> {\\n    ty: &\\'a mut bool,\\n}\\n```\\n\\nThis fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\\ndiffers from the behavior for `&T`, which is always `Copy`).\\n\")),\n  (\"E0205\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nAn attempt to implement the `Copy` trait for an enum failed because one of the\\nvariants does not implement `Copy`. To fix this, you must implement `Copy` for\\nthe mentioned variant. Note that this may not be possible, as in the example of\\n\\n```compile_fail,E0204\\nenum Foo {\\n    Bar(Vec<u32>),\\n    Baz,\\n}\\n\\nimpl Copy for Foo { }\\n```\\n\\nThis fails because `Vec<T>` does not implement `Copy` for any `T`.\\n\\nHere\\'s another example that will fail:\\n\\n```compile_fail,E0204\\n#[derive(Copy)]\\nenum Foo<\\'a> {\\n    Bar(&\\'a mut bool),\\n    Baz,\\n}\\n```\\n\\nThis fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\\ndiffers from the behavior for `&T`, which is always `Copy`).\\n\")),\n  (\"E0206\",\n   Some(\"The `Copy` trait was implemented on a type which is neither a struct nor an\\nenum.\\n\\nErroneous code example:\\n\\n```compile_fail,E0206\\ntype Foo = [u8; 256];\\nimpl Copy for Foo { } // error!\\n\\n#[derive(Copy, Clone)]\\nstruct Bar;\\n\\nimpl Copy for &\\'static mut Bar { } // error!\\n```\\n\\nYou can only implement `Copy` for a struct or an enum. Both of the previous\\nexamples will fail, because neither `[u8; 256]` nor `&\\'static mut Bar`\\n(mutable reference to `Bar`) is a struct or enum.\\n\")),\n  (\"E0207\",\n   Some(\"A type parameter that is specified for `impl` is not constrained.\\n\\nErroneous code example:\\n\\n```compile_fail,E0207\\nstruct Foo;\\n\\nimpl<T: Default> Foo {\\n    // error: the type parameter `T` is not constrained by the impl trait, self\\n    // type, or predicates [E0207]\\n    fn get(&self) -> T {\\n        <T as Default>::default()\\n    }\\n}\\n```\\n\\nAny type parameter of an `impl` must meet at least one of\\nthe following criteria:\\n\\n - it appears in the _implementing type_ of the impl, e.g. `impl<T> Foo<T>`\\n - for a trait impl, it appears in the _implemented trait_, e.g.\\n   `impl<T> SomeTrait<T> for Foo`\\n - it is bound as an associated type, e.g. `impl<T, U> SomeTrait for T\\n   where T: AnotherTrait<AssocType=U>`\\n\\n### Error example 1\\n\\nSuppose we have a struct `Foo` and we would like to define some methods for it.\\nThe previous code example has a definition which leads to a compiler error:\\n\\nThe problem is that the parameter `T` does not appear in the implementing type\\n(`Foo`) of the impl. In this case, we can fix the error by moving the type\\nparameter from the `impl` to the method `get`:\\n\\n\\n```\\nstruct Foo;\\n\\n// Move the type parameter from the impl to the method\\nimpl Foo {\\n    fn get<T: Default>(&self) -> T {\\n        <T as Default>::default()\\n    }\\n}\\n```\\n\\n### Error example 2\\n\\nAs another example, suppose we have a `Maker` trait and want to establish a\\ntype `FooMaker` that makes `Foo`s:\\n\\n```compile_fail,E0207\\ntrait Maker {\\n    type Item;\\n    fn make(&mut self) -> Self::Item;\\n}\\n\\nstruct Foo<T> {\\n    foo: T\\n}\\n\\nstruct FooMaker;\\n\\nimpl<T: Default> Maker for FooMaker {\\n// error: the type parameter `T` is not constrained by the impl trait, self\\n// type, or predicates [E0207]\\n    type Item = Foo<T>;\\n\\n    fn make(&mut self) -> Foo<T> {\\n        Foo { foo: <T as Default>::default() }\\n    }\\n}\\n```\\n\\nThis fails to compile because `T` does not appear in the trait or in the\\nimplementing type.\\n\\nOne way to work around this is to introduce a phantom type parameter into\\n`FooMaker`, like so:\\n\\n```\\nuse std::marker::PhantomData;\\n\\ntrait Maker {\\n    type Item;\\n    fn make(&mut self) -> Self::Item;\\n}\\n\\nstruct Foo<T> {\\n    foo: T\\n}\\n\\n// Add a type parameter to `FooMaker`\\nstruct FooMaker<T> {\\n    phantom: PhantomData<T>,\\n}\\n\\nimpl<T: Default> Maker for FooMaker<T> {\\n    type Item = Foo<T>;\\n\\n    fn make(&mut self) -> Foo<T> {\\n        Foo {\\n            foo: <T as Default>::default(),\\n        }\\n    }\\n}\\n```\\n\\nAnother way is to do away with the associated type in `Maker` and use an input\\ntype parameter instead:\\n\\n```\\n// Use a type parameter instead of an associated type here\\ntrait Maker<Item> {\\n    fn make(&mut self) -> Item;\\n}\\n\\nstruct Foo<T> {\\n    foo: T\\n}\\n\\nstruct FooMaker;\\n\\nimpl<T: Default> Maker<Foo<T>> for FooMaker {\\n    fn make(&mut self) -> Foo<T> {\\n        Foo { foo: <T as Default>::default() }\\n    }\\n}\\n```\\n\\n### Additional information\\n\\nFor more information, please see [RFC 447].\\n\\n[RFC 447]: https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md\\n\")),\n  (\"E0210\",\n   Some(\"This error indicates a violation of one of Rust\\'s orphan rules for trait\\nimplementations. The rule concerns the use of type parameters in an\\nimplementation of a foreign trait (a trait defined in another crate), and\\nstates that type parameters must be \\\"covered\\\" by a local type.\\n\\nWhen implementing a foreign trait for a foreign type,\\nthe trait must have one or more type parameters.\\nA type local to your crate must appear before any use of any type parameters.\\n\\nTo understand what this means, it is perhaps easier to consider a few examples.\\n\\nIf `ForeignTrait` is a trait defined in some external crate `foo`, then the\\nfollowing trait `impl` is an error:\\n\\n```compile_fail,E0210\\n# #[cfg(for_demonstration_only)]\\nextern crate foo;\\n# #[cfg(for_demonstration_only)]\\nuse foo::ForeignTrait;\\n# use std::panic::UnwindSafe as ForeignTrait;\\n\\nimpl<T> ForeignTrait for T { } // error\\n# fn main() {}\\n```\\n\\nTo work around this, it can be covered with a local type, `MyType`:\\n\\n```\\n# use std::panic::UnwindSafe as ForeignTrait;\\nstruct MyType<T>(T);\\nimpl<T> ForeignTrait for MyType<T> { } // Ok\\n```\\n\\nPlease note that a type alias is not sufficient.\\n\\nFor another example of an error, suppose there\\'s another trait defined in `foo`\\nnamed `ForeignTrait2` that takes two type parameters. Then this `impl` results\\nin the same rule violation:\\n\\n```ignore (cannot-doctest-multicrate-project)\\nstruct MyType2;\\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\\n```\\n\\nThe reason for this is that there are two appearances of type parameter `T` in\\nthe `impl` header, both as parameters for `ForeignTrait2`. The first appearance\\nis uncovered, and so runs afoul of the orphan rule.\\n\\nConsider one more example:\\n\\n```ignore (cannot-doctest-multicrate-project)\\nimpl<T> ForeignTrait2<MyType<T>, T> for MyType2 { } // Ok\\n```\\n\\nThis only differs from the previous `impl` in that the parameters `T` and\\n`MyType<T>` for `ForeignTrait2` have been swapped. This example does *not*\\nviolate the orphan rule; it is permitted.\\n\\nTo see why that last example was allowed, you need to understand the general\\nrule. Unfortunately this rule is a bit tricky to state. Consider an `impl`:\\n\\n```ignore (only-for-syntax-highlight)\\nimpl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\\n```\\n\\nwhere `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\\nare types. One of the types `T0, ..., Tn` must be a local type (this is another\\norphan rule, see the explanation for E0117).\\n\\nBoth of the following must be true:\\n1. At least one of the types `T0..=Tn` must be a local type.\\nLet `Ti` be the first such type.\\n2. No uncovered type parameters `P1..=Pm` may appear in `T0..Ti`\\n(excluding `Ti`).\\n\\nFor information on the design of the orphan rules,\\nsee [RFC 2451] and [RFC 1023].\\n\\nFor information on the design of the orphan rules, see [RFC 1023].\\n\\n[RFC 2451]: https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html\\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\\n\")),\n  (\"E0211\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nYou used a function or type which doesn\\'t fit the requirements for where it was\\nused. Erroneous code examples:\\n\\n```compile_fail\\n#![feature(intrinsics)]\\n\\nextern \\\"rust-intrinsic\\\" {\\n    fn size_of<T>(); // error: intrinsic has wrong type\\n}\\n\\n// or:\\n\\nfn main() -> i32 { 0 }\\n// error: main function expects type: `fn() {main}`: expected (), found i32\\n\\n// or:\\n\\nlet x = 1u8;\\nmatch x {\\n    0u8..=3i8 => (),\\n    // error: mismatched types in range: expected u8, found i8\\n    _ => ()\\n}\\n\\n// or:\\n\\nuse std::rc::Rc;\\nstruct Foo;\\n\\nimpl Foo {\\n    fn x(self: Rc<Foo>) {}\\n    // error: mismatched self type: expected `Foo`: expected struct\\n    //        `Foo`, found struct `alloc::rc::Rc`\\n}\\n```\\n\\nFor the first code example, please check the function definition. Example:\\n\\n```\\n#![feature(intrinsics)]\\n\\nextern \\\"rust-intrinsic\\\" {\\n    fn size_of<T>() -> usize; // ok!\\n}\\n```\\n\\nThe second case example is a bit particular: the main function must always\\nhave this definition:\\n\\n```compile_fail\\nfn main();\\n```\\n\\nThey never take parameters and never return types.\\n\\nFor the third example, when you match, all patterns must have the same type\\nas the type you\\'re matching on. Example:\\n\\n```\\nlet x = 1u8;\\n\\nmatch x {\\n    0u8..=3u8 => (), // ok!\\n    _ => ()\\n}\\n```\\n\\nAnd finally, for the last example, only `Box<Self>`, `&Self`, `Self`,\\nor `&mut Self` work as explicit self parameters. Example:\\n\\n```\\nstruct Foo;\\n\\nimpl Foo {\\n    fn x(self: Box<Foo>) {} // ok!\\n}\\n```\\n\")),\n  (\"E0212\",\n   Some(\"Cannot use the associated type of\\na trait with uninferred generic parameters.\\n\\nErroneous code example:\\n\\n```compile_fail,E0212\\npub trait Foo<T> {\\n    type A;\\n\\n    fn get(&self, t: T) -> Self::A;\\n}\\n\\nfn foo2<I : for<\\'x> Foo<&\\'x isize>>(\\n    field: I::A) {} // error!\\n```\\n\\nIn this example, we have to instantiate `\\'x`, and\\nwe don\\'t know what lifetime to instantiate it with.\\nTo fix this, spell out the precise lifetimes involved.\\nExample:\\n\\n```\\npub trait Foo<T> {\\n    type A;\\n\\n    fn get(&self, t: T) -> Self::A;\\n}\\n\\nfn foo3<I : for<\\'x> Foo<&\\'x isize>>(\\n    x: <I as Foo<&isize>>::A) {} // ok!\\n\\n\\nfn foo4<\\'a, I : for<\\'x> Foo<&\\'x isize>>(\\n    x: <I as Foo<&\\'a isize>>::A) {} // ok!\\n```\\n\")),\n  (\"E0214\",\n   Some(\"A generic type was described using parentheses rather than angle brackets.\\n\\nErroneous code example:\\n\\n```compile_fail,E0214\\nlet v: Vec(&str) = vec![\\\"foo\\\"];\\n```\\n\\nThis is not currently supported: `v` should be defined as `Vec<&str>`.\\nParentheses are currently only used with generic types when defining parameters\\nfor `Fn`-family traits.\\n\\nThe previous code example fixed:\\n\\n```\\nlet v: Vec<&str> = vec![\\\"foo\\\"];\\n```\\n\")),\n  (\"E0220\",\n   Some(\"The associated type used was not defined in the trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0220\\ntrait T1 {\\n    type Bar;\\n}\\n\\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\\n\\n// or:\\n\\ntrait T2 {\\n    type Bar;\\n\\n    // error: Baz is used but not declared\\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\\n}\\n```\\n\\nMake sure that you have defined the associated type in the trait body.\\nAlso, verify that you used the right trait or you didn\\'t misspell the\\nassociated type name. Example:\\n\\n```\\ntrait T1 {\\n    type Bar;\\n}\\n\\ntype Foo = T1<Bar=i32>; // ok!\\n\\n// or:\\n\\ntrait T2 {\\n    type Bar;\\n    type Baz; // we declare `Baz` in our trait.\\n\\n    // and now we can use it here:\\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\\n}\\n```\\n\")),\n  (\"E0221\",\n   Some(\"An attempt was made to retrieve an associated type, but the type was ambiguous.\\n\\nErroneous code example:\\n\\n```compile_fail,E0221\\ntrait T1 {}\\ntrait T2 {}\\n\\ntrait Foo {\\n    type A: T1;\\n}\\n\\ntrait Bar : Foo {\\n    type A: T2;\\n    fn do_something() {\\n        let _: Self::A;\\n    }\\n}\\n```\\n\\nIn this example, `Foo` defines an associated type `A`. `Bar` inherits that type\\nfrom `Foo`, and defines another associated type of the same name. As a result,\\nwhen we attempt to use `Self::A`, it\\'s ambiguous whether we mean the `A` defined\\nby `Foo` or the one defined by `Bar`.\\n\\nThere are two options to work around this issue. The first is simply to rename\\none of the types. Alternatively, one can specify the intended type using the\\nfollowing syntax:\\n\\n```\\ntrait T1 {}\\ntrait T2 {}\\n\\ntrait Foo {\\n    type A: T1;\\n}\\n\\ntrait Bar : Foo {\\n    type A: T2;\\n    fn do_something() {\\n        let _: <Self as Bar>::A;\\n    }\\n}\\n```\\n\")),\n  (\"E0222\",\n   Some(\"An attempt was made to constrain an associated type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0222\\npub trait Vehicle {\\n    type Color;\\n}\\n\\npub trait Box {\\n    type Color;\\n}\\n\\npub trait BoxCar : Box + Vehicle {}\\n\\nfn dent_object<COLOR>(c: dyn BoxCar<Color=COLOR>) {} // Invalid constraint\\n```\\n\\nIn this example, `BoxCar` has two supertraits: `Vehicle` and `Box`. Both of\\nthese traits define an associated type `Color`. `BoxCar` inherits two types\\nwith that name from both supertraits. Because of this, we need to use the\\nfully qualified path syntax to refer to the appropriate `Color` associated\\ntype, either `<BoxCar as Vehicle>::Color` or `<BoxCar as Box>::Color`, but this\\nsyntax is not allowed to be used in a function signature.\\n\\nIn order to encode this kind of constraint, a `where` clause and a new type\\nparameter are needed:\\n\\n```\\npub trait Vehicle {\\n    type Color;\\n}\\n\\npub trait Box {\\n    type Color;\\n}\\n\\npub trait BoxCar : Box + Vehicle {}\\n\\n// Introduce a new `CAR` type parameter\\nfn foo<CAR, COLOR>(\\n    c: CAR,\\n) where\\n    // Bind the type parameter `CAR` to the trait `BoxCar`\\n    CAR: BoxCar,\\n    // Further restrict `<BoxCar as Vehicle>::Color` to be the same as the\\n    // type parameter `COLOR`\\n    CAR: Vehicle<Color = COLOR>,\\n    // We can also simultaneously restrict the other trait\\'s associated type\\n    CAR: Box<Color = COLOR>\\n{}\\n```\\n\")),\n  (\"E0223\",\n   Some(\"An attempt was made to retrieve an associated type, but the type was ambiguous.\\n\\nErroneous code example:\\n\\n```compile_fail,E0223\\ntrait MyTrait {type X; }\\n\\nfn main() {\\n    let foo: MyTrait::X;\\n}\\n```\\n\\nThe problem here is that we\\'re attempting to take the type of X from MyTrait.\\nUnfortunately, the type of X is not defined, because it\\'s only made concrete in\\nimplementations of the trait. A working version of this code might look like:\\n\\n```\\ntrait MyTrait {type X; }\\nstruct MyStruct;\\n\\nimpl MyTrait for MyStruct {\\n    type X = u32;\\n}\\n\\nfn main() {\\n    let foo: <MyStruct as MyTrait>::X;\\n}\\n```\\n\\nThis syntax specifies that we want the X type from MyTrait, as made concrete in\\nMyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\\nmight implement two different traits with identically-named associated types.\\nThis syntax allows disambiguation between the two.\\n\")),\n  (\"E0224\",\n   Some(\"A trait object was declared with no traits.\\n\\nErroneous code example:\\n\\n```compile_fail,E0224\\ntype Foo = dyn \\'static +;\\n```\\n\\nRust does not currently support this.\\n\\nTo solve, ensure that the trait object has at least one trait:\\n\\n```\\ntype Foo = dyn \\'static + Copy;\\n```\\n\")),\n  (\"E0225\",\n   Some(\"Multiple types were used as bounds for a closure or trait object.\\n\\nErroneous code example:\\n\\n```compile_fail,E0225\\nfn main() {\\n    let _: Box<dyn std::io::Read + std::io::Write>;\\n}\\n```\\n\\nRust does not currently support this.\\n\\nAuto traits such as Send and Sync are an exception to this rule:\\nIt\\'s possible to have bounds of one non-builtin trait, plus any number of\\nauto traits. For example, the following compiles correctly:\\n\\n```\\nfn main() {\\n    let _: Box<dyn std::io::Read + Send + Sync>;\\n}\\n```\\n\")),\n  (\"E0226\",\n   Some(\"More than one explicit lifetime bound was used on a trait object.\\n\\nExample of erroneous code:\\n\\n```compile_fail,E0226\\ntrait Foo {}\\n\\ntype T<\\'a, \\'b> = dyn Foo + \\'a + \\'b; // error: Trait object `arg` has two\\n                                    //        lifetime bound, \\'a and \\'b.\\n```\\n\\nHere `T` is a trait object with two explicit lifetime bounds, \\'a and \\'b.\\n\\nOnly a single explicit lifetime bound is permitted on trait objects.\\nTo fix this error, consider removing one of the lifetime bounds:\\n\\n```\\ntrait Foo {}\\n\\ntype T<\\'a> = dyn Foo + \\'a;\\n```\\n\")),\n  (\"E0228\",\n   Some(\"The lifetime bound for this object type cannot be deduced from context and must\\nbe specified.\\n\\nErroneous code example:\\n\\n```compile_fail,E0228\\ntrait Trait { }\\n\\nstruct TwoBounds<\\'a, \\'b, T: Sized + \\'a + \\'b> {\\n    x: &\\'a i32,\\n    y: &\\'b i32,\\n    z: T,\\n}\\n\\ntype Foo<\\'a, \\'b> = TwoBounds<\\'a, \\'b, dyn Trait>;\\n```\\n\\nWhen a trait object is used as a type argument of a generic type, Rust will try\\nto infer its lifetime if unspecified. However, this isn\\'t possible when the\\ncontaining type has more than one lifetime bound.\\n\\nThe above example can be resolved by either reducing the number of lifetime\\nbounds to one or by making the trait object lifetime explicit, like so:\\n\\n```\\ntrait Trait { }\\n\\nstruct TwoBounds<\\'a, \\'b, T: Sized + \\'a + \\'b> {\\n    x: &\\'a i32,\\n    y: &\\'b i32,\\n    z: T,\\n}\\n\\ntype Foo<\\'a, \\'b> = TwoBounds<\\'a, \\'b, dyn Trait + \\'b>;\\n```\\n\\nFor more information, see [RFC 599] and its amendment [RFC 1156].\\n\\n[RFC 599]: https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md\\n[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md\\n\")),\n  (\"E0229\",\n   Some(\"An associated type binding was done outside of the type parameter declaration\\nand `where` clause.\\n\\nErroneous code example:\\n\\n```compile_fail,E0229\\npub trait Foo {\\n    type A;\\n    fn boo(&self) -> <Self as Foo>::A;\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for isize {\\n    type A = usize;\\n    fn boo(&self) -> usize { 42 }\\n}\\n\\nfn baz<I>(x: &<I as Foo<A=Bar>>::A) {}\\n// error: associated type bindings are not allowed here\\n```\\n\\nTo solve this error, please move the type bindings in the type parameter\\ndeclaration:\\n\\n```\\n# struct Bar;\\n# trait Foo { type A; }\\nfn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!\\n```\\n\\nOr in the `where` clause:\\n\\n```\\n# struct Bar;\\n# trait Foo { type A; }\\nfn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\\n```\\n\")),\n  (\"E0230\",\n   Some(\"The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\\nmessage for when a particular trait isn\\'t implemented on a type placed in a\\nposition that needs that trait. For example, when the following code is\\ncompiled:\\n\\n```compile_fail,E0230\\n#![feature(rustc_attrs)]\\n\\n#[rustc_on_unimplemented = \\\"error on `{Self}` with params `<{A},{B}>`\\\"] // error\\ntrait BadAnnotation<A> {}\\n```\\n\\nThere will be an error about `bool` not implementing `Index<u8>`, followed by a\\nnote saying \\\"the type `bool` cannot be indexed by `u8`\\\".\\n\\nAs you can see, you can specify type parameters in curly braces for\\nsubstitution with the actual types (using the regular format string syntax) in\\na given situation. Furthermore, `{Self}` will substitute to the type (in this\\ncase, `bool`) that we tried to use.\\n\\nThis error appears when the curly braces contain an identifier which doesn\\'t\\nmatch with any of the type parameters or the string `Self`. This might happen\\nif you misspelled a type parameter, or if you intended to use literal curly\\nbraces. If it is the latter, escape the curly braces with a second curly brace\\nof the same type; e.g., a literal `{` is `{{`.\\n\")),\n  (\"E0231\",\n   Some(\"The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\\nmessage for when a particular trait isn\\'t implemented on a type placed in a\\nposition that needs that trait. For example, when the following code is\\ncompiled:\\n\\n```compile_fail,E0231\\n#![feature(rustc_attrs)]\\n\\n#[rustc_on_unimplemented = \\\"error on `{Self}` with params `<{A},{}>`\\\"] // error!\\ntrait BadAnnotation<A> {}\\n```\\n\\nthere will be an error about `bool` not implementing `Index<u8>`, followed by a\\nnote saying \\\"the type `bool` cannot be indexed by `u8`\\\".\\n\\nAs you can see, you can specify type parameters in curly braces for\\nsubstitution with the actual types (using the regular format string syntax) in\\na given situation. Furthermore, `{Self}` will substitute to the type (in this\\ncase, `bool`) that we tried to use.\\n\\nThis error appears when the curly braces do not contain an identifier. Please\\nadd one of the same name as a type parameter. If you intended to use literal\\nbraces, use `{{` and `}}` to escape them.\\n\")),\n  (\"E0232\",\n   Some(\"The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\\nmessage for when a particular trait isn\\'t implemented on a type placed in a\\nposition that needs that trait. For example, when the following code is\\ncompiled:\\n\\n```compile_fail,E0232\\n#![feature(rustc_attrs)]\\n\\n#[rustc_on_unimplemented(lorem=\\\"\\\")] // error!\\ntrait BadAnnotation {}\\n```\\n\\nthere will be an error about `bool` not implementing `Index<u8>`, followed by a\\nnote saying \\\"the type `bool` cannot be indexed by `u8`\\\".\\n\\nFor this to work, some note must be specified. An empty attribute will not do\\nanything, please remove the attribute or add some helpful note for users of the\\ntrait.\\n\")),\n  (\"E0243\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThis error indicates that not enough type parameters were found in a type or\\ntrait.\\n\\nFor example, the `Foo` struct below is defined to be generic in `T`, but the\\ntype parameter is missing in the definition of `Bar`:\\n\\n```compile_fail,E0107\\nstruct Foo<T> { x: T }\\n\\nstruct Bar { x: Foo }\\n```\\n\")),\n  (\"E0244\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThis error indicates that too many type parameters were found in a type or\\ntrait.\\n\\nFor example, the `Foo` struct below has no type parameters, but is supplied\\nwith two in the definition of `Bar`:\\n\\n```compile_fail,E0107\\nstruct Foo { x: bool }\\n\\nstruct Bar<S, T> { x: Foo<S, T> }\\n```\\n\")),\n  (\"E0251\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nTwo items of the same name cannot be imported without rebinding one of the\\nitems under a new local name.\\n\\nAn example of this error:\\n\\n```\\nuse foo::baz;\\nuse bar::*; // error, do `use foo::baz as quux` instead on the previous line\\n\\nfn main() {}\\n\\nmod foo {\\n    pub struct baz;\\n}\\n\\nmod bar {\\n    pub mod baz {}\\n}\\n```\\n\")),\n  (\"E0252\",\n   Some(\"Two items of the same name cannot be imported without rebinding one of the\\nitems under a new local name.\\n\\nErroneous code example:\\n\\n```compile_fail,E0252\\nuse foo::baz;\\nuse bar::baz; // error, do `use bar::baz as quux` instead\\n\\nfn main() {}\\n\\nmod foo {\\n    pub struct baz;\\n}\\n\\nmod bar {\\n    pub mod baz {}\\n}\\n```\\n\\nYou can use aliases in order to fix this error. Example:\\n\\n```\\nuse foo::baz as foo_baz;\\nuse bar::baz; // ok!\\n\\nfn main() {}\\n\\nmod foo {\\n    pub struct baz;\\n}\\n\\nmod bar {\\n    pub mod baz {}\\n}\\n```\\n\\nOr you can reference the item with its parent:\\n\\n```\\nuse bar::baz;\\n\\nfn main() {\\n    let x = foo::baz; // ok!\\n}\\n\\nmod foo {\\n    pub struct baz;\\n}\\n\\nmod bar {\\n    pub mod baz {}\\n}\\n```\\n\")),\n  (\"E0253\",\n   Some(\"Attempt was made to import an unimportable value. This can happen when trying\\nto import a method from a trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0253\\nmod foo {\\n    pub trait MyTrait {\\n        fn do_something();\\n    }\\n}\\n\\nuse foo::MyTrait::do_something;\\n// error: `do_something` is not directly importable\\n\\nfn main() {}\\n```\\n\\nIt\\'s invalid to directly import methods belonging to a trait or concrete type.\\n\")),\n  (\"E0254\",\n   Some(\"Attempt was made to import an item whereas an extern crate with this name has\\nalready been imported.\\n\\nErroneous code example:\\n\\n```compile_fail,E0254\\nextern crate core;\\n\\nmod foo {\\n    pub trait core {\\n        fn do_something();\\n    }\\n}\\n\\nuse foo::core;  // error: an extern crate named `core` has already\\n                //        been imported in this module\\n\\nfn main() {}\\n```\\n\\nTo fix this issue, you have to rename at least one of the two imports.\\nExample:\\n\\n```\\nextern crate core as libcore; // ok!\\n\\nmod foo {\\n    pub trait core {\\n        fn do_something();\\n    }\\n}\\n\\nuse foo::core;\\n\\nfn main() {}\\n```\\n\")),\n  (\"E0255\",\n   Some(\"You can\\'t import a value whose name is the same as another value defined in the\\nmodule.\\n\\nErroneous code example:\\n\\n```compile_fail,E0255\\nuse bar::foo; // error: an item named `foo` is already in scope\\n\\nfn foo() {}\\n\\nmod bar {\\n     pub fn foo() {}\\n}\\n\\nfn main() {}\\n```\\n\\nYou can use aliases in order to fix this error. Example:\\n\\n```\\nuse bar::foo as bar_foo; // ok!\\n\\nfn foo() {}\\n\\nmod bar {\\n     pub fn foo() {}\\n}\\n\\nfn main() {}\\n```\\n\\nOr you can reference the item with its parent:\\n\\n```\\nfn foo() {}\\n\\nmod bar {\\n     pub fn foo() {}\\n}\\n\\nfn main() {\\n    bar::foo(); // we get the item by referring to its parent\\n}\\n```\\n\")),\n  (\"E0256\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nYou can\\'t import a type or module when the name of the item being imported is\\nthe same as another type or submodule defined in the module.\\n\\nAn example of this error:\\n\\n```compile_fail\\nuse foo::Bar; // error\\n\\ntype Bar = u32;\\n\\nmod foo {\\n    pub mod Bar { }\\n}\\n\\nfn main() {}\\n```\\n\")),\n  (\"E0259\",\n   Some(\"The name chosen for an external crate conflicts with another external crate\\nthat has been imported into the current module.\\n\\nErroneous code example:\\n\\n```compile_fail,E0259\\nextern crate core;\\nextern crate std as core;\\n\\nfn main() {}\\n```\\n\\nThe solution is to choose a different name that doesn\\'t conflict with any\\nexternal crate imported into the current module.\\n\\nCorrect example:\\n\\n```\\nextern crate core;\\nextern crate std as other_name;\\n\\nfn main() {}\\n```\\n\")),\n  (\"E0260\",\n   Some(\"The name for an item declaration conflicts with an external crate\\'s name.\\n\\nErroneous code example:\\n\\n```compile_fail,E0260\\nextern crate core;\\n\\nstruct core;\\n\\nfn main() {}\\n```\\n\\nThere are two possible solutions:\\n\\nSolution #1: Rename the item.\\n\\n```\\nextern crate core;\\n\\nstruct xyz;\\n```\\n\\nSolution #2: Import the crate with a different name.\\n\\n```\\nextern crate core as xyz;\\n\\nstruct abc;\\n```\\n\\nSee the [Declaration Statements][declaration-statements] section of the\\nreference for more information about what constitutes an item declaration\\nand what does not.\\n\\n[declaration-statements]: https://doc.rust-lang.org/reference/statements.html#declaration-statements\\n\")),\n  (\"E0261\",\n   Some(\"An undeclared lifetime was used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0261\\n// error, use of undeclared lifetime name `\\'a`\\nfn foo(x: &\\'a str) { }\\n\\nstruct Foo {\\n    // error, use of undeclared lifetime name `\\'a`\\n    x: &\\'a str,\\n}\\n```\\n\\nThese can be fixed by declaring lifetime parameters:\\n\\n```\\nstruct Foo<\\'a> {\\n    x: &\\'a str,\\n}\\n\\nfn foo<\\'a>(x: &\\'a str) {}\\n```\\n\\nImpl blocks declare lifetime parameters separately. You need to add lifetime\\nparameters to an impl block if you\\'re implementing a type that has a lifetime\\nparameter of its own.\\nFor example:\\n\\n```compile_fail,E0261\\nstruct Foo<\\'a> {\\n    x: &\\'a str,\\n}\\n\\n// error,  use of undeclared lifetime name `\\'a`\\nimpl Foo<\\'a> {\\n    fn foo<\\'a>(x: &\\'a str) {}\\n}\\n```\\n\\nThis is fixed by declaring the impl block like this:\\n\\n```\\nstruct Foo<\\'a> {\\n    x: &\\'a str,\\n}\\n\\n// correct\\nimpl<\\'a> Foo<\\'a> {\\n    fn foo(x: &\\'a str) {}\\n}\\n```\\n\")),\n  (\"E0262\",\n   Some(\"An invalid name was used for a lifetime parameter.\\n\\nErroneous code example:\\n\\n```compile_fail,E0262\\n// error, invalid lifetime parameter name `\\'static`\\nfn foo<\\'static>(x: &\\'static str) { }\\n```\\n\\nDeclaring certain lifetime names in parameters is disallowed. For example,\\nbecause the `\\'static` lifetime is a special built-in lifetime name denoting\\nthe lifetime of the entire program, this is an error:\\n\")),\n  (\"E0263\",\n   Some(\"A lifetime was declared more than once in the same scope.\\n\\nErroneous code example:\\n\\n```compile_fail,E0263\\nfn foo<\\'a, \\'b, \\'a>(x: &\\'a str, y: &\\'b str, z: &\\'a str) { // error!\\n}\\n```\\n\\nTwo lifetimes cannot have the same name. To fix this example, change\\nthe second `\\'a` lifetime into something else (`\\'c` for example):\\n\\n```\\nfn foo<\\'a, \\'b, \\'c>(x: &\\'a str, y: &\\'b str, z: &\\'c str) { // ok!\\n}\\n```\\n\")),\n  (\"E0264\",\n   Some(\"An unknown external lang item was used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0264\\n#![feature(lang_items)]\\n\\nextern \\\"C\\\" {\\n    #[lang = \\\"cake\\\"] // error: unknown external lang item: `cake`\\n    fn cake();\\n}\\n```\\n\\nA list of available external lang items is available in\\n`src/librustc_middle/middle/weak_lang_items.rs`. Example:\\n\\n```\\n#![feature(lang_items)]\\n\\nextern \\\"C\\\" {\\n    #[lang = \\\"panic_impl\\\"] // ok!\\n    fn cake();\\n}\\n```\\n\")),\n  (\"E0267\",\n   Some(\"A loop keyword (`break` or `continue`) was used inside a closure but outside of\\nany loop.\\n\\nErroneous code example:\\n\\n```compile_fail,E0267\\nlet w = || { break; }; // error: `break` inside of a closure\\n```\\n\\n`break` and `continue` keywords can be used as normal inside closures as long as\\nthey are also contained within a loop. To halt the execution of a closure you\\nshould instead use a return statement. Example:\\n\\n```\\nlet w = || {\\n    for _ in 0..10 {\\n        break;\\n    }\\n};\\n\\nw();\\n```\\n\")),\n  (\"E0268\",\n   Some(\"A loop keyword (`break` or `continue`) was used outside of a loop.\\n\\nErroneous code example:\\n\\n```compile_fail,E0268\\nfn some_func() {\\n    break; // error: `break` outside of a loop\\n}\\n```\\n\\nWithout a loop to break out of or continue in, no sensible action can be taken.\\nPlease verify that you are using `break` and `continue` only in loops. Example:\\n\\n```\\nfn some_func() {\\n    for _ in 0..10 {\\n        break; // ok!\\n    }\\n}\\n```\\n\")),\n  (\"E0271\",\n   Some(\"A type mismatched an associated type of a trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0271\\ntrait Trait { type AssociatedType; }\\n\\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\\n//                        |            |\\n//         This says `foo` can         |\\n//           only be used with         |\\n//              some type that         |\\n//         implements `Trait`.         |\\n//                                     |\\n//                             This says not only must\\n//                             `T` be an impl of `Trait`\\n//                             but also that the impl\\n//                             must assign the type `u32`\\n//                             to the associated type.\\n    println!(\\\"in foo\\\");\\n}\\n\\nimpl Trait for i8 { type AssociatedType = &\\'static str; }\\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n//      |                             |\\n// `i8` does have                     |\\n// implementation                     |\\n// of `Trait`...                      |\\n//                     ... but it is an implementation\\n//                     that assigns `&\\'static str` to\\n//                     the associated type.\\n\\nfoo(3_i8);\\n// Here, we invoke `foo` with an `i8`, which does not satisfy\\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\\n// therefore the type-checker complains with this error code.\\n```\\n\\nThe issue can be resolved by changing the associated type:\\n1) in the `foo` implementation:\\n```\\ntrait Trait { type AssociatedType; }\\n\\nfn foo<T>(t: T) where T: Trait<AssociatedType = &\\'static str> {\\n    println!(\\\"in foo\\\");\\n}\\n\\nimpl Trait for i8 { type AssociatedType = &\\'static str; }\\n\\nfoo(3_i8);\\n```\\n\\n2) in the `Trait` implementation for `i8`:\\n```\\ntrait Trait { type AssociatedType; }\\n\\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\\n    println!(\\\"in foo\\\");\\n}\\n\\nimpl Trait for i8 { type AssociatedType = u32; }\\n\\nfoo(3_i8);\\n```\\n\")),\n  (\"E0275\",\n   Some(\"An evaluation of a trait requirement overflowed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0275\\ntrait Foo {}\\n\\nstruct Bar<T>(T);\\n\\nimpl<T> Foo for T where Bar<T>: Foo {}\\n```\\n\\nThis error occurs when there was a recursive trait requirement that overflowed\\nbefore it could be evaluated. This often means that there is an unbounded\\nrecursion in resolving some type bounds.\\n\\nTo determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\\nto do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To\\ndetermine this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is\\nclearly a recursive requirement that can\\'t be resolved directly.\\n\\nConsider changing your trait bounds so that they\\'re less self-referential.\\n\")),\n  (\"E0276\",\n   Some(\"A trait implementation has stricter requirements than the trait definition.\\n\\nErroneous code example:\\n\\n```compile_fail,E0276\\ntrait Foo {\\n    fn foo<T>(x: T);\\n}\\n\\nimpl Foo for bool {\\n    fn foo<T>(x: T) where T: Copy {}\\n}\\n```\\n\\nHere, all types implementing `Foo` must have a method `foo<T>(x: T)` which can\\ntake any type `T`. However, in the `impl` for `bool`, we have added an extra\\nbound that `T` is `Copy`, which isn\\'t compatible with the original trait.\\n\\nConsider removing the bound from the method or adding the bound to the original\\nmethod definition in the trait.\\n\")),\n  (\"E0277\",\n   Some(\"You tried to use a type which doesn\\'t implement some trait in a place which\\nexpected that trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0277\\n// here we declare the Foo trait with a bar method\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n// we now declare a function which takes an object implementing the Foo trait\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar();\\n}\\n\\nfn main() {\\n    // we now call the method with the i32 type, which doesn\\'t implement\\n    // the Foo trait\\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\\n}\\n```\\n\\nIn order to fix this error, verify that the type you\\'re using does implement\\nthe trait. Example:\\n\\n```\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n// we implement the trait on the i32 type\\nimpl Foo for i32 {\\n    fn bar(&self) {}\\n}\\n\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar(); // we can now use this method since i32 implements the\\n               // Foo trait\\n}\\n\\nfn main() {\\n    some_func(5i32); // ok!\\n}\\n```\\n\\nOr in a generic context, an erroneous code example would look like:\\n\\n```compile_fail,E0277\\nfn some_func<T>(foo: T) {\\n    println!(\\\"{:?}\\\", foo); // error: the trait `core::fmt::Debug` is not\\n                           //        implemented for the type `T`\\n}\\n\\nfn main() {\\n    // We now call the method with the i32 type,\\n    // which *does* implement the Debug trait.\\n    some_func(5i32);\\n}\\n```\\n\\nNote that the error here is in the definition of the generic function. Although\\nwe only call it with a parameter that does implement `Debug`, the compiler\\nstill rejects the function. It must work with all possible input types. In\\norder to make this example compile, we need to restrict the generic type we\\'re\\naccepting:\\n\\n```\\nuse std::fmt;\\n\\n// Restrict the input type to types that implement Debug.\\nfn some_func<T: fmt::Debug>(foo: T) {\\n    println!(\\\"{:?}\\\", foo);\\n}\\n\\nfn main() {\\n    // Calling the method is still fine, as i32 implements Debug.\\n    some_func(5i32);\\n\\n    // This would fail to compile now:\\n    // struct WithoutDebug;\\n    // some_func(WithoutDebug);\\n}\\n```\\n\\nRust only looks at the signature of the called function, as such it must\\nalready specify all requirements that will be used for every type parameter.\\n\")),\n  (\"E0281\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nYou tried to supply a type which doesn\\'t implement some trait in a location\\nwhich expected that trait. This error typically occurs when working with\\n`Fn`-based types. Erroneous code example:\\n\\n```compile_fail\\nfn foo<F: Fn(usize)>(x: F) { }\\n\\nfn main() {\\n    // type mismatch: ... implements the trait `core::ops::Fn<(String,)>`,\\n    // but the trait `core::ops::Fn<(usize,)>` is required\\n    // [E0281]\\n    foo(|y: String| { });\\n}\\n```\\n\\nThe issue in this case is that `foo` is defined as accepting a `Fn` with one\\nargument of type `String`, but the closure we attempted to pass to it requires\\none arguments of type `usize`.\\n\")),\n  (\"E0282\",\n   Some(\"The compiler could not infer a type and asked for a type annotation.\\n\\nErroneous code example:\\n\\n```compile_fail,E0282\\nlet x = \\\"hello\\\".chars().rev().collect();\\n```\\n\\nThis error indicates that type inference did not result in one unique possible\\ntype, and extra information is required. In most cases this can be provided\\nby adding a type annotation. Sometimes you need to specify a generic type\\nparameter manually.\\n\\nA common example is the `collect` method on `Iterator`. It has a generic type\\nparameter with a `FromIterator` bound, which for a `char` iterator is\\nimplemented by `Vec` and `String` among others. Consider the following snippet\\nthat reverses the characters of a string:\\n\\nIn the first code example, the compiler cannot infer what the type of `x` should\\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\\nto use, you can use a type annotation on `x`:\\n\\n```\\nlet x: Vec<char> = \\\"hello\\\".chars().rev().collect();\\n```\\n\\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\\nthe compiler can infer the rest:\\n\\n```\\nlet x: Vec<_> = \\\"hello\\\".chars().rev().collect();\\n```\\n\\nAnother way to provide the compiler with enough information, is to specify the\\ngeneric type parameter:\\n\\n```\\nlet x = \\\"hello\\\".chars().rev().collect::<Vec<char>>();\\n```\\n\\nAgain, you need not specify the full type if the compiler can infer it:\\n\\n```\\nlet x = \\\"hello\\\".chars().rev().collect::<Vec<_>>();\\n```\\n\\nApart from a method or function with a generic type parameter, this error can\\noccur when a type parameter of a struct or trait cannot be inferred. In that\\ncase it is not always possible to use a type annotation, because all candidates\\nhave the same return type. For instance:\\n\\n```compile_fail,E0282\\nstruct Foo<T> {\\n    num: T,\\n}\\n\\nimpl<T> Foo<T> {\\n    fn bar() -> i32 {\\n        0\\n    }\\n\\n    fn baz() {\\n        let number = Foo::bar();\\n    }\\n}\\n```\\n\\nThis will fail because the compiler does not know which instance of `Foo` to\\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\\n\")),\n  (\"E0283\",\n   Some(\"An implementation cannot be chosen unambiguously because of lack of information.\\n\\nErroneous code example:\\n\\n```compile_fail,E0283\\ntrait Generator {\\n    fn create() -> u32;\\n}\\n\\nstruct Impl;\\n\\nimpl Generator for Impl {\\n    fn create() -> u32 { 1 }\\n}\\n\\nstruct AnotherImpl;\\n\\nimpl Generator for AnotherImpl {\\n    fn create() -> u32 { 2 }\\n}\\n\\nfn main() {\\n    let cont: u32 = Generator::create();\\n    // error, impossible to choose one of Generator trait implementation\\n    // Should it be Impl or AnotherImpl, maybe something else?\\n}\\n```\\n\\nThis error can be solved by adding type annotations that provide the missing\\ninformation to the compiler. In this case, the solution is to use a concrete\\ntype:\\n\\n```\\ntrait Generator {\\n    fn create() -> u32;\\n}\\n\\nstruct AnotherImpl;\\n\\nimpl Generator for AnotherImpl {\\n    fn create() -> u32 { 2 }\\n}\\n\\nfn main() {\\n    let gen1 = AnotherImpl::create();\\n\\n    // if there are multiple methods with same name (different traits)\\n    let gen2 = <AnotherImpl as Generator>::create();\\n}\\n```\\n\")),\n  (\"E0284\",\n   Some(\"This error occurs when the compiler is unable to unambiguously infer the\\nreturn type of a function or method which is generic on return type, such\\nas the `collect` method for `Iterator`s.\\n\\nFor example:\\n\\n```compile_fail,E0284\\nfn main() {\\n    let n: u32 = 1;\\n    let mut d: u64 = 2;\\n    d = d + n.into();\\n}\\n```\\n\\nHere we have an addition of `d` and `n.into()`. Hence, `n.into()` can return\\nany type `T` where `u64: Add<T>`. On the other hand, the `into` method can\\nreturn any type where `u32: Into<T>`.\\n\\nThe author of this code probably wants `into()` to return a `u64`, but the\\ncompiler can\\'t be sure that there isn\\'t another type `T` where both\\n`u32: Into<T>` and `u64: Add<T>`.\\n\\nTo resolve this error, use a concrete type for the intermediate expression:\\n\\n```\\nfn main() {\\n    let n: u32 = 1;\\n    let mut d: u64 = 2;\\n    let m: u64 = n.into();\\n    d = d + m;\\n}\\n```\\n\\nNote that the type of `v` can now be inferred from the type of `temp`.\\n\")),\n  (\"E0297\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nPatterns used to bind names must be irrefutable. That is, they must guarantee\\nthat a name will be extracted in all cases. Instead of pattern matching the\\nloop variable, consider using a `match` or `if let` inside the loop body. For\\ninstance:\\n\\n```compile_fail,E0005\\nlet xs : Vec<Option<i32>> = vec![Some(1), None];\\n\\n// This fails because `None` is not covered.\\nfor Some(x) in xs {\\n    // ...\\n}\\n```\\n\\nMatch inside the loop instead:\\n\\n```\\nlet xs : Vec<Option<i32>> = vec![Some(1), None];\\n\\nfor item in xs {\\n    match item {\\n        Some(x) => {},\\n        None => {},\\n    }\\n}\\n```\\n\\nOr use `if let`:\\n\\n```\\nlet xs : Vec<Option<i32>> = vec![Some(1), None];\\n\\nfor item in xs {\\n    if let Some(x) = item {\\n        // ...\\n    }\\n}\\n```\\n\")),\n  (\"E0301\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nMutable borrows are not allowed in pattern guards, because matching cannot have\\nside effects. Side effects could alter the matched object or the environment\\non which the match depends in such a way, that the match would not be\\nexhaustive. For instance, the following would not match any arm if mutable\\nborrows were allowed:\\n\\n```compile_fail,E0596\\nmatch Some(()) {\\n    None => { },\\n    option if option.take().is_none() => {\\n        /* impossible, option is `Some` */\\n    },\\n    Some(_) => { } // When the previous match failed, the option became `None`.\\n}\\n```\\n\")),\n  (\"E0302\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nAssignments are not allowed in pattern guards, because matching cannot have\\nside effects. Side effects could alter the matched object or the environment\\non which the match depends in such a way, that the match would not be\\nexhaustive. For instance, the following would not match any arm if assignments\\nwere allowed:\\n\\n```compile_fail,E0594\\nmatch Some(()) {\\n    None => { },\\n    option if { option = None; false } => { },\\n    Some(_) => { } // When the previous match failed, the option became `None`.\\n}\\n```\\n\")),\n  (\"E0303\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nSub-bindings, e.g. `ref x @ Some(ref y)` are now allowed under\\n`#![feature(bindings_after_at)]` and checked to make sure that\\nmemory safety is upheld.\\n\\n--------------\\n\\nIn certain cases it is possible for sub-bindings to violate memory safety.\\nUpdates to the borrow checker in a future version of Rust may remove this\\nrestriction, but for now patterns must be rewritten without sub-bindings.\\n\\nBefore:\\n\\n```compile_fail\\nmatch Some(\\\"hi\\\".to_string()) {\\n    ref op_string_ref @ Some(s) => {},\\n    None => {},\\n}\\n```\\n\\nAfter:\\n\\n```\\nmatch Some(\\\"hi\\\".to_string()) {\\n    Some(ref s) => {\\n        let op_string_ref = &Some(s);\\n        // ...\\n    },\\n    None => {},\\n}\\n```\\n\\nThe `op_string_ref` binding has type `&Option<&String>` in both cases.\\n\\nSee also [Issue 14587][issue-14587].\\n\\n[issue-14587]: https://github.com/rust-lang/rust/issues/14587\\n\")),\n  (\"E0307\",\n   Some(\"The `self` parameter in a method has an invalid \\\"receiver type\\\".\\n\\nErroneous code example:\\n\\n```compile_fail,E0307\\nstruct Foo;\\nstruct Bar;\\n\\ntrait Trait {\\n    fn foo(&self);\\n}\\n\\nimpl Trait for Foo {\\n    fn foo(self: &Bar) {}\\n}\\n```\\n\\nMethods take a special first parameter, of which there are three variants:\\n`self`, `&self`, and `&mut self`. These are syntactic sugar for\\n`self: Self`, `self: &Self`, and `self: &mut Self` respectively.\\n\\n```\\n# struct Foo;\\ntrait Trait {\\n    fn foo(&self);\\n//         ^^^^^ `self` here is a reference to the receiver object\\n}\\n\\nimpl Trait for Foo {\\n    fn foo(&self) {}\\n//         ^^^^^ the receiver type is `&Foo`\\n}\\n```\\n\\nThe type `Self` acts as an alias to the type of the current trait\\nimplementer, or \\\"receiver type\\\". Besides the already mentioned `Self`,\\n`&Self` and `&mut Self` valid receiver types, the following are also valid:\\n`self: Box<Self>`, `self: Rc<Self>`, `self: Arc<Self>`, and `self: Pin<P>`\\n(where P is one of the previous types except `Self`). Note that `Self` can\\nalso be the underlying implementing type, like `Foo` in the following\\nexample:\\n\\n```\\n# struct Foo;\\n# trait Trait {\\n#     fn foo(&self);\\n# }\\nimpl Trait for Foo {\\n    fn foo(self: &Foo) {}\\n}\\n```\\n\\nThis error will be emitted by the compiler when using an invalid receiver type,\\nlike in the following example:\\n\\n```compile_fail,E0307\\n# struct Foo;\\n# struct Bar;\\n# trait Trait {\\n#     fn foo(&self);\\n# }\\nimpl Trait for Foo {\\n    fn foo(self: &Bar) {}\\n}\\n```\\n\\nThe nightly feature [Arbitrary self types][AST] extends the accepted\\nset of receiver types to also include any type that can dereference to\\n`Self`:\\n\\n```\\n#![feature(arbitrary_self_types)]\\n\\nstruct Foo;\\nstruct Bar;\\n\\n// Because you can dereference `Bar` into `Foo`...\\nimpl std::ops::Deref for Bar {\\n    type Target = Foo;\\n\\n    fn deref(&self) -> &Foo {\\n        &Foo\\n    }\\n}\\n\\nimpl Foo {\\n    fn foo(self: Bar) {}\\n//         ^^^^^^^^^ ...it can be used as the receiver type\\n}\\n```\\n\\n[AST]: https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html\\n\")),\n  (\"E0308\",\n   Some(\"Expected type did not match the received type.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0308\\nfn plus_one(x: i32) -> i32 {\\n    x + 1\\n}\\n\\nplus_one(\\\"Not a number\\\");\\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\\n\\nif \\\"Not a bool\\\" {\\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\\n}\\n\\nlet x: f32 = \\\"Not a float\\\";\\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\\n//     |\\n//     expected due to this\\n```\\n\\nThis error occurs when an expression was used in a place where the compiler\\nexpected an expression of a different type. It can occur in several cases, the\\nmost common being when calling a function and passing an argument which has a\\ndifferent type than the matching type in the function declaration.\\n\")),\n  (\"E0309\",\n   Some(\"A parameter type is missing an explicit lifetime bound and may not live long\\nenough.\\n\\nErroneous code example:\\n\\n```compile_fail,E0309\\n// This won\\'t compile because the applicable impl of\\n// `SomeTrait` (below) requires that `T: \\'a`, but the struct does\\n// not have a matching where-clause.\\nstruct Foo<\\'a, T> {\\n    foo: <T as SomeTrait<\\'a>>::Output,\\n}\\n\\ntrait SomeTrait<\\'a> {\\n    type Output;\\n}\\n\\nimpl<\\'a, T> SomeTrait<\\'a> for T\\nwhere\\n    T: \\'a,\\n{\\n    type Output = u32;\\n}\\n```\\n\\nThe type definition contains some field whose type requires an outlives\\nannotation. Outlives annotations (e.g., `T: \\'a`) are used to guarantee that all\\nthe data in `T` is valid for at least the lifetime `\\'a`. This scenario most\\ncommonly arises when the type contains an associated type reference like\\n`<T as SomeTrait<\\'a>>::Output`, as shown in the previous code.\\n\\nThere, the where clause `T: \\'a` that appears on the impl is not known to be\\nsatisfied on the struct. To make this example compile, you have to add a\\nwhere-clause like `T: \\'a` to the struct definition:\\n\\n```\\nstruct Foo<\\'a, T>\\nwhere\\n    T: \\'a,\\n{\\n    foo: <T as SomeTrait<\\'a>>::Output\\n}\\n\\ntrait SomeTrait<\\'a> {\\n    type Output;\\n}\\n\\nimpl<\\'a, T> SomeTrait<\\'a> for T\\nwhere\\n    T: \\'a,\\n{\\n    type Output = u32;\\n}\\n```\\n\")),\n  (\"E0310\",\n   Some(\"A parameter type is missing a lifetime constraint or has a lifetime that\\ndoes not live long enough.\\n\\nErroneous code example:\\n\\n```compile_fail,E0310\\n// This won\\'t compile because T is not constrained to the static lifetime\\n// the reference needs\\nstruct Foo<T> {\\n    foo: &\\'static T\\n}\\n```\\n\\nType parameters in type definitions have lifetimes associated with them that\\nrepresent how long the data stored within them is guaranteed to live. This\\nlifetime must be as long as the data needs to be alive, and missing the\\nconstraint that denotes this will cause this error.\\n\\nThis will compile, because it has the constraint on the type parameter:\\n\\n```\\nstruct Foo<T: \\'static> {\\n    foo: &\\'static T\\n}\\n```\\n\")),\n  (\"E0312\",\n   Some(\"Reference\\'s lifetime of borrowed content doesn\\'t match the expected lifetime.\\n\\nErroneous code example:\\n\\n```compile_fail,E0312\\npub fn opt_str<\\'a>(maybestr: &\\'a Option<String>) -> &\\'static str {\\n    if maybestr.is_none() {\\n        \\\"(none)\\\"\\n    } else {\\n        let s: &\\'a str = maybestr.as_ref().unwrap();\\n        s  // Invalid lifetime!\\n    }\\n}\\n```\\n\\nTo fix this error, either lessen the expected lifetime or find a way to not have\\nto use this reference outside of its current scope (by running the code directly\\nin the same block for example?):\\n\\n```\\n// In this case, we can fix the issue by switching from \\\"static\\\" lifetime to \\'a\\npub fn opt_str<\\'a>(maybestr: &\\'a Option<String>) -> &\\'a str {\\n    if maybestr.is_none() {\\n        \\\"(none)\\\"\\n    } else {\\n        let s: &\\'a str = maybestr.as_ref().unwrap();\\n        s  // Ok!\\n    }\\n}\\n```\\n\")),\n  (\"E0316\",\n   Some(\"A `where` clause contains a nested quantification over lifetimes.\\n\\nErroneous code example:\\n\\n```compile_fail,E0316\\ntrait Tr<\\'a, \\'b> {}\\n\\nfn foo<T>(t: T)\\nwhere\\n    for<\\'a> &\\'a T: for<\\'b> Tr<\\'a, \\'b>, // error: nested quantification\\n{\\n}\\n```\\n\\nRust syntax allows lifetime quantifications in two places within\\n`where` clauses: Quantifying over the trait bound only (as in\\n`Ty: for<\\'l> Trait<\\'l>`) and quantifying over the whole clause\\n(as in `for<\\'l> &\\'l Ty: Trait<\\'l>`). Using both in the same clause\\nleads to a nested lifetime quantification, which is not supported.\\n\\nThe following example compiles, because the clause with the nested\\nquantification has been rewritten to use only one `for<>`:\\n\\n```\\ntrait Tr<\\'a, \\'b> {}\\n\\nfn foo<T>(t: T)\\nwhere\\n    for<\\'a, \\'b> &\\'a T: Tr<\\'a, \\'b>, // ok\\n{\\n}\\n```\\n\")),\n  (\"E0317\",\n   Some(\"An `if` expression is missing an `else` block.\\n\\nErroneous code example:\\n\\n```compile_fail,E0317\\nlet x = 5;\\nlet a = if x == 5 {\\n    1\\n};\\n```\\n\\nThis error occurs when an `if` expression without an `else` block is used in a\\ncontext where a type other than `()` is expected. In the previous code example,\\nthe `let` expression was expecting a value but since there was no `else`, no\\nvalue was returned.\\n\\nAn `if` expression without an `else` block has the type `()`, so this is a type\\nerror. To resolve it, add an `else` block having the same type as the `if`\\nblock.\\n\\nSo to fix the previous code example:\\n\\n```\\nlet x = 5;\\nlet a = if x == 5 {\\n    1\\n} else {\\n    2\\n};\\n```\\n\")),\n  (\"E0321\",\n   Some(\"A cross-crate opt-out trait was implemented on something which wasn\\'t a struct\\nor enum type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0321\\n#![feature(auto_traits)]\\n\\nstruct Foo;\\n\\nimpl !Sync for Foo {}\\n\\nunsafe impl Send for &\\'static Foo {}\\n// error: cross-crate traits with a default impl, like `core::marker::Send`,\\n//        can only be implemented for a struct/enum type, not\\n//        `&\\'static Foo`\\n```\\n\\nOnly structs and enums are permitted to impl Send, Sync, and other opt-out\\ntrait, and the struct or enum must be local to the current crate. So, for\\nexample, `unsafe impl Send for Rc<Foo>` is not allowed.\\n\")),\n  (\"E0322\",\n   Some(\"The `Sized` trait was implemented explicitly.\\n\\nErroneous code example:\\n\\n```compile_fail,E0322\\nstruct Foo;\\n\\nimpl Sized for Foo {} // error!\\n```\\n\\nThe `Sized` trait is a special trait built-in to the compiler for types with a\\nconstant size known at compile-time. This trait is automatically implemented\\nfor types as needed by the compiler, and it is currently disallowed to\\nexplicitly implement it for a type.\\n\")),\n  (\"E0323\",\n   Some(\"An associated const was implemented when another trait item was expected.\\n\\nErroneous code example:\\n\\n```compile_fail,E0323\\ntrait Foo {\\n    type N;\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    const N : u32 = 0;\\n    // error: item `N` is an associated const, which doesn\\'t match its\\n    //        trait `<Bar as Foo>`\\n}\\n```\\n\\nPlease verify that the associated const wasn\\'t misspelled and the correct trait\\nwas implemented. Example:\\n\\n```\\nstruct Bar;\\n\\ntrait Foo {\\n    type N;\\n}\\n\\nimpl Foo for Bar {\\n    type N = u32; // ok!\\n}\\n```\\n\\nOr:\\n\\n```\\nstruct Bar;\\n\\ntrait Foo {\\n    const N : u32;\\n}\\n\\nimpl Foo for Bar {\\n    const N : u32 = 0; // ok!\\n}\\n```\\n\")),\n  (\"E0324\",\n   Some(\"A method was implemented when another trait item was expected.\\n\\nErroneous code example:\\n\\n```compile_fail,E0324\\nstruct Bar;\\n\\ntrait Foo {\\n    const N : u32;\\n\\n    fn M();\\n}\\n\\nimpl Foo for Bar {\\n    fn N() {}\\n    // error: item `N` is an associated method, which doesn\\'t match its\\n    //        trait `<Bar as Foo>`\\n}\\n```\\n\\nTo fix this error, please verify that the method name wasn\\'t misspelled and\\nverify that you are indeed implementing the correct trait items. Example:\\n\\n```\\nstruct Bar;\\n\\ntrait Foo {\\n    const N : u32;\\n\\n    fn M();\\n}\\n\\nimpl Foo for Bar {\\n    const N : u32 = 0;\\n\\n    fn M() {} // ok!\\n}\\n```\\n\")),\n  (\"E0325\",\n   Some(\"An associated type was implemented when another trait item was expected.\\n\\nErroneous code example:\\n\\n```compile_fail,E0325\\nstruct Bar;\\n\\ntrait Foo {\\n    const N : u32;\\n}\\n\\nimpl Foo for Bar {\\n    type N = u32;\\n    // error: item `N` is an associated type, which doesn\\'t match its\\n    //        trait `<Bar as Foo>`\\n}\\n```\\n\\nPlease verify that the associated type name wasn\\'t misspelled and your\\nimplementation corresponds to the trait definition. Example:\\n\\n```\\nstruct Bar;\\n\\ntrait Foo {\\n    type N;\\n}\\n\\nimpl Foo for Bar {\\n    type N = u32; // ok!\\n}\\n```\\n\\nOr:\\n\\n```\\nstruct Bar;\\n\\ntrait Foo {\\n    const N : u32;\\n}\\n\\nimpl Foo for Bar {\\n    const N : u32 = 0; // ok!\\n}\\n```\\n\")),\n  (\"E0326\",\n   Some(\"An implementation of a trait doesn\\'t match the type constraint.\\n\\nErroneous code example:\\n\\n```compile_fail,E0326\\ntrait Foo {\\n    const BAR: bool;\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    const BAR: u32 = 5; // error, expected bool, found u32\\n}\\n```\\n\\nThe types of any associated constants in a trait implementation must match the\\ntypes in the trait definition.\\n\")),\n  (\"E0328\",\n   Some(\"The Unsize trait should not be implemented directly. All implementations of\\nUnsize are provided automatically by the compiler.\\n\\nErroneous code example:\\n\\n```compile_fail,E0328\\n#![feature(unsize)]\\n\\nuse std::marker::Unsize;\\n\\npub struct MyType;\\n\\nimpl<T> Unsize<T> for MyType {}\\n```\\n\\nIf you are defining your own smart pointer type and would like to enable\\nconversion from a sized to an unsized type with the\\n[DST coercion system][RFC 982], use [`CoerceUnsized`] instead.\\n\\n```\\n#![feature(coerce_unsized)]\\n\\nuse std::ops::CoerceUnsized;\\n\\npub struct MyType<T: ?Sized> {\\n    field_with_unsized_type: T,\\n}\\n\\nimpl<T, U> CoerceUnsized<MyType<U>> for MyType<T>\\n    where T: CoerceUnsized<U> {}\\n```\\n\\n[RFC 982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\\n[`CoerceUnsized`]: https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html\\n\")),\n  (\"E0329\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nAn attempt was made to access an associated constant through either a generic\\ntype parameter or `Self`. This is not supported yet. An example causing this\\nerror is shown below:\\n\\n```\\ntrait Foo {\\n    const BAR: f64;\\n}\\n\\nstruct MyStruct;\\n\\nimpl Foo for MyStruct {\\n    const BAR: f64 = 0f64;\\n}\\n\\nfn get_bar_bad<F: Foo>(t: F) -> f64 {\\n    F::BAR\\n}\\n```\\n\\nCurrently, the value of `BAR` for a particular type can only be accessed\\nthrough a concrete type, as shown below:\\n\\n```\\ntrait Foo {\\n    const BAR: f64;\\n}\\n\\nstruct MyStruct;\\n\\nimpl Foo for MyStruct {\\n    const BAR: f64 = 0f64;\\n}\\n\\nfn get_bar_good() -> f64 {\\n    <MyStruct as Foo>::BAR\\n}\\n```\\n\")),\n  (\"E0364\",\n   Some(\"Private items cannot be publicly re-exported. This error indicates that you\\nattempted to `pub use` a type or value that was not itself public.\\n\\nErroneous code example:\\n\\n```compile_fail,E0364\\nmod a {\\n    fn foo() {}\\n\\n    mod a {\\n        pub use super::foo; // error!\\n    }\\n}\\n```\\n\\nThe solution to this problem is to ensure that the items that you are\\nre-exporting are themselves marked with `pub`:\\n\\n```\\nmod a {\\n    pub fn foo() {} // ok!\\n\\n    mod a {\\n        pub use super::foo;\\n    }\\n}\\n```\\n\\nSee the [Use Declarations][use-declarations] section of the reference for\\nmore information on this topic.\\n\\n[use-declarations]: https://doc.rust-lang.org/reference/items/use-declarations.html\\n\")),\n  (\"E0365\",\n   Some(\"Private modules cannot be publicly re-exported. This error indicates that you\\nattempted to `pub use` a module that was not itself public.\\n\\nErroneous code example:\\n\\n```compile_fail,E0365\\nmod foo {\\n    pub const X: u32 = 1;\\n}\\n\\npub use foo as foo2;\\n\\nfn main() {}\\n```\\n\\nThe solution to this problem is to ensure that the module that you are\\nre-exporting is itself marked with `pub`:\\n\\n```\\npub mod foo {\\n    pub const X: u32 = 1;\\n}\\n\\npub use foo as foo2;\\n\\nfn main() {}\\n```\\n\\nSee the [Use Declarations][use-declarations] section of the reference for\\nmore information on this topic.\\n\\n[use-declarations]: https://doc.rust-lang.org/reference/items/use-declarations.html\\n\")),\n  (\"E0366\",\n   Some(\"An attempt was made to implement `Drop` on a concrete specialization of a\\ngeneric type. An example is shown below:\\n\\n```compile_fail,E0366\\nstruct Foo<T> {\\n    t: T\\n}\\n\\nimpl Drop for Foo<u32> {\\n    fn drop(&mut self) {}\\n}\\n```\\n\\nThis code is not legal: it is not possible to specialize `Drop` to a subset of\\nimplementations of a generic type. One workaround for this is to wrap the\\ngeneric type, as shown below:\\n\\n```\\nstruct Foo<T> {\\n    t: T\\n}\\n\\nstruct Bar {\\n    t: Foo<u32>\\n}\\n\\nimpl Drop for Bar {\\n    fn drop(&mut self) {}\\n}\\n```\\n\")),\n  (\"E0367\",\n   Some(\"An attempt was made to implement `Drop` on a specialization of a generic type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0367\\ntrait Foo {}\\n\\nstruct MyStruct<T> {\\n    t: T\\n}\\n\\nimpl<T: Foo> Drop for MyStruct<T> {\\n    fn drop(&mut self) {}\\n}\\n```\\n\\nThis code is not legal: it is not possible to specialize `Drop` to a subset of\\nimplementations of a generic type. In order for this code to work, `MyStruct`\\nmust also require that `T` implements `Foo`. Alternatively, another option is\\nto wrap the generic type in another that specializes appropriately:\\n\\n```\\ntrait Foo{}\\n\\nstruct MyStruct<T> {\\n    t: T\\n}\\n\\nstruct MyStructWrapper<T: Foo> {\\n    t: MyStruct<T>\\n}\\n\\nimpl <T: Foo> Drop for MyStructWrapper<T> {\\n    fn drop(&mut self) {}\\n}\\n```\\n\")),\n  (\"E0368\",\n   Some(\"A binary assignment operator like `+=` or `^=` was applied to a type that\\ndoesn\\'t support it.\\n\\nErroneous code example:\\n\\n```compile_fail,E0368\\nlet mut x = 12f32; // error: binary operation `<<` cannot be applied to\\n                   //        type `f32`\\n\\nx <<= 2;\\n```\\n\\nTo fix this error, please check that this type implements this binary\\noperation. Example:\\n\\n```\\nlet mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait\\n\\nx <<= 2; // ok!\\n```\\n\\nIt is also possible to overload most operators for your own type by\\nimplementing the `[OP]Assign` traits from `std::ops`.\\n\\nAnother problem you might be facing is this: suppose you\\'ve overloaded the `+`\\noperator for some type `Foo` by implementing the `std::ops::Add` trait for\\n`Foo`, but you find that using `+=` does not work, as in this example:\\n\\n```compile_fail,E0368\\nuse std::ops::Add;\\n\\nstruct Foo(u32);\\n\\nimpl Add for Foo {\\n    type Output = Foo;\\n\\n    fn add(self, rhs: Foo) -> Foo {\\n        Foo(self.0 + rhs.0)\\n    }\\n}\\n\\nfn main() {\\n    let mut x: Foo = Foo(5);\\n    x += Foo(7); // error, `+= cannot be applied to the type `Foo`\\n}\\n```\\n\\nThis is because `AddAssign` is not automatically implemented, so you need to\\nmanually implement it for your type.\\n\")),\n  (\"E0369\",\n   Some(\"A binary operation was attempted on a type which doesn\\'t support it.\\n\\nErroneous code example:\\n\\n```compile_fail,E0369\\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\\n               //        type `f32`\\n\\nx << 2;\\n```\\n\\nTo fix this error, please check that this type implements this binary\\noperation. Example:\\n\\n```\\nlet x = 12u32; // the `u32` type does implement it:\\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\\n\\nx << 2; // ok!\\n```\\n\\nIt is also possible to overload most operators for your own type by\\nimplementing traits from `std::ops`.\\n\\nString concatenation appends the string on the right to the string on the\\nleft and may require reallocation. This requires ownership of the string\\non the left. If something should be added to a string literal, move the\\nliteral to the heap by allocating it with `to_owned()` like in\\n`\\\"Your text\\\".to_owned()`.\\n\")),\n  (\"E0370\",\n   Some(\"The maximum value of an enum was reached, so it cannot be automatically\\nset in the next enum value.\\n\\nErroneous code example:\\n\\n```compile_fail,E0370\\n#[repr(i64)]\\nenum Foo {\\n    X = 0x7fffffffffffffff,\\n    Y, // error: enum discriminant overflowed on value after\\n       //        9223372036854775807: i64; set explicitly via\\n       //        Y = -9223372036854775808 if that is desired outcome\\n}\\n```\\n\\nTo fix this, please set manually the next enum value or put the enum variant\\nwith the maximum value at the end of the enum. Examples:\\n\\n```\\n#[repr(i64)]\\nenum Foo {\\n    X = 0x7fffffffffffffff,\\n    Y = 0, // ok!\\n}\\n```\\n\\nOr:\\n\\n```\\n#[repr(i64)]\\nenum Foo {\\n    Y = 0, // ok!\\n    X = 0x7fffffffffffffff,\\n}\\n```\\n\")),\n  (\"E0371\",\n   Some(\"A trait was implemented on another which already automatically implemented it.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0371\\ntrait Foo { fn foo(&self) { } }\\ntrait Bar: Foo { }\\ntrait Baz: Bar { }\\n\\nimpl Bar for Baz { } // error, `Baz` implements `Bar` by definition\\nimpl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`\\nimpl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`\\nimpl Baz for Bar { } // Note: This is OK\\n```\\n\\nWhen `Trait2` is a subtrait of `Trait1` (for example, when `Trait2` has a\\ndefinition like `trait Trait2: Trait1 { ... }`), it is not allowed to implement\\n`Trait1` for `Trait2`. This is because `Trait2` already implements `Trait1` by\\ndefinition, so it is not useful to do this.\\n\")),\n  (\"E0373\",\n   Some(\"A captured variable in a closure may not live long enough.\\n\\nErroneous code example:\\n\\n```compile_fail,E0373\\nfn foo() -> Box<Fn(u32) -> u32> {\\n    let x = 0u32;\\n    Box::new(|y| x + y)\\n}\\n```\\n\\nThis error occurs when an attempt is made to use data captured by a closure,\\nwhen that data may no longer exist. It\\'s most commonly seen when attempting to\\nreturn a closure as shown in the previous code example.\\n\\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\\nclosed-over data by reference. This means that once `foo()` returns, `x` no\\nlonger exists. An attempt to access `x` within the closure would thus be\\nunsafe.\\n\\nAnother situation where this might be encountered is when spawning threads:\\n\\n```compile_fail,E0373\\nfn foo() {\\n    let x = 0u32;\\n    let y = 1u32;\\n\\n    let thr = std::thread::spawn(|| {\\n        x + y\\n    });\\n}\\n```\\n\\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\\nmay well have disappeared by the time we try to use them. Even if we call\\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\\nstack frame won\\'t disappear), we will not succeed: the compiler cannot prove\\nthat this behavior is safe, and so won\\'t let us do it.\\n\\nThe solution to this problem is usually to switch to using a `move` closure.\\nThis approach moves (or copies, where possible) data into the closure, rather\\nthan taking references to it. For example:\\n\\n```\\nfn foo() -> Box<Fn(u32) -> u32> {\\n    let x = 0u32;\\n    Box::new(move |y| x + y)\\n}\\n```\\n\\nNow that the closure has its own copy of the data, there\\'s no need to worry\\nabout safety.\\n\\nThis error may also be encountered while using `async` blocks:\\n\\n```compile_fail,E0373,edition2018\\nuse std::future::Future;\\n\\nasync fn f() {\\n    let v = vec![1, 2, 3i32];\\n    spawn(async { //~ ERROR E0373\\n        println!(\\\"{:?}\\\", v)\\n    });\\n}\\n\\nfn spawn<F: Future + Send + \\'static>(future: F) {\\n    unimplemented!()\\n}\\n```\\n\\nSimilarly to closures, `async` blocks are not executed immediately and may\\ncapture closed-over data by reference. For more information, see\\nhttps://rust-lang.github.io/async-book/03_async_await/01_chapter.html.\\n\")),\n  (\"E0374\",\n   Some(\"`CoerceUnsized` was implemented on a struct which does not contain a field with\\nan unsized type.\\n\\nExample of erroneous code:\\n\\n```compile_fail,E0374\\n#![feature(coerce_unsized)]\\nuse std::ops::CoerceUnsized;\\n\\nstruct Foo<T: ?Sized> {\\n    a: i32,\\n}\\n\\n// error: Struct `Foo` has no unsized fields that need `CoerceUnsized`.\\nimpl<T, U> CoerceUnsized<Foo<U>> for Foo<T>\\n    where T: CoerceUnsized<U> {}\\n```\\n\\nAn [unsized type][1] is any type where the compiler does not know the length or\\nalignment of at compile time. Any struct containing an unsized type is also\\nunsized.\\n\\n[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\\n\\n`CoerceUnsized` is used to coerce one struct containing an unsized type\\ninto another struct containing a different unsized type. If the struct\\ndoesn\\'t have any fields of unsized types then you don\\'t need explicit\\ncoercion to get the types you want. To fix this you can either\\nnot try to implement `CoerceUnsized` or you can add a field that is\\nunsized to the struct.\\n\\nExample:\\n\\n```\\n#![feature(coerce_unsized)]\\nuse std::ops::CoerceUnsized;\\n\\n// We don\\'t need to impl `CoerceUnsized` here.\\nstruct Foo {\\n    a: i32,\\n}\\n\\n// We add the unsized type field to the struct.\\nstruct Bar<T: ?Sized> {\\n    a: i32,\\n    b: T,\\n}\\n\\n// The struct has an unsized field so we can implement\\n// `CoerceUnsized` for it.\\nimpl<T, U> CoerceUnsized<Bar<U>> for Bar<T>\\n    where T: CoerceUnsized<U> {}\\n```\\n\\nNote that `CoerceUnsized` is mainly used by smart pointers like `Box`, `Rc`\\nand `Arc` to be able to mark that they can coerce unsized types that they\\nare pointing at.\\n\")),\n  (\"E0375\",\n   Some(\"`CoerceUnsized` was implemented on a struct which contains more than one field\\nwith an unsized type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0375\\n#![feature(coerce_unsized)]\\nuse std::ops::CoerceUnsized;\\n\\nstruct Foo<T: ?Sized, U: ?Sized> {\\n    a: i32,\\n    b: T,\\n    c: U,\\n}\\n\\n// error: Struct `Foo` has more than one unsized field.\\nimpl<T, U> CoerceUnsized<Foo<U, T>> for Foo<T, U> {}\\n```\\n\\nA struct with more than one field containing an unsized type cannot implement\\n`CoerceUnsized`. This only occurs when you are trying to coerce one of the\\ntypes in your struct to another type in the struct. In this case we try to\\nimpl `CoerceUnsized` from `T` to `U` which are both types that the struct\\ntakes. An [unsized type][1] is any type that the compiler doesn\\'t know the\\nlength or alignment of at compile time. Any struct containing an unsized type\\nis also unsized.\\n\\n`CoerceUnsized` only allows for coercion from a structure with a single\\nunsized type field to another struct with a single unsized type field.\\nIn fact Rust only allows for a struct to have one unsized type in a struct\\nand that unsized type must be the last field in the struct. So having two\\nunsized types in a single struct is not allowed by the compiler. To fix this\\nuse only one field containing an unsized type in the struct and then use\\nmultiple structs to manage each unsized type field you need.\\n\\nExample:\\n\\n```\\n#![feature(coerce_unsized)]\\nuse std::ops::CoerceUnsized;\\n\\nstruct Foo<T: ?Sized> {\\n    a: i32,\\n    b: T,\\n}\\n\\nimpl <T, U> CoerceUnsized<Foo<U>> for Foo<T>\\n    where T: CoerceUnsized<U> {}\\n\\nfn coerce_foo<T: CoerceUnsized<U>, U>(t: T) -> Foo<U> {\\n    Foo { a: 12i32, b: t } // we use coercion to get the `Foo<U>` type we need\\n}\\n```\\n\\n[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\\n\")),\n  (\"E0376\",\n   Some(\"`CoerceUnsized` was implemented on something that isn\\'t a struct.\\n\\nErroneous code example:\\n\\n```compile_fail,E0376\\n#![feature(coerce_unsized)]\\nuse std::ops::CoerceUnsized;\\n\\nstruct Foo<T: ?Sized> {\\n    a: T,\\n}\\n\\n// error: The type `U` is not a struct\\nimpl<T, U> CoerceUnsized<U> for Foo<T> {}\\n```\\n\\n`CoerceUnsized` can only be implemented for a struct. Unsized types are\\nalready able to be coerced without an implementation of `CoerceUnsized`\\nwhereas a struct containing an unsized type needs to know the unsized type\\nfield it\\'s containing is able to be coerced. An [unsized type][1]\\nis any type that the compiler doesn\\'t know the length or alignment of at\\ncompile time. Any struct containing an unsized type is also unsized.\\n\\n[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\\n\\nThe `CoerceUnsized` trait takes a struct type. Make sure the type you are\\nproviding to `CoerceUnsized` is a struct with only the last field containing an\\nunsized type.\\n\\nExample:\\n\\n```\\n#![feature(coerce_unsized)]\\nuse std::ops::CoerceUnsized;\\n\\nstruct Foo<T> {\\n    a: T,\\n}\\n\\n// The `Foo<U>` is a struct so `CoerceUnsized` can be implemented\\nimpl<T, U> CoerceUnsized<Foo<U>> for Foo<T> where T: CoerceUnsized<U> {}\\n```\\n\\nNote that in Rust, structs can only contain an unsized type if the field\\ncontaining the unsized type is the last and only unsized type field in the\\nstruct.\\n\")),\n  (\"E0378\",\n   Some(\"The `DispatchFromDyn` trait was implemented on something which is not a pointer\\nor a newtype wrapper around a pointer.\\n\\nErroneous code example:\\n\\n```compile_fail,E0378\\n#![feature(dispatch_from_dyn)]\\nuse std::ops::DispatchFromDyn;\\n\\nstruct WrapperExtraField<T> {\\n    ptr: T,\\n    extra_stuff: i32,\\n}\\n\\nimpl<T, U> DispatchFromDyn<WrapperExtraField<U>> for WrapperExtraField<T>\\nwhere\\n    T: DispatchFromDyn<U>,\\n{}\\n```\\n\\nThe `DispatchFromDyn` trait currently can only be implemented for\\nbuiltin pointer types and structs that are newtype wrappers around them\\n\\u{2014} that is, the struct must have only one field (except for`PhantomData`),\\nand that field must itself implement `DispatchFromDyn`.\\n\\n```\\n#![feature(dispatch_from_dyn, unsize)]\\nuse std::{\\n    marker::Unsize,\\n    ops::DispatchFromDyn,\\n};\\n\\nstruct Ptr<T: ?Sized>(*const T);\\n\\nimpl<T: ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T>\\nwhere\\n    T: Unsize<U>,\\n{}\\n```\\n\\nAnother example:\\n\\n```\\n#![feature(dispatch_from_dyn)]\\nuse std::{\\n    ops::DispatchFromDyn,\\n    marker::PhantomData,\\n};\\n\\nstruct Wrapper<T> {\\n    ptr: T,\\n    _phantom: PhantomData<()>,\\n}\\n\\nimpl<T, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T>\\nwhere\\n    T: DispatchFromDyn<U>,\\n{}\\n```\\n\")),\n  (\"E0379\",\n   Some(\"A trait method was declared const.\\n\\nErroneous code example:\\n\\n```compile_fail,E0379\\ntrait Foo {\\n    const fn bar() -> u32; // error!\\n}\\n```\\n\\nTrait methods cannot be declared `const` by design. For more information, see\\n[RFC 911].\\n\\n[RFC 911]: https://github.com/rust-lang/rfcs/pull/911\\n\")),\n  (\"E0380\",\n   Some(\"An auto trait was declared with a method or an associated item.\\n\\nErroneous code example:\\n\\n```compile_fail,E0380\\nunsafe auto trait Trait {\\n    type Output; // error!\\n}\\n```\\n\\nAuto traits cannot have methods or associated items. For more information see\\nthe [opt-in builtin traits RFC][RFC 19].\\n\\n[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md\\n\")),\n  (\"E0381\",\n   Some(\"It is not allowed to use or capture an uninitialized variable.\\n\\nErroneous code example:\\n\\n```compile_fail,E0381\\nfn main() {\\n    let x: i32;\\n    let y = x; // error, use of possibly-uninitialized variable\\n}\\n```\\n\\nTo fix this, ensure that any declared variables are initialized before being\\nused. Example:\\n\\n```\\nfn main() {\\n    let x: i32 = 0;\\n    let y = x; // ok!\\n}\\n```\\n\")),\n  (\"E0382\",\n   Some(\"A variable was used after its contents have been moved elsewhere.\\n\\nErroneous code example:\\n\\n```compile_fail,E0382\\nstruct MyStruct { s: u32 }\\n\\nfn main() {\\n    let mut x = MyStruct{ s: 5u32 };\\n    let y = x;\\n    x.s = 6;\\n    println!(\\\"{}\\\", x.s);\\n}\\n```\\n\\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\\nof `x` when we set `y`. This is fundamental to Rust\\'s ownership system: outside\\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\\n\\nSometimes we don\\'t need to move the value. Using a reference, we can let another\\nfunction borrow the value without changing its ownership. In the example below,\\nwe don\\'t actually have to move our string to `calculate_length`, we can give it\\na reference to it with `&` instead.\\n\\n```\\nfn main() {\\n    let s1 = String::from(\\\"hello\\\");\\n\\n    let len = calculate_length(&s1);\\n\\n    println!(\\\"The length of \\'{}\\' is {}.\\\", s1, len);\\n}\\n\\nfn calculate_length(s: &String) -> usize {\\n    s.len()\\n}\\n```\\n\\nA mutable reference can be created with `&mut`.\\n\\nSometimes we don\\'t want a reference, but a duplicate. All types marked `Clone`\\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\\naffect the original variable.\\n\\nMost types in the standard library are marked `Clone`. The example below\\ndemonstrates using `clone()` on a string. `s1` is first set to \\\"many\\\", and then\\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\\n`s2`. \\\"any many\\\" is printed to the console.\\n\\n```\\nfn main() {\\n    let mut s1 = String::from(\\\"many\\\");\\n    let s2 = s1.clone();\\n    s1.remove(0);\\n    println!(\\\"{} {}\\\", s1, s2);\\n}\\n```\\n\\nIf we control the definition of a type, we can implement `Clone` on it ourselves\\nwith `#[derive(Clone)]`.\\n\\nSome types have no ownership semantics at all and are trivial to duplicate. An\\nexample is `i32` and the other number types. We don\\'t have to call `.clone()` to\\nclone them, because they are marked `Copy` in addition to `Clone`.  Implicit\\ncloning is more convenient in this case. We can mark our own types `Copy` if\\nall their members also are marked `Copy`.\\n\\nIn the example below, we implement a `Point` type. Because it only stores two\\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\\n`let p2 = p1` without `p1` being moved.\\n\\n```\\n#[derive(Copy, Clone)]\\nstruct Point { x: i32, y: i32 }\\n\\nfn main() {\\n    let mut p1 = Point{ x: -1, y: 2 };\\n    let p2 = p1;\\n    p1.x = 1;\\n    println!(\\\"p1: {}, {}\\\", p1.x, p1.y);\\n    println!(\\\"p2: {}, {}\\\", p2.x, p2.y);\\n}\\n```\\n\\nAlternatively, if we don\\'t control the struct\\'s definition, or mutable shared\\nownership is truly required, we can use `Rc` and `RefCell`:\\n\\n```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nstruct MyStruct { s: u32 }\\n\\nfn main() {\\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\\n    let y = x.clone();\\n    x.borrow_mut().s = 6;\\n    println!(\\\"{}\\\", x.borrow().s);\\n}\\n```\\n\\nWith this approach, x and y share ownership of the data via the `Rc` (reference\\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\\nthat at most one writer or multiple readers can access the data at any one time.\\n\\nIf you wish to learn more about ownership in Rust, start with the\\n[Understanding Ownership][understanding-ownership] chapter in the Book.\\n\\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\\n\")),\n  (\"E0383\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThis error occurs when an attempt is made to partially reinitialize a\\nstructure that is currently uninitialized.\\n\\nFor example, this can happen when a drop has taken place:\\n\\n```compile_fail\\nstruct Foo {\\n    a: u32,\\n}\\nimpl Drop for Foo {\\n    fn drop(&mut self) { /* ... */ }\\n}\\n\\nlet mut x = Foo { a: 1 };\\ndrop(x); // `x` is now uninitialized\\nx.a = 2; // error, partial reinitialization of uninitialized structure `t`\\n```\\n\\nThis error can be fixed by fully reinitializing the structure in question:\\n\\n```\\nstruct Foo {\\n    a: u32,\\n}\\nimpl Drop for Foo {\\n    fn drop(&mut self) { /* ... */ }\\n}\\n\\nlet mut x = Foo { a: 1 };\\ndrop(x);\\nx = Foo { a: 2 };\\n```\\n\")),\n  (\"E0384\",\n   Some(\"An immutable variable was reassigned.\\n\\nErroneous code example:\\n\\n```compile_fail,E0384\\nfn main() {\\n    let x = 3;\\n    x = 5; // error, reassignment of immutable variable\\n}\\n```\\n\\nBy default, variables in Rust are immutable. To fix this error, add the keyword\\n`mut` after the keyword `let` when declaring the variable. For example:\\n\\n```\\nfn main() {\\n    let mut x = 3;\\n    x = 5;\\n}\\n```\\n\")),\n  (\"E0386\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThis error occurs when an attempt is made to mutate the target of a mutable\\nreference stored inside an immutable container.\\n\\nFor example, this can happen when storing a `&mut` inside an immutable `Box`:\\n\\n```\\nlet mut x: i64 = 1;\\nlet y: Box<_> = Box::new(&mut x);\\n**y = 2; // error, cannot assign to data in an immutable container\\n```\\n\\nThis error can be fixed by making the container mutable:\\n\\n```\\nlet mut x: i64 = 1;\\nlet mut y: Box<_> = Box::new(&mut x);\\n**y = 2;\\n```\\n\\nIt can also be fixed by using a type with interior mutability, such as `Cell`\\nor `RefCell`:\\n\\n```\\nuse std::cell::Cell;\\n\\nlet x: i64 = 1;\\nlet y: Box<Cell<_>> = Box::new(Cell::new(x));\\ny.set(2);\\n```\\n\")),\n  (\"E0387\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThis error occurs when an attempt is made to mutate or mutably reference data\\nthat a closure has captured immutably.\\n\\nErroneous code example:\\n\\n```compile_fail\\n// Accepts a function or a closure that captures its environment immutably.\\n// Closures passed to foo will not be able to mutate their closed-over state.\\nfn foo<F: Fn()>(f: F) { }\\n\\n// Attempts to mutate closed-over data. Error message reads:\\n// `cannot assign to data in a captured outer variable...`\\nfn mutable() {\\n    let mut x = 0u32;\\n    foo(|| x = 2);\\n}\\n\\n// Attempts to take a mutable reference to closed-over data.  Error message\\n// reads: `cannot borrow data mutably in a captured outer variable...`\\nfn mut_addr() {\\n    let mut x = 0u32;\\n    foo(|| { let y = &mut x; });\\n}\\n```\\n\\nThe problem here is that foo is defined as accepting a parameter of type `Fn`.\\nClosures passed into foo will thus be inferred to be of type `Fn`, meaning that\\nthey capture their context immutably.\\n\\nIf the definition of `foo` is under your control, the simplest solution is to\\ncapture the data mutably. This can be done by defining `foo` to take FnMut\\nrather than Fn:\\n\\n```\\nfn foo<F: FnMut()>(f: F) { }\\n```\\n\\nAlternatively, we can consider using the `Cell` and `RefCell` types to achieve\\ninterior mutability through a shared reference. Our example\\'s `mutable`\\nfunction could be redefined as below:\\n\\n```\\nuse std::cell::Cell;\\n\\nfn foo<F: Fn()>(f: F) { }\\n\\nfn mutable() {\\n    let x = Cell::new(0u32);\\n    foo(|| x.set(2));\\n}\\n```\\n\\nYou can read more in the API documentation for [Cell][std-cell].\\n\\n[std-cell]: https://doc.rust-lang.org/std/cell/\\n\")),\n  (\"E0388\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\")),\n  (\"E0389\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nAn attempt was made to mutate data using a non-mutable reference. This\\ncommonly occurs when attempting to assign to a non-mutable reference of a\\nmutable reference (`&(&mut T)`).\\n\\nErroneous code example:\\n\\n```compile_fail\\nstruct FancyNum {\\n    num: u8,\\n}\\n\\nfn main() {\\n    let mut fancy = FancyNum{ num: 5 };\\n    let fancy_ref = &(&mut fancy);\\n    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\\n    println!(\\\"{}\\\", fancy_ref.num);\\n}\\n```\\n\\nHere, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\\nimmutable reference to a value borrows it immutably. There can be multiple\\nreferences of type `&(&mut T)` that point to the same value, so they must be\\nimmutable to prevent multiple mutable references to the same value.\\n\\nTo fix this, either remove the outer reference:\\n\\n```\\nstruct FancyNum {\\n    num: u8,\\n}\\n\\nfn main() {\\n    let mut fancy = FancyNum{ num: 5 };\\n\\n    let fancy_ref = &mut fancy;\\n    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\\n\\n    fancy_ref.num = 6; // No error!\\n\\n    println!(\\\"{}\\\", fancy_ref.num);\\n}\\n```\\n\\nOr make the outer reference mutable:\\n\\n```\\nstruct FancyNum {\\n    num: u8\\n}\\n\\nfn main() {\\n    let mut fancy = FancyNum{ num: 5 };\\n\\n    let fancy_ref = &mut (&mut fancy);\\n    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\\n\\n    fancy_ref.num = 6; // No error!\\n\\n    println!(\\\"{}\\\", fancy_ref.num);\\n}\\n```\\n\")),\n  (\"E0390\",\n   Some(\"A method or constant was implemented on a primitive type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0390\\nstruct Foo {\\n    x: i32\\n}\\n\\nimpl *mut Foo {}\\n// error: only a single inherent implementation marked with\\n//        `#[lang = \\\"mut_ptr\\\"]` is allowed for the `*mut T` primitive\\n```\\n\\nThis isn\\'t allowed, but using a trait to implement a method or constant\\nis a good solution.\\nExample:\\n\\n```\\nstruct Foo {\\n    x: i32\\n}\\n\\ntrait Bar {\\n    fn bar();\\n}\\n\\nimpl Bar for *mut Foo {\\n    fn bar() {} // ok!\\n}\\n```\\n\")),\n  (\"E0391\",\n   Some(\"A type dependency cycle has been encountered.\\n\\nErroneous code example:\\n\\n```compile_fail,E0391\\ntrait FirstTrait : SecondTrait {\\n\\n}\\n\\ntrait SecondTrait : FirstTrait {\\n\\n}\\n```\\n\\nThe previous example contains a circular dependency between two traits:\\n`FirstTrait` depends on `SecondTrait` which itself depends on `FirstTrait`.\\n\")),\n  (\"E0392\",\n   Some(\"A type or lifetime parameter has been declared but is not actually used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0392\\nenum Foo<T> {\\n    Bar,\\n}\\n```\\n\\nIf the type parameter was included by mistake, this error can be fixed\\nby simply removing the type parameter, as shown below:\\n\\n```\\nenum Foo {\\n    Bar,\\n}\\n```\\n\\nAlternatively, if the type parameter was intentionally inserted, it must be\\nused. A simple fix is shown below:\\n\\n```\\nenum Foo<T> {\\n    Bar(T),\\n}\\n```\\n\\nThis error may also commonly be found when working with unsafe code. For\\nexample, when using raw pointers one may wish to specify the lifetime for\\nwhich the pointed-at data is valid. An initial attempt (below) causes this\\nerror:\\n\\n```compile_fail,E0392\\nstruct Foo<\\'a, T> {\\n    x: *const T,\\n}\\n```\\n\\nWe want to express the constraint that Foo should not outlive `\\'a`, because\\nthe data pointed to by `T` is only valid for that lifetime. The problem is\\nthat there are no actual uses of `\\'a`. It\\'s possible to work around this\\nby adding a PhantomData type to the struct, using it to tell the compiler\\nto act as if the struct contained a borrowed reference `&\\'a T`:\\n\\n```\\nuse std::marker::PhantomData;\\n\\nstruct Foo<\\'a, T: \\'a> {\\n    x: *const T,\\n    phantom: PhantomData<&\\'a T>\\n}\\n```\\n\\n[PhantomData] can also be used to express information about unused type\\nparameters.\\n\\n[PhantomData]: https://doc.rust-lang.org/std/marker/struct.PhantomData.html\\n\")),\n  (\"E0393\",\n   Some(\"A type parameter which references `Self` in its default value was not specified.\\n\\nErroneous code example:\\n\\n```compile_fail,E0393\\ntrait A<T=Self> {}\\n\\nfn together_we_will_rule_the_galaxy(son: &A) {}\\n// error: the type parameter `T` must be explicitly specified in an\\n//        object type because its default value `Self` references the\\n//        type `Self`\\n```\\n\\nA trait object is defined over a single, fully-defined trait. With a regular\\ndefault parameter, this parameter can just be substituted in. However, if the\\ndefault parameter is `Self`, the trait changes for each concrete type; i.e.\\n`i32` will be expected to implement `A<i32>`, `bool` will be expected to\\nimplement `A<bool>`, etc... These types will not share an implementation of a\\nfully-defined trait; instead they share implementations of a trait with\\ndifferent parameters substituted in for each implementation. This is\\nirreconcilable with what we need to make a trait object work, and is thus\\ndisallowed. Making the trait concrete by explicitly specifying the value of the\\ndefaulted parameter will fix this issue. Fixed example:\\n\\n```\\ntrait A<T=Self> {}\\n\\nfn together_we_will_rule_the_galaxy(son: &A<i32>) {} // Ok!\\n```\\n\")),\n  (\"E0398\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nIn Rust 1.3, the default object lifetime bounds are expected to change, as\\ndescribed in [RFC 1156]. You are getting a warning because the compiler\\nthinks it is possible that this change will cause a compilation error in your\\ncode. It is possible, though unlikely, that this is a false alarm.\\n\\nThe heart of the change is that where `&\\'a Box<SomeTrait>` used to default to\\n`&\\'a Box<SomeTrait+\\'a>`, it now defaults to `&\\'a Box<SomeTrait+\\'static>` (here,\\n`SomeTrait` is the name of some trait type). Note that the only types which are\\naffected are references to boxes, like `&Box<SomeTrait>` or\\n`&[Box<SomeTrait>]`. More common types like `&SomeTrait` or `Box<SomeTrait>`\\nare unaffected.\\n\\nTo silence this warning, edit your code to use an explicit bound. Most of the\\ntime, this means that you will want to change the signature of a function that\\nyou are calling. For example, if the error is reported on a call like `foo(x)`,\\nand `foo` is defined as follows:\\n\\n```\\n# trait SomeTrait {}\\nfn foo(arg: &Box<SomeTrait>) { /* ... */ }\\n```\\n\\nYou might change it to:\\n\\n```\\n# trait SomeTrait {}\\nfn foo<\\'a>(arg: &\\'a Box<SomeTrait+\\'a>) { /* ... */ }\\n```\\n\\nThis explicitly states that you expect the trait object `SomeTrait` to contain\\nreferences (with a maximum lifetime of `\\'a`).\\n\\n[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md\\n\")),\n  (\"E0399\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler\\n\\nYou implemented a trait, overriding one or more of its associated types but did\\nnot reimplement its default methods.\\n\\nExample of erroneous code:\\n\\n```\\n#![feature(associated_type_defaults)]\\n\\npub trait Foo {\\n    type Assoc = u8;\\n    fn bar(&self) {}\\n}\\n\\nimpl Foo for i32 {\\n    // error - the following trait items need to be reimplemented as\\n    //         `Assoc` was overridden: `bar`\\n    type Assoc = i32;\\n}\\n```\\n\\nTo fix this, add an implementation for each default method from the trait:\\n\\n```\\n#![feature(associated_type_defaults)]\\n\\npub trait Foo {\\n    type Assoc = u8;\\n    fn bar(&self) {}\\n}\\n\\nimpl Foo for i32 {\\n    type Assoc = i32;\\n    fn bar(&self) {} // ok!\\n}\\n```\\n\")),\n  (\"E0401\",\n   Some(\"Inner items do not inherit type or const parameters from the functions\\nthey are embedded in.\\n\\nErroneous code example:\\n\\n```compile_fail,E0401\\nfn foo<T>(x: T) {\\n    fn bar(y: T) { // T is defined in the \\\"outer\\\" function\\n        // ..\\n    }\\n    bar(x);\\n}\\n```\\n\\nNor will this:\\n\\n```compile_fail,E0401\\nfn foo<T>(x: T) {\\n    type MaybeT = Option<T>;\\n    // ...\\n}\\n```\\n\\nOr this:\\n\\n```compile_fail,E0401\\nfn foo<T>(x: T) {\\n    struct Foo {\\n        x: T,\\n    }\\n    // ...\\n}\\n```\\n\\nItems inside functions are basically just like top-level items, except\\nthat they can only be used from the function they are in.\\n\\nThere are a couple of solutions for this.\\n\\nIf the item is a function, you may use a closure:\\n\\n```\\nfn foo<T>(x: T) {\\n    let bar = |y: T| { // explicit type annotation may not be necessary\\n        // ..\\n    };\\n    bar(x);\\n}\\n```\\n\\nFor a generic item, you can copy over the parameters:\\n\\n```\\nfn foo<T>(x: T) {\\n    fn bar<T>(y: T) {\\n        // ..\\n    }\\n    bar(x);\\n}\\n```\\n\\n```\\nfn foo<T>(x: T) {\\n    type MaybeT<T> = Option<T>;\\n}\\n```\\n\\nBe sure to copy over any bounds as well:\\n\\n```\\nfn foo<T: Copy>(x: T) {\\n    fn bar<T: Copy>(y: T) {\\n        // ..\\n    }\\n    bar(x);\\n}\\n```\\n\\n```\\nfn foo<T: Copy>(x: T) {\\n    struct Foo<T: Copy> {\\n        x: T,\\n    }\\n}\\n```\\n\\nThis may require additional type hints in the function body.\\n\\nIn case the item is a function inside an `impl`, defining a private helper\\nfunction might be easier:\\n\\n```\\n# struct Foo<T>(T);\\nimpl<T> Foo<T> {\\n    pub fn foo(&self, x: T) {\\n        self.bar(x);\\n    }\\n\\n    fn bar(&self, y: T) {\\n        // ..\\n    }\\n}\\n```\\n\\nFor default impls in traits, the private helper solution won\\'t work, however\\nclosures or copying the parameters should still work.\\n\")),\n  (\"E0403\",\n   Some(\"Some type parameters have the same name.\\n\\nErroneous code example:\\n\\n```compile_fail,E0403\\nfn f<T, T>(s: T, u: T) {} // error: the name `T` is already used for a generic\\n                          //        parameter in this item\\'s generic parameters\\n```\\n\\nPlease verify that none of the type parameters are misspelled, and rename any\\nclashing parameters. Example:\\n\\n```\\nfn f<T, Y>(s: T, u: Y) {} // ok!\\n```\\n\\nType parameters in an associated item also cannot shadow parameters from the\\ncontaining item:\\n\\n```compile_fail,E0403\\ntrait Foo<T> {\\n    fn do_something(&self) -> T;\\n    fn do_something_else<T: Clone>(&self, bar: T);\\n}\\n```\\n\")),\n  (\"E0404\",\n   Some(\"A type that is not a trait was used in a trait position, such as a bound\\nor `impl`.\\n\\nErroneous code example:\\n\\n```compile_fail,E0404\\nstruct Foo;\\nstruct Bar;\\n\\nimpl Foo for Bar {} // error: `Foo` is not a trait\\nfn baz<T: Foo>(t: T) {} // error: `Foo` is not a trait\\n```\\n\\nAnother erroneous code example:\\n\\n```compile_fail,E0404\\ntype Foo = Iterator<Item=String>;\\n\\nfn bar<T: Foo>(t: T) {} // error: `Foo` is a type alias\\n```\\n\\nPlease verify that the trait\\'s name was not misspelled or that the right\\nidentifier was used. Example:\\n\\n```\\ntrait Foo {\\n    // some functions\\n}\\nstruct Bar;\\n\\nimpl Foo for Bar { // ok!\\n    // functions implementation\\n}\\n\\nfn baz<T: Foo>(t: T) {} // ok!\\n```\\n\\nAlternatively, you could introduce a new trait with your desired restrictions\\nas a super trait:\\n\\n```\\n# trait Foo {}\\n# struct Bar;\\n# impl Foo for Bar {}\\ntrait Qux: Foo {} // Anything that implements Qux also needs to implement Foo\\nfn baz<T: Qux>(t: T) {} // also ok!\\n```\\n\\nFinally, if you are on nightly and want to use a trait alias\\ninstead of a type alias, you should use `#![feature(trait_alias)]`:\\n\\n```\\n#![feature(trait_alias)]\\ntrait Foo = Iterator<Item=String>;\\n\\nfn bar<T: Foo>(t: T) {} // ok!\\n```\\n\")),\n  (\"E0405\",\n   Some(\"The code refers to a trait that is not in scope.\\n\\nErroneous code example:\\n\\n```compile_fail,E0405\\nstruct Foo;\\n\\nimpl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\\n```\\n\\nPlease verify that the name of the trait wasn\\'t misspelled and ensure that it\\nwas imported. Example:\\n\\n```\\n# #[cfg(for_demonstration_only)]\\n// solution 1:\\nuse some_file::SomeTrait;\\n\\n// solution 2:\\ntrait SomeTrait {\\n    // some functions\\n}\\n\\nstruct Foo;\\n\\nimpl SomeTrait for Foo { // ok!\\n    // implements functions\\n}\\n```\\n\")),\n  (\"E0407\",\n   Some(\"A definition of a method not in the implemented trait was given in a trait\\nimplementation.\\n\\nErroneous code example:\\n\\n```compile_fail,E0407\\ntrait Foo {\\n    fn a();\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    fn a() {}\\n    fn b() {} // error: method `b` is not a member of trait `Foo`\\n}\\n```\\n\\nPlease verify you didn\\'t misspell the method name and you used the correct\\ntrait. First example:\\n\\n```\\ntrait Foo {\\n    fn a();\\n    fn b();\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    fn a() {}\\n    fn b() {} // ok!\\n}\\n```\\n\\nSecond example:\\n\\n```\\ntrait Foo {\\n    fn a();\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    fn a() {}\\n}\\n\\nimpl Bar {\\n    fn b() {}\\n}\\n```\\n\")),\n  (\"E0408\",\n   Some(\"An \\\"or\\\" pattern was used where the variable bindings are not consistently bound\\nacross patterns.\\n\\nErroneous code example:\\n\\n```compile_fail,E0408\\nmatch x {\\n    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is\\n                                      //        not bound in pattern #2\\n    _ => ()\\n}\\n```\\n\\nHere, `y` is bound to the contents of the `Some` and can be used within the\\nblock corresponding to the match arm. However, in case `x` is `None`, we have\\nnot specified what `y` is, and the block will use a nonexistent variable.\\n\\nTo fix this error, either split into multiple match arms:\\n\\n```\\nlet x = Some(1);\\nmatch x {\\n    Some(y) => { /* use y */ }\\n    None => { /* ... */ }\\n}\\n```\\n\\nor, bind the variable to a field of the same type in all sub-patterns of the\\nor pattern:\\n\\n```\\nlet x = (0, 2);\\nmatch x {\\n    (0, y) | (y, 0) => { /* use y */}\\n    _ => {}\\n}\\n```\\n\\nIn this example, if `x` matches the pattern `(0, _)`, the second field is set\\nto `y`. If it matches `(_, 0)`, the first field is set to `y`; so in all\\ncases `y` is set to some value.\\n\")),\n  (\"E0409\",\n   Some(\"An \\\"or\\\" pattern was used where the variable bindings are not consistently bound\\nacross patterns.\\n\\nErroneous code example:\\n\\n```compile_fail,E0409\\nlet x = (0, 2);\\nmatch x {\\n    (0, ref y) | (y, 0) => { /* use y */} // error: variable `y` is bound with\\n                                          //        different mode in pattern #2\\n                                          //        than in pattern #1\\n    _ => ()\\n}\\n```\\n\\nHere, `y` is bound by-value in one case and by-reference in the other.\\n\\nTo fix this error, just use the same mode in both cases.\\nGenerally using `ref` or `ref mut` where not already used will fix this:\\n\\n```\\nlet x = (0, 2);\\nmatch x {\\n    (0, ref y) | (ref y, 0) => { /* use y */}\\n    _ => ()\\n}\\n```\\n\\nAlternatively, split the pattern:\\n\\n```\\nlet x = (0, 2);\\nmatch x {\\n    (y, 0) => { /* use y */ }\\n    (0, ref y) => { /* use y */}\\n    _ => ()\\n}\\n```\\n\")),\n  (\"E0411\",\n   Some(\"The `Self` keyword was used outside an impl, trait, or type definition.\\n\\nErroneous code example:\\n\\n```compile_fail,E0411\\n<Self>::foo; // error: use of `Self` outside of an impl, trait, or type\\n             // definition\\n```\\n\\nThe `Self` keyword represents the current type, which explains why it can only\\nbe used inside an impl, trait, or type definition. It gives access to the\\nassociated items of a type:\\n\\n```\\ntrait Foo {\\n    type Bar;\\n}\\n\\ntrait Baz : Foo {\\n    fn bar() -> Self::Bar; // like this\\n}\\n```\\n\\nHowever, be careful when two types have a common associated type:\\n\\n```compile_fail\\ntrait Foo {\\n    type Bar;\\n}\\n\\ntrait Foo2 {\\n    type Bar;\\n}\\n\\ntrait Baz : Foo + Foo2 {\\n    fn bar() -> Self::Bar;\\n    // error: ambiguous associated type `Bar` in bounds of `Self`\\n}\\n```\\n\\nThis problem can be solved by specifying from which trait we want to use the\\n`Bar` type:\\n\\n```\\ntrait Foo {\\n    type Bar;\\n}\\n\\ntrait Foo2 {\\n    type Bar;\\n}\\n\\ntrait Baz : Foo + Foo2 {\\n    fn bar() -> <Self as Foo>::Bar; // ok!\\n}\\n```\\n\")),\n  (\"E0412\",\n   Some(\"A used type name is not in scope.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0412\\nimpl Something {} // error: type name `Something` is not in scope\\n\\n// or:\\n\\ntrait Foo {\\n    fn bar(N); // error: type name `N` is not in scope\\n}\\n\\n// or:\\n\\nfn foo(x: T) {} // type name `T` is not in scope\\n```\\n\\nTo fix this error, please verify you didn\\'t misspell the type name, you did\\ndeclare it or imported it into the scope. Examples:\\n\\n```\\nstruct Something;\\n\\nimpl Something {} // ok!\\n\\n// or:\\n\\ntrait Foo {\\n    type N;\\n\\n    fn bar(_: Self::N); // ok!\\n}\\n\\n// or:\\n\\nfn foo<T>(x: T) {} // ok!\\n```\\n\\nAnother case that causes this error is when a type is imported into a parent\\nmodule. To fix this, you can follow the suggestion and use File directly or\\n`use super::File;` which will import the types from the parent namespace. An\\nexample that causes this error is below:\\n\\n```compile_fail,E0412\\nuse std::fs::File;\\n\\nmod foo {\\n    fn some_function(f: File) {}\\n}\\n```\\n\\n```\\nuse std::fs::File;\\n\\nmod foo {\\n    // either\\n    use super::File;\\n    // or\\n    // use std::fs::File;\\n    fn foo(f: File) {}\\n}\\n# fn main() {} // don\\'t insert it for us; that\\'ll break imports\\n```\\n\")),\n  (\"E0415\",\n   Some(\"More than one function parameter have the same name.\\n\\nErroneous code example:\\n\\n```compile_fail,E0415\\nfn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than\\n                          //        once in this parameter list\\n```\\n\\nPlease verify you didn\\'t misspell parameters\\' name. Example:\\n\\n```\\nfn foo(f: i32, g: i32) {} // ok!\\n```\\n\")),\n  (\"E0416\",\n   Some(\"An identifier is bound more than once in a pattern.\\n\\nErroneous code example:\\n\\n```compile_fail,E0416\\nmatch (1, 2) {\\n    (x, x) => {} // error: identifier `x` is bound more than once in the\\n                 //        same pattern\\n}\\n```\\n\\nPlease verify you didn\\'t misspell identifiers\\' name. Example:\\n\\n```\\nmatch (1, 2) {\\n    (x, y) => {} // ok!\\n}\\n```\\n\\nOr maybe did you mean to unify? Consider using a guard:\\n\\n```\\n# let (A, B, C) = (1, 2, 3);\\nmatch (A, B, C) {\\n    (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }\\n    (y, z, see) => { /* A and B unequal; do another thing */ }\\n}\\n```\\n\")),\n  (\"E0422\",\n   Some(\"An identifier that is neither defined nor a struct was used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0422\\nfn main () {\\n    let x = Foo { x: 1, y: 2 };\\n}\\n```\\n\\nIn this case, `Foo` is undefined, so it inherently isn\\'t anything, and\\ndefinitely not a struct.\\n\\n```compile_fail\\nfn main () {\\n    let foo = 1;\\n    let x = foo { x: 1, y: 2 };\\n}\\n```\\n\\nIn this case, `foo` is defined, but is not a struct, so Rust can\\'t use it as\\none.\\n\")),\n  (\"E0423\",\n   Some(\"An identifier was used like a function name or a value was expected and the\\nidentifier exists but it belongs to a different namespace.\\n\\nErroneous code example:\\n\\n```compile_fail,E0423\\nstruct Foo { a: bool };\\n\\nlet f = Foo();\\n// error: expected function, tuple struct or tuple variant, found `Foo`\\n// `Foo` is a struct name, but this expression uses it like a function name\\n```\\n\\nPlease verify you didn\\'t misspell the name of what you actually wanted to use\\nhere. Example:\\n\\n```\\nfn Foo() -> u32 { 0 }\\n\\nlet f = Foo(); // ok!\\n```\\n\\nIt is common to forget the trailing `!` on macro invocations, which would also\\nyield this error:\\n\\n```compile_fail,E0423\\nprintln(\\\"\\\");\\n// error: expected function, tuple struct or tuple variant,\\n// found macro `println`\\n// did you mean `println!(...)`? (notice the trailing `!`)\\n```\\n\\nAnother case where this error is emitted is when a value is expected, but\\nsomething else is found:\\n\\n```compile_fail,E0423\\npub mod a {\\n    pub const I: i32 = 1;\\n}\\n\\nfn h1() -> i32 {\\n    a.I\\n    //~^ ERROR expected value, found module `a`\\n    // did you mean `a::I`?\\n}\\n```\\n\")),\n  (\"E0424\",\n   Some(\"The `self` keyword was used inside of an associated function without a \\\"`self`\\nreceiver\\\" parameter.\\n\\nErroneous code example:\\n\\n```compile_fail,E0424\\nstruct Foo;\\n\\nimpl Foo {\\n    // `bar` is a method, because it has a receiver parameter.\\n    fn bar(&self) {}\\n\\n    // `foo` is not a method, because it has no receiver parameter.\\n    fn foo() {\\n        self.bar(); // error: `self` value is a keyword only available in\\n                    //        methods with a `self` parameter\\n    }\\n}\\n```\\n\\nThe `self` keyword can only be used inside methods, which are associated\\nfunctions (functions defined inside of a `trait` or `impl` block) that have a\\n`self` receiver as its first parameter, like `self`, `&self`, `&mut self` or\\n`self: &mut Pin<Self>` (this last one is an example of an [\\\"arbitrary `self`\\ntype\\\"](https://github.com/rust-lang/rust/issues/44874)).\\n\\nCheck if the associated function\\'s parameter list should have contained a `self`\\nreceiver for it to be a method, and add it if so. Example:\\n\\n```\\nstruct Foo;\\n\\nimpl Foo {\\n    fn bar(&self) {}\\n\\n    fn foo(self) { // `foo` is now a method.\\n        self.bar(); // ok!\\n    }\\n}\\n```\\n\")),\n  (\"E0425\",\n   Some(\"An unresolved name was used.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0425\\nsomething_that_doesnt_exist::foo;\\n// error: unresolved name `something_that_doesnt_exist::foo`\\n\\n// or:\\n\\ntrait Foo {\\n    fn bar() {\\n        Self; // error: unresolved name `Self`\\n    }\\n}\\n\\n// or:\\n\\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\\n```\\n\\nPlease verify that the name wasn\\'t misspelled and ensure that the\\nidentifier being referred to is valid for the given situation. Example:\\n\\n```\\nenum something_that_does_exist {\\n    Foo,\\n}\\n```\\n\\nOr:\\n\\n```\\nmod something_that_does_exist {\\n    pub static foo : i32 = 0i32;\\n}\\n\\nsomething_that_does_exist::foo; // ok!\\n```\\n\\nOr:\\n\\n```\\nlet unknown_variable = 12u32;\\nlet x = unknown_variable; // ok!\\n```\\n\\nIf the item is not defined in the current module, it must be imported using a\\n`use` statement, like so:\\n\\n```\\n# mod foo { pub fn bar() {} }\\n# fn main() {\\nuse foo::bar;\\nbar();\\n# }\\n```\\n\\nIf the item you are importing is not defined in some super-module of the\\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\\n\")),\n  (\"E0426\",\n   Some(\"An undeclared label was used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0426\\nloop {\\n    break \\'a; // error: use of undeclared label `\\'a`\\n}\\n```\\n\\nPlease verify you spelled or declared the label correctly. Example:\\n\\n```\\n\\'a: loop {\\n    break \\'a; // ok!\\n}\\n```\\n\")),\n  (\"E0428\",\n   Some(\"A type or module has been defined more than once.\\n\\nErroneous code example:\\n\\n```compile_fail,E0428\\nstruct Bar;\\nstruct Bar; // error: duplicate definition of value `Bar`\\n```\\n\\nPlease verify you didn\\'t misspell the type/module\\'s name or remove/rename the\\nduplicated one. Example:\\n\\n```\\nstruct Bar;\\nstruct Bar2; // ok!\\n```\\n\")),\n  (\"E0429\",\n   Some(\"The `self` keyword cannot appear alone as the last segment in a `use`\\ndeclaration.\\n\\nErroneous code example:\\n\\n```compile_fail,E0429\\nuse std::fmt::self; // error: `self` imports are only allowed within a { } list\\n```\\n\\nTo use a namespace itself in addition to some of its members, `self` may appear\\nas part of a brace-enclosed list of imports:\\n\\n```\\nuse std::fmt::{self, Debug};\\n```\\n\\nIf you only want to import the namespace, do so directly:\\n\\n```\\nuse std::fmt;\\n```\\n\")),\n  (\"E0430\",\n   Some(\"The `self` import appears more than once in the list.\\n\\nErroneous code example:\\n\\n```compile_fail,E0430\\nuse something::{self, self}; // error: `self` import can only appear once in\\n                             //        the list\\n```\\n\\nPlease verify you didn\\'t misspell the import name or remove the duplicated\\n`self` import. Example:\\n\\n```\\n# mod something {}\\n# fn main() {\\nuse something::{self}; // ok!\\n# }\\n```\\n\")),\n  (\"E0431\",\n   Some(\"An invalid `self` import was made.\\n\\nErroneous code example:\\n\\n```compile_fail,E0431\\nuse {self}; // error: `self` import can only appear in an import list with a\\n            //        non-empty prefix\\n```\\n\\nYou cannot import the current module into itself, please remove this import\\nor verify you didn\\'t misspell it.\\n\")),\n  (\"E0432\",\n   Some(\"An import was unresolved.\\n\\nErroneous code example:\\n\\n```compile_fail,E0432\\nuse something::Foo; // error: unresolved import `something::Foo`.\\n```\\n\\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\\nimport items relative to the current and parent modules, use the `self::` and\\n`super::` prefixes, respectively.\\n\\nIn Rust 2018, paths in `use` statements are relative to the current module\\nunless they begin with the name of a crate or a literal `crate::`, in which\\ncase they start from the crate root. As in Rust 2015 code, the `self::` and\\n`super::` prefixes refer to the current and parent modules respectively.\\n\\nAlso verify that you didn\\'t misspell the import name and that the import exists\\nin the module from where you tried to import it. Example:\\n\\n```\\nuse self::something::Foo; // Ok.\\n\\nmod something {\\n    pub struct Foo;\\n}\\n# fn main() {}\\n```\\n\\nIf you tried to use a module from an external crate and are using Rust 2015,\\nyou may have missed the `extern crate` declaration (which is usually placed in\\nthe crate root):\\n\\n```edition2015\\nextern crate core; // Required to use the `core` crate in Rust 2015.\\n\\nuse core::any;\\n# fn main() {}\\n```\\n\\nIn Rust 2018 the `extern crate` declaration is not required and you can instead\\njust `use` it:\\n\\n```edition2018\\nuse core::any; // No extern crate required in Rust 2018.\\n# fn main() {}\\n```\\n\")),\n  (\"E0433\",\n   Some(\"An undeclared crate, module, or type was used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0433\\nlet map = HashMap::new();\\n// error: failed to resolve: use of undeclared type `HashMap`\\n```\\n\\nPlease verify you didn\\'t misspell the type/module\\'s name or that you didn\\'t\\nforget to import it:\\n\\n```\\nuse std::collections::HashMap; // HashMap has been imported.\\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\\n```\\n\\nIf you\\'ve expected to use a crate name:\\n\\n```compile_fail\\nuse ferris_wheel::BigO;\\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\\n```\\n\\nMake sure the crate has been added as a dependency in `Cargo.toml`.\\n\\nTo use a module from your current crate, add the `crate::` prefix to the path.\\n\")),\n  (\"E0434\",\n   Some(\"A variable used inside an inner function comes from a dynamic environment.\\n\\nErroneous code example:\\n\\n```compile_fail,E0434\\nfn foo() {\\n    let y = 5;\\n    fn bar() -> u32 {\\n        y // error: can\\'t capture dynamic environment in a fn item; use the\\n          //        || { ... } closure form instead.\\n    }\\n}\\n```\\n\\nInner functions do not have access to their containing environment. To fix this\\nerror, you can replace the function with a closure:\\n\\n```\\nfn foo() {\\n    let y = 5;\\n    let bar = || {\\n        y\\n    };\\n}\\n```\\n\\nOr replace the captured variable with a constant or a static item:\\n\\n```\\nfn foo() {\\n    static mut X: u32 = 4;\\n    const Y: u32 = 5;\\n    fn bar() -> u32 {\\n        unsafe {\\n            X = 3;\\n        }\\n        Y\\n    }\\n}\\n```\\n\")),\n  (\"E0435\",\n   Some(\"A non-constant value was used in a constant expression.\\n\\nErroneous code example:\\n\\n```compile_fail,E0435\\nlet foo = 42;\\nlet a: [u8; foo]; // error: attempt to use a non-constant value in a constant\\n```\\n\\n\\'constant\\' means \\'a compile-time value\\'.\\n\\nMore details can be found in the [Variables and Mutability] section of the book.\\n\\n[Variables and Mutability]: https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants\\n\\nTo fix this error, please replace the value with a constant. Example:\\n\\n```\\nlet a: [u8; 42]; // ok!\\n```\\n\\nOr:\\n\\n```\\nconst FOO: usize = 42;\\nlet a: [u8; FOO]; // ok!\\n```\\n\")),\n  (\"E0436\",\n   Some(\"The functional record update syntax was used on something other than a struct.\\n\\nErroneous code example:\\n\\n```compile_fail,E0436\\nenum PublicationFrequency {\\n    Weekly,\\n    SemiMonthly { days: (u8, u8), annual_special: bool },\\n}\\n\\nfn one_up_competitor(competitor_frequency: PublicationFrequency)\\n                     -> PublicationFrequency {\\n    match competitor_frequency {\\n        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {\\n            days: (1, 15), annual_special: false\\n        },\\n        c @ PublicationFrequency::SemiMonthly{ .. } =>\\n            PublicationFrequency::SemiMonthly {\\n                annual_special: true, ..c // error: functional record update\\n                                          //        syntax requires a struct\\n        }\\n    }\\n}\\n```\\n\\nThe functional record update syntax is only allowed for structs (struct-like\\nenum variants don\\'t qualify, for example). To fix the previous code, rewrite the\\nexpression without functional record update syntax:\\n\\n```\\nenum PublicationFrequency {\\n    Weekly,\\n    SemiMonthly { days: (u8, u8), annual_special: bool },\\n}\\n\\nfn one_up_competitor(competitor_frequency: PublicationFrequency)\\n                     -> PublicationFrequency {\\n    match competitor_frequency {\\n        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {\\n            days: (1, 15), annual_special: false\\n        },\\n        PublicationFrequency::SemiMonthly{ days, .. } =>\\n            PublicationFrequency::SemiMonthly {\\n                days, annual_special: true // ok!\\n        }\\n    }\\n}\\n```\\n\")),\n  (\"E0437\",\n   Some(\"An associated type whose name does not match any of the associated types\\nin the trait was used when implementing the trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0437\\ntrait Foo {}\\n\\nimpl Foo for i32 {\\n    type Bar = bool;\\n}\\n```\\n\\nTrait implementations can only implement associated types that are members of\\nthe trait in question.\\n\\nThe solution to this problem is to remove the extraneous associated type:\\n\\n```\\ntrait Foo {}\\n\\nimpl Foo for i32 {}\\n```\\n\")),\n  (\"E0438\",\n   Some(\"An associated constant whose name does not match any of the associated constants\\nin the trait was used when implementing the trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0438\\ntrait Foo {}\\n\\nimpl Foo for i32 {\\n    const BAR: bool = true;\\n}\\n```\\n\\nTrait implementations can only implement associated constants that are\\nmembers of the trait in question.\\n\\nThe solution to this problem is to remove the extraneous associated constant:\\n\\n```\\ntrait Foo {}\\n\\nimpl Foo for i32 {}\\n```\\n\")),\n  (\"E0439\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThe length of the platform-intrinsic function `simd_shuffle` wasn\\'t specified.\\n\\nErroneous code example:\\n\\n```ignore (no longer emitted)\\n#![feature(platform_intrinsics)]\\n\\nextern \\\"platform-intrinsic\\\" {\\n    fn simd_shuffle<A,B>(a: A, b: A, c: [u32; 8]) -> B;\\n    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`\\n}\\n```\\n\\nThe `simd_shuffle` function needs the length of the array passed as\\nlast parameter in its name. Example:\\n\\n```\\n#![feature(platform_intrinsics)]\\n\\nextern \\\"platform-intrinsic\\\" {\\n    fn simd_shuffle8<A,B>(a: A, b: A, c: [u32; 8]) -> B;\\n}\\n```\\n\")),\n  (\"E0445\",\n   Some(\"A private trait was used on a public type parameter bound.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0445\\n#![deny(private_in_public)]\\n\\ntrait Foo {\\n    fn dummy(&self) { }\\n}\\n\\npub trait Bar : Foo {} // error: private trait in public interface\\npub struct Bar2<T: Foo>(pub T); // same error\\npub fn foo<T: Foo> (t: T) {} // same error\\n\\nfn main() {}\\n```\\n\\nTo solve this error, please ensure that the trait is also public. The trait\\ncan be made inaccessible if necessary by placing it into a private inner\\nmodule, but it still has to be marked with `pub`. Example:\\n\\n```\\npub trait Foo { // we set the Foo trait public\\n    fn dummy(&self) { }\\n}\\n\\npub trait Bar : Foo {} // ok!\\npub struct Bar2<T: Foo>(pub T); // ok!\\npub fn foo<T: Foo> (t: T) {} // ok!\\n\\nfn main() {}\\n```\\n\")),\n  (\"E0446\",\n   Some(\"A private type was used in a public type signature.\\n\\nErroneous code example:\\n\\n```compile_fail,E0446\\n#![deny(private_in_public)]\\nstruct Bar(u32);\\n\\nmod foo {\\n    use crate::Bar;\\n    pub fn bar() -> Bar { // error: private type in public interface\\n        Bar(0)\\n    }\\n}\\n\\nfn main() {}\\n```\\n\\nThere are two ways to solve this error. The first is to make the public type\\nsignature only public to a module that also has access to the private type.\\nThis is done by using pub(crate) or pub(in crate::my_mod::etc)\\nExample:\\n\\n```\\nstruct Bar(u32);\\n\\nmod foo {\\n    use crate::Bar;\\n    pub(crate) fn bar() -> Bar { // only public to crate root\\n        Bar(0)\\n    }\\n}\\n\\nfn main() {}\\n```\\n\\nThe other way to solve this error is to make the private type public.\\nExample:\\n\\n```\\npub struct Bar(u32); // we set the Bar type public\\nmod foo {\\n    use crate::Bar;\\n    pub fn bar() -> Bar { // ok!\\n        Bar(0)\\n    }\\n}\\n\\nfn main() {}\\n```\\n\")),\n  (\"E0447\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThe `pub` keyword was used inside a function.\\n\\nErroneous code example:\\n\\n```\\nfn foo() {\\n    pub struct Bar; // error: visibility has no effect inside functions\\n}\\n```\\n\\nSince we cannot access items defined inside a function, the visibility of its\\nitems does not impact outer code. So using the `pub` keyword in this context\\nis invalid.\\n\")),\n  (\"E0448\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThe `pub` keyword was used inside a public enum.\\n\\nErroneous code example:\\n\\n```compile_fail\\npub enum Foo {\\n    pub Bar, // error: unnecessary `pub` visibility\\n}\\n```\\n\\nSince the enum is already public, adding `pub` on one its elements is\\nunnecessary. Example:\\n\\n```compile_fail\\nenum Foo {\\n    pub Bar, // not ok!\\n}\\n```\\n\\nThis is the correct syntax:\\n\\n```\\npub enum Foo {\\n    Bar, // ok!\\n}\\n```\\n\")),\n  (\"E0449\",\n   Some(\"A visibility qualifier was used when it was unnecessary.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0449\\nstruct Bar;\\n\\ntrait Foo {\\n    fn foo();\\n}\\n\\npub impl Bar {} // error: unnecessary visibility qualifier\\n\\npub impl Foo for Bar { // error: unnecessary visibility qualifier\\n    pub fn foo() {} // error: unnecessary visibility qualifier\\n}\\n```\\n\\nTo fix this error, please remove the visibility qualifier when it is not\\nrequired. Example:\\n\\n```\\nstruct Bar;\\n\\ntrait Foo {\\n    fn foo();\\n}\\n\\n// Directly implemented methods share the visibility of the type itself,\\n// so `pub` is unnecessary here\\nimpl Bar {}\\n\\n// Trait methods share the visibility of the trait, so `pub` is\\n// unnecessary in either case\\nimpl Foo for Bar {\\n    fn foo() {}\\n}\\n```\\n\")),\n  (\"E0451\",\n   Some(\"A struct constructor with private fields was invoked.\\n\\nErroneous code example:\\n\\n```compile_fail,E0451\\nmod Bar {\\n    pub struct Foo {\\n        pub a: isize,\\n        b: isize,\\n    }\\n}\\n\\nlet f = Bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `Bar::Foo`\\n                                //        is private\\n```\\n\\nTo fix this error, please ensure that all the fields of the struct are public,\\nor implement a function for easy instantiation. Examples:\\n\\n```\\nmod Bar {\\n    pub struct Foo {\\n        pub a: isize,\\n        pub b: isize, // we set `b` field public\\n    }\\n}\\n\\nlet f = Bar::Foo{ a: 0, b: 0 }; // ok!\\n```\\n\\nOr:\\n\\n```\\nmod Bar {\\n    pub struct Foo {\\n        pub a: isize,\\n        b: isize, // still private\\n    }\\n\\n    impl Foo {\\n        pub fn new() -> Foo { // we create a method to instantiate `Foo`\\n            Foo { a: 0, b: 0 }\\n        }\\n    }\\n}\\n\\nlet f = Bar::Foo::new(); // ok!\\n```\\n\")),\n  (\"E0452\",\n   Some(\"An invalid lint attribute has been given.\\n\\nErroneous code example:\\n\\n```compile_fail,E0452\\n#![allow(foo = \\\"\\\")] // error: malformed lint attribute\\n```\\n\\nLint attributes only accept a list of identifiers (where each identifier is a\\nlint name). Ensure the attribute is of this form:\\n\\n```\\n#![allow(foo)] // ok!\\n// or:\\n#![allow(foo, foo2)] // ok!\\n```\\n\")),\n  (\"E0453\",\n   Some(\"A lint check attribute was overruled by a `forbid` directive set as an\\nattribute on an enclosing scope, or on the command line with the `-F` option.\\n\\nExample of erroneous code:\\n\\n```compile_fail,E0453\\n#![forbid(non_snake_case)]\\n\\n#[allow(non_snake_case)]\\nfn main() {\\n    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer\\n                      //        forbid(non_snake_case)\\n}\\n```\\n\\nThe `forbid` lint setting, like `deny`, turns the corresponding compiler\\nwarning into a hard error. Unlike `deny`, `forbid` prevents itself from being\\noverridden by inner attributes.\\n\\nIf you\\'re sure you want to override the lint check, you can change `forbid` to\\n`deny` (or use `-D` instead of `-F` if the `forbid` setting was given as a\\ncommand-line option) to allow the inner lint check attribute:\\n\\n```\\n#![deny(non_snake_case)]\\n\\n#[allow(non_snake_case)]\\nfn main() {\\n    let MyNumber = 2; // ok!\\n}\\n```\\n\\nOtherwise, edit the code to pass the lint check, and remove the overruled\\nattribute:\\n\\n```\\n#![forbid(non_snake_case)]\\n\\nfn main() {\\n    let my_number = 2;\\n}\\n```\\n\")),\n  (\"E0454\",\n   Some(\"A link name was given with an empty name.\\n\\nErroneous code example:\\n\\n```compile_fail,E0454\\n#[link(name = \\\"\\\")] extern \\\"C\\\" {}\\n// error: `#[link(name = \\\"\\\")]` given with empty name\\n```\\n\\nThe rust compiler cannot link to an external library if you don\\'t give it its\\nname. Example:\\n\\n```no_run\\n#[link(name = \\\"some_lib\\\")] extern \\\"C\\\" {} // ok!\\n```\\n\")),\n  (\"E0455\",\n   Some(\"Linking with `kind=framework` is only supported when targeting macOS,\\nas frameworks are specific to that operating system.\\n\\nErroneous code example:\\n\\n```ignore (should-compile_fail-but-cannot-doctest-conditionally-without-macos)\\n#[link(name = \\\"FooCoreServices\\\", kind = \\\"framework\\\")] extern \\\"C\\\" {}\\n// OS used to compile is Linux for example\\n```\\n\\nTo solve this error you can use conditional compilation:\\n\\n```\\n#[cfg_attr(target=\\\"macos\\\", link(name = \\\"FooCoreServices\\\", kind = \\\"framework\\\"))]\\nextern \\\"C\\\" {}\\n```\\n\\nLearn more in the [Conditional Compilation][conditional-compilation] section\\nof the Reference.\\n\\n[conditional-compilation]: https://doc.rust-lang.org/reference/attributes.html#conditional-compilation\\n\")),\n  (\"E0458\",\n   Some(\"An unknown \\\"kind\\\" was specified for a link attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0458\\n#[link(kind = \\\"wonderful_unicorn\\\")] extern \\\"C\\\" {}\\n// error: unknown kind: `wonderful_unicorn`\\n```\\n\\nPlease specify a valid \\\"kind\\\" value, from one of the following:\\n\\n* static\\n* dylib\\n* framework\\n\")),\n  (\"E0459\",\n   Some(\"A link was used without a name parameter.\\n\\nErroneous code example:\\n\\n```compile_fail,E0459\\n#[link(kind = \\\"dylib\\\")] extern \\\"C\\\" {}\\n// error: `#[link(...)]` specified without `name = \\\"foo\\\"`\\n```\\n\\nPlease add the name parameter to allow the rust compiler to find the library\\nyou want. Example:\\n\\n```no_run\\n#[link(kind = \\\"dylib\\\", name = \\\"some_lib\\\")] extern \\\"C\\\" {} // ok!\\n```\\n\")),\n  (\"E0463\",\n   Some(\"A plugin/crate was declared but cannot be found.\\n\\nErroneous code example:\\n\\n```compile_fail,E0463\\n#![feature(plugin)]\\n#![plugin(cookie_monster)] // error: can\\'t find crate for `cookie_monster`\\nextern crate cake_is_a_lie; // error: can\\'t find crate for `cake_is_a_lie`\\n```\\n\\nYou need to link your code to the relevant crate in order to be able to use it\\n(through Cargo or the `-L` option of rustc example). Plugins are crates as\\nwell, and you link to them the same way.\\n\\n## Common causes\\n\\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\\n  in Cargo.toml.\\n- The crate is present, but under a different name. If using Cargo, look for\\n  `package = ` under `[dependencies]` in Cargo.toml.\\n\\n## Common causes for missing `std` or `core`\\n\\n- You are cross-compiling for a target which doesn\\'t have `std` prepackaged.\\n  Consider one of the following:\\n  + Adding a pre-compiled version of std with `rustup target add`\\n  + Building std from source with `cargo build -Z build-std`\\n  + Using `#![no_std]` at the crate root, so you won\\'t need `std` in the first\\n    place.\\n- You are developing the compiler itself and haven\\'t built libstd from source.\\n  You can usually build it with `x.py build library/std`. More information\\n  about x.py is available in the [rustc-dev-guide].\\n\\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\\n\")),\n  (\"E0464\",\n   Some(\"The compiler found multiple library files with the requested crate name.\\n\\nThis error can occur in several different cases -- for example, when using\\n`extern crate` or passing `--extern` options without crate paths. It can also be\\ncaused by caching issues with the build directory, in which case `cargo clean`\\nmay help.\\n\")),\n  (\"E0466\",\n   Some(\"Macro import declaration was malformed.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0466\\n#[macro_use(a_macro(another_macro))] // error: invalid import declaration\\nextern crate core as some_crate;\\n\\n#[macro_use(i_want = \\\"some_macros\\\")] // error: invalid import declaration\\nextern crate core as another_crate;\\n```\\n\\nThis is a syntax error at the level of attribute declarations. The proper\\nsyntax for macro imports is the following:\\n\\n```ignore (cannot-doctest-multicrate-project)\\n// In some_crate:\\n#[macro_export]\\nmacro_rules! get_tacos {\\n    ...\\n}\\n\\n#[macro_export]\\nmacro_rules! get_pimientos {\\n    ...\\n}\\n\\n// In your crate:\\n#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and\\nextern crate some_crate;               // `get_pimientos` macros from some_crate\\n```\\n\\nIf you would like to import all exported macros, write `macro_use` with no\\narguments.\\n\")),\n  (\"E0468\",\n   Some(\"A non-root module tried to import macros from another crate.\\n\\nExample of erroneous code:\\n\\n```compile_fail,E0468\\nmod foo {\\n    #[macro_use(debug_assert)]  // error: must be at crate root to import\\n    extern crate core;          //        macros from another crate\\n    fn run_macro() { debug_assert!(true); }\\n}\\n```\\n\\nOnly `extern crate` imports at the crate root level are allowed to import\\nmacros.\\n\\nEither move the macro import to crate root or do without the foreign macros.\\nThis will work:\\n\\n```\\n#[macro_use(debug_assert)] // ok!\\nextern crate core;\\n\\nmod foo {\\n    fn run_macro() { debug_assert!(true); }\\n}\\n# fn main() {}\\n```\\n\")),\n  (\"E0469\",\n   Some(\"A macro listed for import was not found.\\n\\nErroneous code example:\\n\\n```compile_fail,E0469\\n#[macro_use(drink, be_merry)] // error: imported macro not found\\nextern crate alloc;\\n\\nfn main() {\\n    // ...\\n}\\n```\\n\\nEither the listed macro is not contained in the imported crate, or it is not\\nexported from the given crate.\\n\\nThis could be caused by a typo. Did you misspell the macro\\'s name?\\n\\nDouble-check the names of the macros listed for import, and that the crate\\nin question exports them.\\n\\nA working version would be:\\n\\n```ignore (cannot-doctest-multicrate-project)\\n// In some_crate crate:\\n#[macro_export]\\nmacro_rules! eat {\\n    ...\\n}\\n\\n#[macro_export]\\nmacro_rules! drink {\\n    ...\\n}\\n\\n// In your crate:\\n#[macro_use(eat, drink)]\\nextern crate some_crate; //ok!\\n```\\n\")),\n  (\"E0477\",\n   Some(\"The type does not fulfill the required lifetime.\\n\\nErroneous code example:\\n\\n```compile_fail,E0477\\nuse std::sync::Mutex;\\n\\nstruct MyString<\\'a> {\\n    data: &\\'a str,\\n}\\n\\nfn i_want_static_closure<F>(a: F)\\n    where F: Fn() + \\'static {}\\n\\nfn print_string<\\'a>(s: Mutex<MyString<\\'a>>) {\\n\\n    i_want_static_closure(move || {     // error: this closure has lifetime \\'a\\n                                        //        rather than \\'static\\n        println!(\\\"{}\\\", s.lock().unwrap().data);\\n    });\\n}\\n```\\n\\nIn this example, the closure does not satisfy the `\\'static` lifetime constraint.\\nTo fix this error, you need to double check the lifetime of the type. Here, we\\ncan fix this problem by giving `s` a static lifetime:\\n\\n```\\nuse std::sync::Mutex;\\n\\nstruct MyString<\\'a> {\\n    data: &\\'a str,\\n}\\n\\nfn i_want_static_closure<F>(a: F)\\n    where F: Fn() + \\'static {}\\n\\nfn print_string(s: Mutex<MyString<\\'static>>) {\\n\\n    i_want_static_closure(move || {     // ok!\\n        println!(\\\"{}\\\", s.lock().unwrap().data);\\n    });\\n}\\n```\\n\")),\n  (\"E0478\",\n   Some(\"A lifetime bound was not satisfied.\\n\\nErroneous code example:\\n\\n```compile_fail,E0478\\n// Check that the explicit lifetime bound (`\\'SnowWhite`, in this example) must\\n// outlive all the superbounds from the trait (`\\'kiss`, in this example).\\n\\ntrait Wedding<\\'t>: \\'t { }\\n\\nstruct Prince<\\'kiss, \\'SnowWhite> {\\n    child: Box<Wedding<\\'kiss> + \\'SnowWhite>,\\n    // error: lifetime bound not satisfied\\n}\\n```\\n\\nIn this example, the `\\'SnowWhite` lifetime is supposed to outlive the `\\'kiss`\\nlifetime but the declaration of the `Prince` struct doesn\\'t enforce it. To fix\\nthis issue, you need to specify it:\\n\\n```\\ntrait Wedding<\\'t>: \\'t { }\\n\\nstruct Prince<\\'kiss, \\'SnowWhite: \\'kiss> { // You say here that \\'SnowWhite\\n                                          // must live longer than \\'kiss.\\n    child: Box<Wedding<\\'kiss> + \\'SnowWhite>, // And now it\\'s all good!\\n}\\n```\\n\")),\n  (\"E0482\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nA lifetime of a returned value does not outlive the function call.\\n\\nErroneous code example:\\n\\n```compile_fail,E0700\\nfn prefix<\\'a>(\\n    words: impl Iterator<Item = &\\'a str>\\n) -> impl Iterator<Item = String> { // error!\\n    words.map(|v| format!(\\\"foo-{}\\\", v))\\n}\\n```\\n\\nTo fix this error, make the lifetime of the returned value explicit:\\n\\n```\\nfn prefix<\\'a>(\\n    words: impl Iterator<Item = &\\'a str> + \\'a\\n) -> impl Iterator<Item = String> + \\'a { // ok!\\n    words.map(|v| format!(\\\"foo-{}\\\", v))\\n}\\n```\\n\\nThe [`impl Trait`] feature in this example uses an implicit `\\'static` lifetime\\nrestriction in the returned type. However the type implementing the `Iterator`\\npassed to the function lives just as long as `\\'a`, which is not long enough.\\n\\nThe solution involves adding lifetime bound to both function argument and\\nthe return value to make sure that the values inside the iterator\\nare not dropped when the function goes out of the scope.\\n\\nAn alternative solution would be to guarantee that the `Item` references\\nin the iterator are alive for the whole lifetime of the program.\\n\\n```\\nfn prefix(\\n    words: impl Iterator<Item = &\\'static str>\\n) -> impl Iterator<Item = String> {  // ok!\\n    words.map(|v| format!(\\\"foo-{}\\\", v))\\n}\\n```\\n\\nA similar lifetime problem might arise when returning closures:\\n\\n```compile_fail,E0700\\nfn foo(\\n    x: &mut Vec<i32>\\n) -> impl FnMut(&mut Vec<i32>) -> &[i32] { // error!\\n    |y| {\\n        y.append(x);\\n        y\\n    }\\n}\\n```\\n\\nAnalogically, a solution here is to use explicit return lifetime\\nand move the ownership of the variable to the closure.\\n\\n```\\nfn foo<\\'a>(\\n    x: &\\'a mut Vec<i32>\\n) -> impl FnMut(&mut Vec<i32>) -> &[i32] + \\'a { // ok!\\n    move |y| {\\n        y.append(x);\\n        y\\n    }\\n}\\n```\\n\\nTo better understand the lifetime treatment in the [`impl Trait`],\\nplease see the [RFC 1951].\\n\\n[`impl Trait`]: https://doc.rust-lang.org/reference/types/impl-trait.html\\n[RFC 1951]: https://rust-lang.github.io/rfcs/1951-expand-impl-trait.html\\n\")),\n  (\"E0491\",\n   Some(\"A reference has a longer lifetime than the data it references.\\n\\nErroneous code example:\\n\\n```compile_fail,E0491\\nstruct Foo<\\'a> {\\n    x: fn(&\\'a i32),\\n}\\n\\ntrait Trait<\\'a, \\'b> {\\n    type Out;\\n}\\n\\nimpl<\\'a, \\'b> Trait<\\'a, \\'b> for usize {\\n    type Out = &\\'a Foo<\\'b>; // error!\\n}\\n```\\n\\nHere, the problem is that the compiler cannot be sure that the `\\'b` lifetime\\nwill live longer than `\\'a`, which should be mandatory in order to be sure that\\n`Trait::Out` will always have a reference pointing to an existing type. So in\\nthis case, we just need to tell the compiler than `\\'b` must outlive `\\'a`:\\n\\n```\\nstruct Foo<\\'a> {\\n    x: fn(&\\'a i32),\\n}\\n\\ntrait Trait<\\'a, \\'b> {\\n    type Out;\\n}\\n\\nimpl<\\'a, \\'b: \\'a> Trait<\\'a, \\'b> for usize { // we added the lifetime enforcement\\n    type Out = &\\'a Foo<\\'b>; // it now works!\\n}\\n```\\n\")),\n  (\"E0492\",\n   Some(\"A borrow of a constant containing interior mutability was attempted.\\n\\nErroneous code example:\\n\\n```compile_fail,E0492\\nuse std::sync::atomic::AtomicUsize;\\n\\nconst A: AtomicUsize = AtomicUsize::new(0);\\nconst B: &\\'static AtomicUsize = &A;\\n// error: cannot borrow a constant which may contain interior mutability,\\n//        create a static instead\\n```\\n\\nA `const` represents a constant value that should never change. If one takes\\na `&` reference to the constant, then one is taking a pointer to some memory\\nlocation containing the value. Normally this is perfectly fine: most values\\ncan\\'t be changed via a shared `&` pointer, but interior mutability would allow\\nit. That is, a constant value could be mutated. On the other hand, a `static` is\\nexplicitly a single memory location, which can be mutated at will.\\n\\nSo, in order to solve this error, use statics which are `Sync`:\\n\\n```\\nuse std::sync::atomic::AtomicUsize;\\n\\nstatic A: AtomicUsize = AtomicUsize::new(0);\\nstatic B: &\\'static AtomicUsize = &A; // ok!\\n```\\n\\nYou can also have this error while using a cell type:\\n\\n```compile_fail,E0492\\nuse std::cell::Cell;\\n\\nconst A: Cell<usize> = Cell::new(1);\\nconst B: &Cell<usize> = &A;\\n// error: cannot borrow a constant which may contain interior mutability,\\n//        create a static instead\\n\\n// or:\\nstruct C { a: Cell<usize> }\\n\\nconst D: C = C { a: Cell::new(1) };\\nconst E: &Cell<usize> = &D.a; // error\\n\\n// or:\\nconst F: &C = &D; // error\\n```\\n\\nThis is because cell types do operations that are not thread-safe. Due to this,\\nthey don\\'t implement Sync and thus can\\'t be placed in statics.\\n\\nHowever, if you still wish to use these types, you can achieve this by an unsafe\\nwrapper:\\n\\n```\\nuse std::cell::Cell;\\nuse std::marker::Sync;\\n\\nstruct NotThreadSafe<T> {\\n    value: Cell<T>,\\n}\\n\\nunsafe impl<T> Sync for NotThreadSafe<T> {}\\n\\nstatic A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\\nstatic B: &\\'static NotThreadSafe<usize> = &A; // ok!\\n```\\n\\nRemember this solution is unsafe! You will have to ensure that accesses to the\\ncell are synchronized.\\n\")),\n  (\"E0493\",\n   Some(\"A value with a custom `Drop` implementation may be dropped during const-eval.\\n\\nErroneous code example:\\n\\n```compile_fail,E0493\\nenum DropType {\\n    A,\\n}\\n\\nimpl Drop for DropType {\\n    fn drop(&mut self) {}\\n}\\n\\nstruct Foo {\\n    field1: DropType,\\n}\\n\\nstatic FOO: Foo = Foo { field1: (DropType::A, DropType::A).1 }; // error!\\n```\\n\\nThe problem here is that if the given type or one of its fields implements the\\n`Drop` trait, this `Drop` implementation cannot be called within a const\\ncontext since it may run arbitrary, non-const-checked code. To prevent this\\nissue, ensure all values with a custom `Drop` implementation escape the\\ninitializer.\\n\\n```\\nenum DropType {\\n    A,\\n}\\n\\nimpl Drop for DropType {\\n    fn drop(&mut self) {}\\n}\\n\\nstruct Foo {\\n    field1: DropType,\\n}\\n\\nstatic FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields\\n                                               // by hand.\\n```\\n\")),\n  (\"E0495\",\n   Some(\"A lifetime cannot be determined in the given situation.\\n\\nErroneous code example:\\n\\n```compile_fail,E0495\\nfn transmute_lifetime<\\'a, \\'b, T>(t: &\\'a (T,)) -> &\\'b T {\\n    match (&t,) { // error!\\n        ((u,),) => u,\\n    }\\n}\\n\\nlet y = Box::new((42,));\\nlet x = transmute_lifetime(&y);\\n```\\n\\nIn this code, you have two ways to solve this issue:\\n 1. Enforce that `\\'a` lives at least as long as `\\'b`.\\n 2. Use the same lifetime requirement for both input and output values.\\n\\nSo for the first solution, you can do it by replacing `\\'a` with `\\'a: \\'b`:\\n\\n```\\nfn transmute_lifetime<\\'a: \\'b, \\'b, T>(t: &\\'a (T,)) -> &\\'b T {\\n    match (&t,) { // ok!\\n        ((u,),) => u,\\n    }\\n}\\n```\\n\\nIn the second you can do it by simply removing `\\'b` so they both use `\\'a`:\\n\\n```\\nfn transmute_lifetime<\\'a, T>(t: &\\'a (T,)) -> &\\'a T {\\n    match (&t,) { // ok!\\n        ((u,),) => u,\\n    }\\n}\\n```\\n\")),\n  (\"E0496\",\n   Some(\"A lifetime name is shadowing another lifetime name.\\n\\nErroneous code example:\\n\\n```compile_fail,E0496\\nstruct Foo<\\'a> {\\n    a: &\\'a i32,\\n}\\n\\nimpl<\\'a> Foo<\\'a> {\\n    fn f<\\'a>(x: &\\'a i32) { // error: lifetime name `\\'a` shadows a lifetime\\n                           //        name that is already in scope\\n    }\\n}\\n```\\n\\nPlease change the name of one of the lifetimes to remove this error. Example:\\n\\n```\\nstruct Foo<\\'a> {\\n    a: &\\'a i32,\\n}\\n\\nimpl<\\'a> Foo<\\'a> {\\n    fn f<\\'b>(x: &\\'b i32) { // ok!\\n    }\\n}\\n\\nfn main() {\\n}\\n```\\n\")),\n  (\"E0497\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nA stability attribute was used outside of the standard library.\\n\\nErroneous code example:\\n\\n```compile_fail\\n#[stable] // error: stability attributes may not be used outside of the\\n          //        standard library\\nfn foo() {}\\n```\\n\\nIt is not possible to use stability attributes outside of the standard library.\\nAlso, for now, it is not possible to write deprecation messages either.\\n\")),\n  (\"E0498\",\n   Some(\"The `plugin` attribute was malformed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0498\\n#![feature(plugin)]\\n#![plugin(foo(args))] // error: invalid argument\\n#![plugin(bar=\\\"test\\\")] // error: invalid argument\\n```\\n\\nThe `#[plugin]` attribute should take a single argument: the name of the plugin.\\n\\nFor example, for the plugin `foo`:\\n\\n```ignore (requires external plugin crate)\\n#![feature(plugin)]\\n#![plugin(foo)] // ok!\\n```\\n\\nSee the [`plugin` feature] section of the Unstable book for more details.\\n\\n[`plugin` feature]: https://doc.rust-lang.org/nightly/unstable-book/language-features/plugin.html\\n\")),\n  (\"E0499\",\n   Some(\"A variable was borrowed as mutable more than once.\\n\\nErroneous code example:\\n\\n```compile_fail,E0499\\nlet mut i = 0;\\nlet mut x = &mut i;\\nlet mut a = &mut i;\\nx;\\n// error: cannot borrow `i` as mutable more than once at a time\\n```\\n\\nPlease note that in Rust, you can either have many immutable references, or one\\nmutable reference. For more details you may want to read the\\n[References & Borrowing][references-and-borrowing] section of the Book.\\n\\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\\n\\nExample:\\n\\n```\\nlet mut i = 0;\\nlet mut x = &mut i; // ok!\\n\\n// or:\\nlet mut i = 0;\\nlet a = &i; // ok!\\nlet b = &i; // still ok!\\nlet c = &i; // still ok!\\nb;\\na;\\n```\\n\")),\n  (\"E0500\",\n   Some(\"A borrowed variable was used by a closure.\\n\\nErroneous code example:\\n\\n```compile_fail,E0500\\nfn you_know_nothing(jon_snow: &mut i32) {\\n    let nights_watch = &jon_snow;\\n    let starks = || {\\n        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\\n                       //        but it is already borrowed\\n    };\\n    println!(\\\"{}\\\", nights_watch);\\n}\\n```\\n\\nIn here, `jon_snow` is already borrowed by the `nights_watch` reference, so it\\ncannot be borrowed by the `starks` closure at the same time. To fix this issue,\\nyou can create the closure after the borrow has ended:\\n\\n```\\nfn you_know_nothing(jon_snow: &mut i32) {\\n    let nights_watch = &jon_snow;\\n    println!(\\\"{}\\\", nights_watch);\\n    let starks = || {\\n        *jon_snow = 3;\\n    };\\n}\\n```\\n\\nOr, if the type implements the `Clone` trait, you can clone it between\\nclosures:\\n\\n```\\nfn you_know_nothing(jon_snow: &mut i32) {\\n    let mut jon_copy = jon_snow.clone();\\n    let starks = || {\\n        *jon_snow = 3;\\n    };\\n    println!(\\\"{}\\\", jon_copy);\\n}\\n```\\n\")),\n  (\"E0501\",\n   Some(\"A mutable variable is used but it is already captured by a closure.\\n\\nErroneous code example:\\n\\n```compile_fail,E0501\\nfn inside_closure(x: &mut i32) {\\n    // Actions which require unique access\\n}\\n\\nfn outside_closure(x: &mut i32) {\\n    // Actions which require unique access\\n}\\n\\nfn foo(a: &mut i32) {\\n    let mut bar = || {\\n        inside_closure(a)\\n    };\\n    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\\n                        //        closure requires unique access.\\n    bar();\\n}\\n```\\n\\nThis error indicates that a mutable variable is used while it is still captured\\nby a closure. Because the closure has borrowed the variable, it is not available\\nuntil the closure goes out of scope.\\n\\nNote that a capture will either move or borrow a variable, but in this\\nsituation, the closure is borrowing the variable. Take a look at the chapter\\non [Capturing][capturing] in Rust By Example for more information.\\n\\n[capturing]: https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html\\n\\nTo fix this error, you can finish using the closure before using the captured\\nvariable:\\n\\n```\\nfn inside_closure(x: &mut i32) {}\\nfn outside_closure(x: &mut i32) {}\\n\\nfn foo(a: &mut i32) {\\n    let mut bar = || {\\n        inside_closure(a)\\n    };\\n    bar();\\n    // borrow on `a` ends.\\n    outside_closure(a); // ok!\\n}\\n```\\n\\nOr you can pass the variable as a parameter to the closure:\\n\\n```\\nfn inside_closure(x: &mut i32) {}\\nfn outside_closure(x: &mut i32) {}\\n\\nfn foo(a: &mut i32) {\\n    let mut bar = |s: &mut i32| {\\n        inside_closure(s)\\n    };\\n    outside_closure(a);\\n    bar(a);\\n}\\n```\\n\\nIt may be possible to define the closure later:\\n\\n```\\nfn inside_closure(x: &mut i32) {}\\nfn outside_closure(x: &mut i32) {}\\n\\nfn foo(a: &mut i32) {\\n    outside_closure(a);\\n    let mut bar = || {\\n        inside_closure(a)\\n    };\\n    bar();\\n}\\n```\\n\")),\n  (\"E0502\",\n   Some(\"A variable already borrowed as immutable was borrowed as mutable.\\n\\nErroneous code example:\\n\\n```compile_fail,E0502\\nfn bar(x: &mut i32) {}\\nfn foo(a: &mut i32) {\\n    let y = &a; // a is borrowed as immutable.\\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\\n            //        as immutable\\n    println!(\\\"{}\\\", y);\\n}\\n```\\n\\nTo fix this error, ensure that you don\\'t have any other references to the\\nvariable before trying to access it mutably:\\n\\n```\\nfn bar(x: &mut i32) {}\\nfn foo(a: &mut i32) {\\n    bar(a);\\n    let y = &a; // ok!\\n    println!(\\\"{}\\\", y);\\n}\\n```\\n\\nFor more information on Rust\\'s ownership system, take a look at the\\n[References & Borrowing][references-and-borrowing] section of the Book.\\n\\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\\n\")),\n  (\"E0503\",\n   Some(\"A value was used after it was mutably borrowed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0503\\nfn main() {\\n    let mut value = 3;\\n    // Create a mutable borrow of `value`.\\n    let borrow = &mut value;\\n    let _sum = value + 1; // error: cannot use `value` because\\n                          //        it was mutably borrowed\\n    println!(\\\"{}\\\", borrow);\\n}\\n```\\n\\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\\nused to calculate `sum`. This is not possible because this would violate\\nRust\\'s mutability rules.\\n\\nYou can fix this error by finishing using the borrow before the next use of\\nthe value:\\n\\n```\\nfn main() {\\n    let mut value = 3;\\n    let borrow = &mut value;\\n    println!(\\\"{}\\\", borrow);\\n    // The block has ended and with it the borrow.\\n    // You can now use `value` again.\\n    let _sum = value + 1;\\n}\\n```\\n\\nOr by cloning `value` before borrowing it:\\n\\n```\\nfn main() {\\n    let mut value = 3;\\n    // We clone `value`, creating a copy.\\n    let value_cloned = value.clone();\\n    // The mutable borrow is a reference to `value` and\\n    // not to `value_cloned`...\\n    let borrow = &mut value;\\n    // ... which means we can still use `value_cloned`,\\n    let _sum = value_cloned + 1;\\n    // even though the borrow only ends here.\\n    println!(\\\"{}\\\", borrow);\\n}\\n```\\n\\nFor more information on Rust\\'s ownership system, take a look at the\\n[References & Borrowing][references-and-borrowing] section of the Book.\\n\\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\\n\")),\n  (\"E0504\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThis error occurs when an attempt is made to move a borrowed variable into a\\nclosure.\\n\\nErroneous code example:\\n\\n```compile_fail\\nstruct FancyNum {\\n    num: u8,\\n}\\n\\nfn main() {\\n    let fancy_num = FancyNum { num: 5 };\\n    let fancy_ref = &fancy_num;\\n\\n    let x = move || {\\n        println!(\\\"child function: {}\\\", fancy_num.num);\\n        // error: cannot move `fancy_num` into closure because it is borrowed\\n    };\\n\\n    x();\\n    println!(\\\"main function: {}\\\", fancy_ref.num);\\n}\\n```\\n\\nHere, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\\nthe closure `x`. There is no way to move a value into a closure while it is\\nborrowed, as that would invalidate the borrow.\\n\\nIf the closure can\\'t outlive the value being moved, try using a reference\\nrather than moving:\\n\\n```\\nstruct FancyNum {\\n    num: u8,\\n}\\n\\nfn main() {\\n    let fancy_num = FancyNum { num: 5 };\\n    let fancy_ref = &fancy_num;\\n\\n    let x = move || {\\n        // fancy_ref is usable here because it doesn\\'t move `fancy_num`\\n        println!(\\\"child function: {}\\\", fancy_ref.num);\\n    };\\n\\n    x();\\n\\n    println!(\\\"main function: {}\\\", fancy_num.num);\\n}\\n```\\n\\nIf the value has to be borrowed and then moved, try limiting the lifetime of\\nthe borrow using a scoped block:\\n\\n```\\nstruct FancyNum {\\n    num: u8,\\n}\\n\\nfn main() {\\n    let fancy_num = FancyNum { num: 5 };\\n\\n    {\\n        let fancy_ref = &fancy_num;\\n        println!(\\\"main function: {}\\\", fancy_ref.num);\\n        // `fancy_ref` goes out of scope here\\n    }\\n\\n    let x = move || {\\n        // `fancy_num` can be moved now (no more references exist)\\n        println!(\\\"child function: {}\\\", fancy_num.num);\\n    };\\n\\n    x();\\n}\\n```\\n\\nIf the lifetime of a reference isn\\'t enough, such as in the case of threading,\\nconsider using an `Arc` to create a reference-counted value:\\n\\n```\\nuse std::sync::Arc;\\nuse std::thread;\\n\\nstruct FancyNum {\\n    num: u8,\\n}\\n\\nfn main() {\\n    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\\n    let fancy_ref2 = fancy_ref1.clone();\\n\\n    let x = thread::spawn(move || {\\n        // `fancy_ref1` can be moved and has a `\\'static` lifetime\\n        println!(\\\"child thread: {}\\\", fancy_ref1.num);\\n    });\\n\\n    x.join().expect(\\\"child thread should finish\\\");\\n    println!(\\\"main thread: {}\\\", fancy_ref2.num);\\n}\\n```\\n\")),\n  (\"E0505\",\n   Some(\"A value was moved out while it was still borrowed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0505\\nstruct Value {}\\n\\nfn borrow(val: &Value) {}\\n\\nfn eat(val: Value) {}\\n\\nfn main() {\\n    let x = Value{};\\n    let _ref_to_val: &Value = &x;\\n    eat(x);\\n    borrow(_ref_to_val);\\n}\\n```\\n\\nHere, the function `eat` takes ownership of `x`. However,\\n`x` cannot be moved because the borrow to `_ref_to_val`\\nneeds to last till the function `borrow`.\\nTo fix that you can do a few different things:\\n\\n* Try to avoid moving the variable.\\n* Release borrow before move.\\n* Implement the `Copy` trait on the type.\\n\\nExamples:\\n\\n```\\nstruct Value {}\\n\\nfn borrow(val: &Value) {}\\n\\nfn eat(val: &Value) {}\\n\\nfn main() {\\n    let x = Value{};\\n\\n    let ref_to_val: &Value = &x;\\n    eat(&x); // pass by reference, if it\\'s possible\\n    borrow(ref_to_val);\\n}\\n```\\n\\nOr:\\n\\n```\\nstruct Value {}\\n\\nfn borrow(val: &Value) {}\\n\\nfn eat(val: Value) {}\\n\\nfn main() {\\n    let x = Value{};\\n\\n    let ref_to_val: &Value = &x;\\n    borrow(ref_to_val);\\n    // ref_to_val is no longer used.\\n    eat(x);\\n}\\n```\\n\\nOr:\\n\\n```\\n#[derive(Clone, Copy)] // implement Copy trait\\nstruct Value {}\\n\\nfn borrow(val: &Value) {}\\n\\nfn eat(val: Value) {}\\n\\nfn main() {\\n    let x = Value{};\\n    let ref_to_val: &Value = &x;\\n    eat(x); // it will be copied here.\\n    borrow(ref_to_val);\\n}\\n```\\n\\nFor more information on Rust\\'s ownership system, take a look at the\\n[References & Borrowing][references-and-borrowing] section of the Book.\\n\\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\\n\")),\n  (\"E0506\",\n   Some(\"An attempt was made to assign to a borrowed value.\\n\\nErroneous code example:\\n\\n```compile_fail,E0506\\nstruct FancyNum {\\n    num: u8,\\n}\\n\\nlet mut fancy_num = FancyNum { num: 5 };\\nlet fancy_ref = &fancy_num;\\nfancy_num = FancyNum { num: 6 };\\n// error: cannot assign to `fancy_num` because it is borrowed\\n\\nprintln!(\\\"Num: {}, Ref: {}\\\", fancy_num.num, fancy_ref.num);\\n```\\n\\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can\\'t\\nbe assigned to a new value as it would invalidate the reference.\\n\\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\\n\\n```\\nstruct FancyNum {\\n    num: u8,\\n}\\n\\nlet mut fancy_num = FancyNum { num: 5 };\\nlet moved_num = fancy_num;\\nfancy_num = FancyNum { num: 6 };\\n\\nprintln!(\\\"Num: {}, Moved num: {}\\\", fancy_num.num, moved_num.num);\\n```\\n\\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\\na scoped block:\\n\\n```\\nstruct FancyNum {\\n    num: u8,\\n}\\n\\nlet mut fancy_num = FancyNum { num: 5 };\\n\\n{\\n    let fancy_ref = &fancy_num;\\n    println!(\\\"Ref: {}\\\", fancy_ref.num);\\n}\\n\\n// Works because `fancy_ref` is no longer in scope\\nfancy_num = FancyNum { num: 6 };\\nprintln!(\\\"Num: {}\\\", fancy_num.num);\\n```\\n\\nOr by moving the reference into a function:\\n\\n```\\nstruct FancyNum {\\n    num: u8,\\n}\\n\\nfn print_fancy_ref(fancy_ref: &FancyNum){\\n    println!(\\\"Ref: {}\\\", fancy_ref.num);\\n}\\n\\nlet mut fancy_num = FancyNum { num: 5 };\\n\\nprint_fancy_ref(&fancy_num);\\n\\n// Works because function borrow has ended\\nfancy_num = FancyNum { num: 6 };\\nprintln!(\\\"Num: {}\\\", fancy_num.num);\\n```\\n\")),\n  (\"E0507\",\n   Some(\"A borrowed value was moved out.\\n\\nErroneous code example:\\n\\n```compile_fail,E0507\\nuse std::cell::RefCell;\\n\\nstruct TheDarkKnight;\\n\\nimpl TheDarkKnight {\\n    fn nothing_is_true(self) {}\\n}\\n\\nfn main() {\\n    let x = RefCell::new(TheDarkKnight);\\n\\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\\n}\\n```\\n\\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\\nyou have three choices:\\n\\n* Try to avoid moving the variable.\\n* Somehow reclaim the ownership.\\n* Implement the `Copy` trait on the type.\\n\\nThis can also happen when using a type implementing `Fn` or `FnMut`, as neither\\nallows moving out of them (they usually represent closures which can be called\\nmore than once). Much of the text following applies equally well to non-`FnOnce`\\nclosure bodies.\\n\\nExamples:\\n\\n```\\nuse std::cell::RefCell;\\n\\nstruct TheDarkKnight;\\n\\nimpl TheDarkKnight {\\n    fn nothing_is_true(&self) {} // First case, we don\\'t take ownership\\n}\\n\\nfn main() {\\n    let x = RefCell::new(TheDarkKnight);\\n\\n    x.borrow().nothing_is_true(); // ok!\\n}\\n```\\n\\nOr:\\n\\n```\\nuse std::cell::RefCell;\\n\\nstruct TheDarkKnight;\\n\\nimpl TheDarkKnight {\\n    fn nothing_is_true(self) {}\\n}\\n\\nfn main() {\\n    let x = RefCell::new(TheDarkKnight);\\n    let x = x.into_inner(); // we get back ownership\\n\\n    x.nothing_is_true(); // ok!\\n}\\n```\\n\\nOr:\\n\\n```\\nuse std::cell::RefCell;\\n\\n#[derive(Clone, Copy)] // we implement the Copy trait\\nstruct TheDarkKnight;\\n\\nimpl TheDarkKnight {\\n    fn nothing_is_true(self) {}\\n}\\n\\nfn main() {\\n    let x = RefCell::new(TheDarkKnight);\\n\\n    x.borrow().nothing_is_true(); // ok!\\n}\\n```\\n\\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\\n\\n```compile_fail,E0507\\nstruct TheDarkKnight;\\n\\nimpl TheDarkKnight {\\n    fn nothing_is_true(self) {}\\n}\\n\\nstruct Batcave {\\n    knight: TheDarkKnight\\n}\\n\\nfn main() {\\n    let mut cave = Batcave {\\n        knight: TheDarkKnight\\n    };\\n    let borrowed = &mut cave;\\n\\n    borrowed.knight.nothing_is_true(); // E0507\\n}\\n```\\n\\nIt is fine only if you put something back. `mem::replace` can be used for that:\\n\\n```\\n# struct TheDarkKnight;\\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\\n# struct Batcave { knight: TheDarkKnight }\\nuse std::mem;\\n\\nlet mut cave = Batcave {\\n    knight: TheDarkKnight\\n};\\nlet borrowed = &mut cave;\\n\\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\\n```\\n\\nFor more information on Rust\\'s ownership system, take a look at the\\n[References & Borrowing][references-and-borrowing] section of the Book.\\n\\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\\n\")),\n  (\"E0508\",\n   Some(\"A value was moved out of a non-copy fixed-size array.\\n\\nErroneous code example:\\n\\n```compile_fail,E0508\\nstruct NonCopy;\\n\\nfn main() {\\n    let array = [NonCopy; 1];\\n    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,\\n                           //        a non-copy fixed-size array\\n}\\n```\\n\\nThe first element was moved out of the array, but this is not\\npossible because `NonCopy` does not implement the `Copy` trait.\\n\\nConsider borrowing the element instead of moving it:\\n\\n```\\nstruct NonCopy;\\n\\nfn main() {\\n    let array = [NonCopy; 1];\\n    let _value = &array[0]; // Borrowing is allowed, unlike moving.\\n}\\n```\\n\\nAlternatively, if your type implements `Clone` and you need to own the value,\\nconsider borrowing and then cloning:\\n\\n```\\n#[derive(Clone)]\\nstruct NonCopy;\\n\\nfn main() {\\n    let array = [NonCopy; 1];\\n    // Now you can clone the array element.\\n    let _value = array[0].clone();\\n}\\n```\\n\\nIf you really want to move the value out, you can use a destructuring array\\npattern to move it:\\n\\n```\\nstruct NonCopy;\\n\\nfn main() {\\n    let array = [NonCopy; 1];\\n    // Destructuring the array\\n    let [_value] = array;\\n}\\n```\\n\")),\n  (\"E0509\",\n   Some(\"This error occurs when an attempt is made to move out of a value whose type\\nimplements the `Drop` trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0509\\nstruct FancyNum {\\n    num: usize\\n}\\n\\nstruct DropStruct {\\n    fancy: FancyNum\\n}\\n\\nimpl Drop for DropStruct {\\n    fn drop(&mut self) {\\n        // Destruct DropStruct, possibly using FancyNum\\n    }\\n}\\n\\nfn main() {\\n    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\\n    let fancy_field = drop_struct.fancy; // Error E0509\\n    println!(\\\"Fancy: {}\\\", fancy_field.num);\\n    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\\n}\\n```\\n\\nHere, we tried to move a field out of a struct of type `DropStruct` which\\nimplements the `Drop` trait. However, a struct cannot be dropped if one or\\nmore of its fields have been moved.\\n\\nStructs implementing the `Drop` trait have an implicit destructor that gets\\ncalled when they go out of scope. This destructor may use the fields of the\\nstruct, so moving out of the struct could make it impossible to run the\\ndestructor. Therefore, we must think of all values whose type implements the\\n`Drop` trait as single units whose fields cannot be moved.\\n\\nThis error can be fixed by creating a reference to the fields of a struct,\\nenum, or tuple using the `ref` keyword:\\n\\n```\\nstruct FancyNum {\\n    num: usize\\n}\\n\\nstruct DropStruct {\\n    fancy: FancyNum\\n}\\n\\nimpl Drop for DropStruct {\\n    fn drop(&mut self) {\\n        // Destruct DropStruct, possibly using FancyNum\\n    }\\n}\\n\\nfn main() {\\n    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\\n    let ref fancy_field = drop_struct.fancy; // No more errors!\\n    println!(\\\"Fancy: {}\\\", fancy_field.num);\\n    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\\n}\\n```\\n\\nNote that this technique can also be used in the arms of a match expression:\\n\\n```\\nstruct FancyNum {\\n    num: usize\\n}\\n\\nenum DropEnum {\\n    Fancy(FancyNum)\\n}\\n\\nimpl Drop for DropEnum {\\n    fn drop(&mut self) {\\n        // Destruct DropEnum, possibly using FancyNum\\n    }\\n}\\n\\nfn main() {\\n    // Creates and enum of type `DropEnum`, which implements `Drop`\\n    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\\n    match drop_enum {\\n        // Creates a reference to the inside of `DropEnum::Fancy`\\n        DropEnum::Fancy(ref fancy_field) => // No error!\\n            println!(\\\"It was fancy-- {}!\\\", fancy_field.num),\\n    }\\n    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\\n}\\n```\\n\")),\n  (\"E0510\",\n   Some(\"The matched value was assigned in a match guard.\\n\\nErroneous code example:\\n\\n```compile_fail,E0510\\nlet mut x = Some(0);\\nmatch x {\\n    None => {}\\n    Some(_) if { x = None; false } => {} // error!\\n    Some(_) => {}\\n}\\n```\\n\\nWhen matching on a variable it cannot be mutated in the match guards, as this\\ncould cause the match to be non-exhaustive.\\n\\nHere executing `x = None` would modify the value being matched and require us\\nto go \\\"back in time\\\" to the `None` arm. To fix it, change the value in the match\\narm:\\n\\n```\\nlet mut x = Some(0);\\nmatch x {\\n    None => {}\\n    Some(_) => {\\n        x = None; // ok!\\n    }\\n}\\n```\\n\")),\n  (\"E0511\",\n   Some(\"Invalid monomorphization of an intrinsic function was used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0511\\n#![feature(platform_intrinsics)]\\n\\nextern \\\"platform-intrinsic\\\" {\\n    fn simd_add<T>(a: T, b: T) -> T;\\n}\\n\\nfn main() {\\n    unsafe { simd_add(0, 1); }\\n    // error: invalid monomorphization of `simd_add` intrinsic\\n}\\n```\\n\\nThe generic type has to be a SIMD type. Example:\\n\\n```\\n#![feature(repr_simd)]\\n#![feature(platform_intrinsics)]\\n\\n#[repr(simd)]\\n#[derive(Copy, Clone)]\\nstruct i32x2(i32, i32);\\n\\nextern \\\"platform-intrinsic\\\" {\\n    fn simd_add<T>(a: T, b: T) -> T;\\n}\\n\\nunsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\\n```\\n\")),\n  (\"E0512\",\n   Some(\"Transmute with two differently sized types was attempted.\\n\\nErroneous code example:\\n\\n```compile_fail,E0512\\nfn takes_u8(_: u8) {}\\n\\nfn main() {\\n    unsafe { takes_u8(::std::mem::transmute(0u16)); }\\n    // error: cannot transmute between types of different sizes,\\n    //        or dependently-sized types\\n}\\n```\\n\\nPlease use types with same size or use the expected type directly. Example:\\n\\n```\\nfn takes_u8(_: u8) {}\\n\\nfn main() {\\n    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\\n    // or:\\n    unsafe { takes_u8(0u8); } // ok!\\n}\\n```\\n\")),\n  (\"E0515\",\n   Some(\"A reference to a local variable was returned.\\n\\nErroneous code example:\\n\\n```compile_fail,E0515\\nfn get_dangling_reference() -> &\\'static i32 {\\n    let x = 0;\\n    &x\\n}\\n```\\n\\n```compile_fail,E0515\\nuse std::slice::Iter;\\nfn get_dangling_iterator<\\'a>() -> Iter<\\'a, i32> {\\n    let v = vec![1, 2, 3];\\n    v.iter()\\n}\\n```\\n\\nLocal variables, function parameters and temporaries are all dropped before the\\nend of the function body. So a reference to them cannot be returned.\\n\\nConsider returning an owned value instead:\\n\\n```\\nuse std::vec::IntoIter;\\n\\nfn get_integer() -> i32 {\\n    let x = 0;\\n    x\\n}\\n\\nfn get_owned_iterator() -> IntoIter<i32> {\\n    let v = vec![1, 2, 3];\\n    v.into_iter()\\n}\\n```\\n\")),\n  (\"E0516\",\n   Some(\"The `typeof` keyword is currently reserved but unimplemented.\\n\\nErroneous code example:\\n\\n```compile_fail,E0516\\nfn main() {\\n    let x: typeof(92) = 92;\\n}\\n```\\n\\nTry using type inference instead. Example:\\n\\n```\\nfn main() {\\n    let x = 92;\\n}\\n```\\n\")),\n  (\"E0517\",\n   Some(\"A `#[repr(..)]` attribute was placed on an unsupported item.\\n\\nExamples of erroneous code:\\n\\n```compile_fail,E0517\\n#[repr(C)]\\ntype Foo = u8;\\n\\n#[repr(packed)]\\nenum Foo {Bar, Baz}\\n\\n#[repr(u8)]\\nstruct Foo {bar: bool, baz: bool}\\n\\n#[repr(C)]\\nimpl Foo {\\n    // ...\\n}\\n```\\n\\n* The `#[repr(C)]` attribute can only be placed on structs and enums.\\n* The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs.\\n* The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums.\\n\\nThese attributes do not work on typedefs, since typedefs are just aliases.\\n\\nRepresentations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the\\ndiscriminant size for enums with no data fields on any of the variants, e.g.\\n`enum Color {Red, Blue, Green}`, effectively setting the size of the enum to\\nthe size of the provided type. Such an enum can be cast to a value of the same\\ntype as well. In short, `#[repr(u8)]` makes the enum behave like an integer\\nwith a constrained set of allowed values.\\n\\nOnly field-less enums can be cast to numerical primitives, so this attribute\\nwill not apply to structs.\\n\\n`#[repr(packed)]` reduces padding to make the struct size smaller. The\\nrepresentation of enums isn\\'t strictly defined in Rust, and this attribute\\nwon\\'t work on enums.\\n\\n`#[repr(simd)]` will give a struct consisting of a homogeneous series of machine\\ntypes (i.e., `u8`, `i32`, etc) a representation that permits vectorization via\\nSIMD. This doesn\\'t make much sense for enums since they don\\'t consist of a\\nsingle list of data.\\n\")),\n  (\"E0518\",\n   Some(\"An `#[inline(..)]` attribute was incorrectly placed on something other than a\\nfunction or method.\\n\\nExample of erroneous code:\\n\\n```compile_fail,E0518\\n#[inline(always)]\\nstruct Foo;\\n\\n#[inline(never)]\\nimpl Foo {\\n    // ...\\n}\\n```\\n\\n`#[inline]` hints the compiler whether or not to attempt to inline a method or\\nfunction. By default, the compiler does a pretty good job of figuring this out\\nitself, but if you feel the need for annotations, `#[inline(always)]` and\\n`#[inline(never)]` can override or force the compiler\\'s decision.\\n\\nIf you wish to apply this attribute to all methods in an impl, manually annotate\\neach method; it is not possible to annotate the entire impl with an `#[inline]`\\nattribute.\\n\")),\n  (\"E0520\",\n   Some(\"A non-default implementation was already made on this type so it cannot be\\nspecialized further.\\n\\nErroneous code example:\\n\\n```compile_fail,E0520\\n#![feature(specialization)]\\n\\ntrait SpaceLlama {\\n    fn fly(&self);\\n}\\n\\n// applies to all T\\nimpl<T> SpaceLlama for T {\\n    default fn fly(&self) {}\\n}\\n\\n// non-default impl\\n// applies to all `Clone` T and overrides the previous impl\\nimpl<T: Clone> SpaceLlama for T {\\n    fn fly(&self) {}\\n}\\n\\n// since `i32` is clone, this conflicts with the previous implementation\\nimpl SpaceLlama for i32 {\\n    default fn fly(&self) {}\\n    // error: item `fly` is provided by an `impl` that specializes\\n    //        another, but the item in the parent `impl` is not marked\\n    //        `default` and so it cannot be specialized.\\n}\\n```\\n\\nSpecialization only allows you to override `default` functions in\\nimplementations.\\n\\nTo fix this error, you need to mark all the parent implementations as default.\\nExample:\\n\\n```\\n#![feature(specialization)]\\n\\ntrait SpaceLlama {\\n    fn fly(&self);\\n}\\n\\n// applies to all T\\nimpl<T> SpaceLlama for T {\\n    default fn fly(&self) {} // This is a parent implementation.\\n}\\n\\n// applies to all `Clone` T; overrides the previous impl\\nimpl<T: Clone> SpaceLlama for T {\\n    default fn fly(&self) {} // This is a parent implementation but was\\n                             // previously not a default one, causing the error\\n}\\n\\n// applies to i32, overrides the previous two impls\\nimpl SpaceLlama for i32 {\\n    fn fly(&self) {} // And now that\\'s ok!\\n}\\n```\\n\")),\n  (\"E0521\",\n   Some(\"Borrowed data escapes outside of closure.\\n\\nErroneous code example:\\n\\n```compile_fail,E0521\\nlet mut list: Vec<&str> = Vec::new();\\n\\nlet _add = |el: &str| {\\n    list.push(el); // error: `el` escapes the closure body here\\n};\\n```\\n\\nA type anotation of a closure parameter implies a new lifetime declaration.\\nConsider to drop it, the compiler is reliably able to infer them.\\n\\n```\\nlet mut list: Vec<&str> = Vec::new();\\n\\nlet _add = |el| {\\n    list.push(el);\\n};\\n```\\n\\nSee the [Closure type inference and annotation][closure-infere-annotation] and\\n[Lifetime elision][lifetime-elision] sections of the Book for more details.\\n\\n[closure-infere-annotation]: https://doc.rust-lang.org/book/ch13-01-closures.html#closure-type-inference-and-annotation\\n[lifetime-elision]: https://doc.rust-lang.org/reference/lifetime-elision.html\\n\")),\n  (\"E0522\",\n   Some(\"The lang attribute was used in an invalid context.\\n\\nErroneous code example:\\n\\n```compile_fail,E0522\\n#![feature(lang_items)]\\n\\n#[lang = \\\"cookie\\\"]\\nfn cookie() -> ! { // error: definition of an unknown language item: `cookie`\\n    loop {}\\n}\\n```\\n\\nThe lang attribute is intended for marking special items that are built-in to\\nRust itself. This includes special traits (like `Copy` and `Sized`) that affect\\nhow the compiler behaves, as well as special functions that may be automatically\\ninvoked (such as the handler for out-of-bounds accesses when indexing a slice).\\n\")),\n  (\"E0524\",\n   Some(\"A variable which requires unique access is being used in more than one closure\\nat the same time.\\n\\nErroneous code example:\\n\\n```compile_fail,E0524\\nfn set(x: &mut isize) {\\n    *x += 4;\\n}\\n\\nfn dragoooon(x: &mut isize) {\\n    let mut c1 = || set(x);\\n    let mut c2 = || set(x); // error!\\n\\n    c2();\\n    c1();\\n}\\n```\\n\\nTo solve this issue, multiple solutions are available. First, is it required\\nfor this variable to be used in more than one closure at a time? If it is the\\ncase, use reference counted types such as `Rc` (or `Arc` if it runs\\nconcurrently):\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nfn set(x: &mut isize) {\\n    *x += 4;\\n}\\n\\nfn dragoooon(x: &mut isize) {\\n    let x = Rc::new(RefCell::new(x));\\n    let y = Rc::clone(&x);\\n    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&mut x2); };\\n    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&mut x2); }; // ok!\\n\\n    c2();\\n    c1();\\n}\\n```\\n\\nIf not, just run closures one at a time:\\n\\n```\\nfn set(x: &mut isize) {\\n    *x += 4;\\n}\\n\\nfn dragoooon(x: &mut isize) {\\n    { // This block isn\\'t necessary since non-lexical lifetimes, it\\'s just to\\n      // make it more clear.\\n        let mut c1 = || set(&mut *x);\\n        c1();\\n    } // `c1` has been dropped here so we\\'re free to use `x` again!\\n    let mut c2 = || set(&mut *x);\\n    c2();\\n}\\n```\\n\")),\n  (\"E0525\",\n   Some(\"A closure was used but didn\\'t implement the expected trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0525\\nstruct X;\\n\\nfn foo<T>(_: T) {}\\nfn bar<T: Fn(u32)>(_: T) {}\\n\\nfn main() {\\n    let x = X;\\n    let closure = |_| foo(x); // error: expected a closure that implements\\n                              //        the `Fn` trait, but this closure only\\n                              //        implements `FnOnce`\\n    bar(closure);\\n}\\n```\\n\\nIn the example above, `closure` is an `FnOnce` closure whereas the `bar`\\nfunction expected an `Fn` closure. In this case, it\\'s simple to fix the issue,\\nyou just have to implement `Copy` and `Clone` traits on `struct X` and it\\'ll\\nbe ok:\\n\\n```\\n#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.\\nstruct X;\\n\\nfn foo<T>(_: T) {}\\nfn bar<T: Fn(u32)>(_: T) {}\\n\\nfn main() {\\n    let x = X;\\n    let closure = |_| foo(x);\\n    bar(closure); // ok!\\n}\\n```\\n\\nTo better understand how these work in Rust, read the [Closures][closures]\\nchapter of the Book.\\n\\n[closures]: https://doc.rust-lang.org/book/ch13-01-closures.html\\n\")),\n  (\"E0527\",\n   Some(\"The number of elements in an array or slice pattern differed from the number of\\nelements in the array being matched.\\n\\nExample of erroneous code:\\n\\n```compile_fail,E0527\\nlet r = &[1, 2, 3, 4];\\nmatch r {\\n    &[a, b] => { // error: pattern requires 2 elements but array\\n                 //        has 4\\n        println!(\\\"a={}, b={}\\\", a, b);\\n    }\\n}\\n```\\n\\nEnsure that the pattern is consistent with the size of the matched\\narray. Additional elements can be matched with `..`:\\n\\n```\\nlet r = &[1, 2, 3, 4];\\nmatch r {\\n    &[a, b, ..] => { // ok!\\n        println!(\\\"a={}, b={}\\\", a, b);\\n    }\\n}\\n```\\n\")),\n  (\"E0528\",\n   Some(\"An array or slice pattern required more elements than were present in the\\nmatched array.\\n\\nExample of erroneous code:\\n\\n```compile_fail,E0528\\nlet r = &[1, 2];\\nmatch r {\\n    &[a, b, c, rest @ ..] => { // error: pattern requires at least 3\\n                               //        elements but array has 2\\n        println!(\\\"a={}, b={}, c={} rest={:?}\\\", a, b, c, rest);\\n    }\\n}\\n```\\n\\nEnsure that the matched array has at least as many elements as the pattern\\nrequires. You can match an arbitrary number of remaining elements with `..`:\\n\\n```\\nlet r = &[1, 2, 3, 4, 5];\\nmatch r {\\n    &[a, b, c, rest @ ..] => { // ok!\\n        // prints `a=1, b=2, c=3 rest=[4, 5]`\\n        println!(\\\"a={}, b={}, c={} rest={:?}\\\", a, b, c, rest);\\n    }\\n}\\n```\\n\")),\n  (\"E0529\",\n   Some(\"An array or slice pattern was matched against some other type.\\n\\nExample of erroneous code:\\n\\n```compile_fail,E0529\\nlet r: f32 = 1.0;\\nmatch r {\\n    [a, b] => { // error: expected an array or slice, found `f32`\\n        println!(\\\"a={}, b={}\\\", a, b);\\n    }\\n}\\n```\\n\\nEnsure that the pattern and the expression being matched on are of consistent\\ntypes:\\n\\n```\\nlet r = [1.0, 2.0];\\nmatch r {\\n    [a, b] => { // ok!\\n        println!(\\\"a={}, b={}\\\", a, b);\\n    }\\n}\\n```\\n\")),\n  (\"E0530\",\n   Some(\"A binding shadowed something it shouldn\\'t.\\n\\nA match arm or a variable has a name that is already used by\\nsomething else, e.g.\\n\\n* struct name\\n* enum variant\\n* static\\n* associated constant\\n\\nThis error may also happen when an enum variant *with fields* is used\\nin a pattern, but without its fields.\\n\\n```compile_fail\\nenum Enum {\\n    WithField(i32)\\n}\\n\\nuse Enum::*;\\nmatch WithField(1) {\\n    WithField => {} // error: missing (_)\\n}\\n```\\n\\nMatch bindings cannot shadow statics:\\n\\n```compile_fail,E0530\\nstatic TEST: i32 = 0;\\n\\nlet r = 123;\\nmatch r {\\n    TEST => {} // error: name of a static\\n}\\n```\\n\\nFixed examples:\\n\\n```\\nstatic TEST: i32 = 0;\\n\\nlet r = 123;\\nmatch r {\\n    some_value => {} // ok!\\n}\\n```\\n\\nor\\n\\n```\\nconst TEST: i32 = 0; // const, not static\\n\\nlet r = 123;\\nmatch r {\\n    TEST => {} // const is ok!\\n    other_values => {}\\n}\\n```\\n\")),\n  (\"E0531\",\n   Some(\"An unknown tuple struct/variant has been used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0531\\nlet Type(x) = Type(12); // error!\\nmatch Bar(12) {\\n    Bar(x) => {} // error!\\n    _ => {}\\n}\\n```\\n\\nIn most cases, it\\'s either a forgotten import or a typo. However, let\\'s look at\\nhow you can have such a type:\\n\\n```edition2018\\nstruct Type(u32); // this is a tuple struct\\n\\nenum Foo {\\n    Bar(u32), // this is a tuple variant\\n}\\n\\nuse Foo::*; // To use Foo\\'s variant directly, we need to import them in\\n            // the scope.\\n```\\n\\nEither way, it should work fine with our previous code:\\n\\n```edition2018\\nstruct Type(u32);\\n\\nenum Foo {\\n    Bar(u32),\\n}\\nuse Foo::*;\\n\\nlet Type(x) = Type(12); // ok!\\nmatch Type(12) {\\n    Type(x) => {} // ok!\\n    _ => {}\\n}\\n```\\n\")),\n  (\"E0532\",\n   Some(\"Pattern arm did not match expected kind.\\n\\nErroneous code example:\\n\\n```compile_fail,E0532\\nenum State {\\n    Succeeded,\\n    Failed(String),\\n}\\n\\nfn print_on_failure(state: &State) {\\n    match *state {\\n        // error: expected unit struct, unit variant or constant, found tuple\\n        //        variant `State::Failed`\\n        State::Failed => println!(\\\"Failed\\\"),\\n        _ => ()\\n    }\\n}\\n```\\n\\nTo fix this error, ensure the match arm kind is the same as the expression\\nmatched.\\n\\nFixed example:\\n\\n```\\nenum State {\\n    Succeeded,\\n    Failed(String),\\n}\\n\\nfn print_on_failure(state: &State) {\\n    match *state {\\n        State::Failed(ref msg) => println!(\\\"Failed with {}\\\", msg),\\n        _ => ()\\n    }\\n}\\n```\\n\")),\n  (\"E0533\",\n   Some(\"An item which isn\\'t a unit struct, a variant, nor a constant has been used as a\\nmatch pattern.\\n\\nErroneous code example:\\n\\n```compile_fail,E0533\\nstruct Tortoise;\\n\\nimpl Tortoise {\\n    fn turtle(&self) -> u32 { 0 }\\n}\\n\\nmatch 0u32 {\\n    Tortoise::turtle => {} // Error!\\n    _ => {}\\n}\\nif let Tortoise::turtle = 0u32 {} // Same error!\\n```\\n\\nIf you want to match against a value returned by a method, you need to bind the\\nvalue first:\\n\\n```\\nstruct Tortoise;\\n\\nimpl Tortoise {\\n    fn turtle(&self) -> u32 { 0 }\\n}\\n\\nmatch 0u32 {\\n    x if x == Tortoise.turtle() => {} // Bound into `x` then we compare it!\\n    _ => {}\\n}\\n```\\n\")),\n  (\"E0534\",\n   Some(\"The `inline` attribute was malformed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0534\\n#[inline()] // error: expected one argument\\npub fn something() {}\\n\\nfn main() {}\\n```\\n\\nThe parenthesized `inline` attribute requires the parameter to be specified:\\n\\n```\\n#[inline(always)]\\nfn something() {}\\n```\\n\\nor:\\n\\n```\\n#[inline(never)]\\nfn something() {}\\n```\\n\\nAlternatively, a paren-less version of the attribute may be used to hint the\\ncompiler about inlining opportunity:\\n\\n```\\n#[inline]\\nfn something() {}\\n```\\n\\nFor more information see the [`inline` attribute][inline-attribute] section\\nof the Reference.\\n\\n[inline-attribute]: https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute\\n\")),\n  (\"E0535\",\n   Some(\"An unknown argument was given to the `inline` attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0535\\n#[inline(unknown)] // error: invalid argument\\npub fn something() {}\\n\\nfn main() {}\\n```\\n\\nThe `inline` attribute only supports two arguments:\\n\\n * always\\n * never\\n\\nAll other arguments given to the `inline` attribute will return this error.\\nExample:\\n\\n```\\n#[inline(never)] // ok!\\npub fn something() {}\\n\\nfn main() {}\\n```\\n\\nFor more information see the [`inline` Attribute][inline-attribute] section\\nof the Reference.\\n\\n[inline-attribute]: https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute\\n\")),\n  (\"E0536\",\n   Some(\"The `not` cfg-predicate was malformed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0536\\n#[cfg(not())] // error: expected 1 cfg-pattern\\npub fn something() {}\\n\\npub fn main() {}\\n```\\n\\nThe `not` predicate expects one cfg-pattern. Example:\\n\\n```\\n#[cfg(not(target_os = \\\"linux\\\"))] // ok!\\npub fn something() {}\\n\\npub fn main() {}\\n```\\n\\nFor more information about the `cfg` attribute, read the section on\\n[Conditional Compilation][conditional-compilation] in the Reference.\\n\\n[conditional-compilation]: https://doc.rust-lang.org/reference/conditional-compilation.html\\n\")),\n  (\"E0537\",\n   Some(\"An unknown predicate was used inside the `cfg` attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0537\\n#[cfg(unknown())] // error: invalid predicate `unknown`\\npub fn something() {}\\n\\npub fn main() {}\\n```\\n\\nThe `cfg` attribute supports only three kinds of predicates:\\n\\n * any\\n * all\\n * not\\n\\nExample:\\n\\n```\\n#[cfg(not(target_os = \\\"linux\\\"))] // ok!\\npub fn something() {}\\n\\npub fn main() {}\\n```\\n\\nFor more information about the `cfg` attribute, read the section on\\n[Conditional Compilation][conditional-compilation] in the Reference.\\n\\n[conditional-compilation]: https://doc.rust-lang.org/reference/conditional-compilation.html\\n\")),\n  (\"E0538\",\n   Some(\"Attribute contains same meta item more than once.\\n\\nErroneous code example:\\n\\n```compile_fail,E0538\\n#[deprecated(\\n    since=\\\"1.0.0\\\",\\n    note=\\\"First deprecation note.\\\",\\n    note=\\\"Second deprecation note.\\\" // error: multiple same meta item\\n)]\\nfn deprecated_function() {}\\n```\\n\\nMeta items are the key-value pairs inside of an attribute. Each key may only be\\nused once in each attribute.\\n\\nTo fix the problem, remove all but one of the meta items with the same key.\\n\\nExample:\\n\\n```\\n#[deprecated(\\n    since=\\\"1.0.0\\\",\\n    note=\\\"First deprecation note.\\\"\\n)]\\nfn deprecated_function() {}\\n```\\n\")),\n  (\"E0539\",\n   Some(\"An invalid meta-item was used inside an attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0539\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[rustc_deprecated(reason)] // error!\\n#[unstable(feature = \\\"deprecated_fn\\\", issue = \\\"123\\\")]\\nfn deprecated() {}\\n\\n#[unstable(feature = \\\"unstable_struct\\\", issue)] // error!\\nstruct Unstable;\\n\\n#[rustc_const_unstable(feature)] // error!\\nconst fn unstable_fn() {}\\n\\n#[stable(feature = \\\"stable_struct\\\", since)] // error!\\nstruct Stable;\\n\\n#[rustc_const_stable(feature)] // error!\\nconst fn stable_fn() {}\\n```\\n\\nMeta items are the key-value pairs inside of an attribute.\\nTo fix these issues you need to give required key-value pairs.\\n\\n```\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[rustc_deprecated(since = \\\"1.39.0\\\", reason = \\\"reason\\\")] // ok!\\n#[unstable(feature = \\\"deprecated_fn\\\", issue = \\\"123\\\")]\\nfn deprecated() {}\\n\\n#[unstable(feature = \\\"unstable_struct\\\", issue = \\\"123\\\")] // ok!\\nstruct Unstable;\\n\\n#[rustc_const_unstable(feature = \\\"unstable_fn\\\", issue = \\\"124\\\")] // ok!\\nconst fn unstable_fn() {}\\n\\n#[stable(feature = \\\"stable_struct\\\", since = \\\"1.39.0\\\")] // ok!\\nstruct Stable;\\n\\n#[rustc_const_stable(feature = \\\"stable_fn\\\", since = \\\"1.39.0\\\")] // ok!\\nconst fn stable_fn() {}\\n```\\n\")),\n  (\"E0541\",\n   Some(\"An unknown meta item was used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0541\\n#[deprecated(\\n    since=\\\"1.0.0\\\",\\n    // error: unknown meta item\\n    reason=\\\"Example invalid meta item. Should be \\'note\\'\\\")\\n]\\nfn deprecated_function() {}\\n```\\n\\nMeta items are the key-value pairs inside of an attribute. The keys provided\\nmust be one of the valid keys for the specified attribute.\\n\\nTo fix the problem, either remove the unknown meta item, or rename it if you\\nprovided the wrong name.\\n\\nIn the erroneous code example above, the wrong name was provided, so changing\\nto a correct one it will fix the error. Example:\\n\\n```\\n#[deprecated(\\n    since=\\\"1.0.0\\\",\\n    note=\\\"This is a valid meta item for the deprecated attribute.\\\"\\n)]\\nfn deprecated_function() {}\\n```\\n\")),\n  (\"E0542\",\n   Some(\"The `since` value is missing in a stability attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0542\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[stable(feature = \\\"_stable_fn\\\")] // invalid\\nfn _stable_fn() {}\\n\\n#[rustc_const_stable(feature = \\\"_stable_const_fn\\\")] // invalid\\nconst fn _stable_const_fn() {}\\n\\n#[stable(feature = \\\"_deprecated_fn\\\", since = \\\"0.1.0\\\")]\\n#[rustc_deprecated(\\n    reason = \\\"explanation for deprecation\\\"\\n)] // invalid\\nfn _deprecated_fn() {}\\n```\\n\\nTo fix this issue, you need to provide the `since` field. Example:\\n\\n```\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[stable(feature = \\\"_stable_fn\\\", since = \\\"1.0.0\\\")] // ok!\\nfn _stable_fn() {}\\n\\n#[rustc_const_stable(feature = \\\"_stable_const_fn\\\", since = \\\"1.0.0\\\")] // ok!\\nconst fn _stable_const_fn() {}\\n\\n#[stable(feature = \\\"_deprecated_fn\\\", since = \\\"0.1.0\\\")]\\n#[rustc_deprecated(\\n    since = \\\"1.0.0\\\",\\n    reason = \\\"explanation for deprecation\\\"\\n)] // ok!\\nfn _deprecated_fn() {}\\n```\\n\\nSee the [How Rust is Made and \\u{201c}Nightly Rust\\u{201d}][how-rust-made-nightly] appendix\\nof the Book and the [Stability attributes][stability-attributes] section of the\\nRustc Dev Guide for more details.\\n\\n[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\\n[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html\\n\")),\n  (\"E0543\",\n   Some(\"The `reason` value is missing in a stability attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0543\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[stable(since = \\\"0.1.0\\\", feature = \\\"_deprecated_fn\\\")]\\n#[rustc_deprecated(\\n    since = \\\"1.0.0\\\"\\n)] // invalid\\nfn _deprecated_fn() {}\\n```\\n\\nTo fix this issue, you need to provide the `reason` field. Example:\\n\\n```\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[stable(since = \\\"0.1.0\\\", feature = \\\"_deprecated_fn\\\")]\\n#[rustc_deprecated(\\n    since = \\\"1.0.0\\\",\\n    reason = \\\"explanation for deprecation\\\"\\n)] // ok!\\nfn _deprecated_fn() {}\\n```\\n\\nSee the [How Rust is Made and \\u{201c}Nightly Rust\\u{201d}][how-rust-made-nightly] appendix\\nof the Book and the [Stability attributes][stability-attributes] section of the\\nRustc Dev Guide for more details.\\n\\n[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\\n[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html\\n\")),\n  (\"E0544\",\n   Some(\"Multiple stability attributes were declared on the same item.\\n\\nErroneous code example:\\n\\n```compile_fail,E0544\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"rust1\\\")]\\n\\n#[stable(feature = \\\"rust1\\\", since = \\\"1.0.0\\\")]\\n#[stable(feature = \\\"test\\\", since = \\\"2.0.0\\\")] // invalid\\nfn foo() {}\\n```\\n\\nTo fix this issue, ensure that each item has at most one stability attribute.\\n\\n```\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"rust1\\\")]\\n\\n#[stable(feature = \\\"test\\\", since = \\\"2.0.0\\\")] // ok!\\nfn foo() {}\\n```\\n\\nSee the [How Rust is Made and \\u{201c}Nightly Rust\\u{201d}][how-rust-made-nightly] appendix\\nof the Book and the [Stability attributes][stability-attributes] section of the\\nRustc Dev Guide for more details.\\n\\n[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\\n[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html\\n\")),\n  (\"E0545\",\n   Some(\"The `issue` value is incorrect in a stability attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0545\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[unstable(feature = \\\"_unstable_fn\\\", issue = \\\"0\\\")] // invalid\\nfn _unstable_fn() {}\\n\\n#[rustc_const_unstable(feature = \\\"_unstable_const_fn\\\", issue = \\\"0\\\")] // invalid\\nconst fn _unstable_const_fn() {}\\n```\\n\\nTo fix this issue, you need to provide a correct value in the `issue` field.\\nExample:\\n\\n```\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[unstable(feature = \\\"_unstable_fn\\\", issue = \\\"none\\\")] // ok!\\nfn _unstable_fn() {}\\n\\n#[rustc_const_unstable(feature = \\\"_unstable_const_fn\\\", issue = \\\"1\\\")] // ok!\\nconst fn _unstable_const_fn() {}\\n```\\n\\nSee the [How Rust is Made and \\u{201c}Nightly Rust\\u{201d}][how-rust-made-nightly] appendix\\nof the Book and the [Stability attributes][stability-attributes] section of the\\nRustc Dev Guide for more details.\\n\\n[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\\n[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html\\n\")),\n  (\"E0546\",\n   Some(\"The `feature` value is missing in a stability attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0546\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[unstable(issue = \\\"none\\\")] // invalid\\nfn unstable_fn() {}\\n\\n#[stable(since = \\\"1.0.0\\\")] // invalid\\nfn stable_fn() {}\\n```\\n\\nTo fix this issue, you need to provide the `feature` field. Example:\\n\\n```\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[unstable(feature = \\\"unstable_fn\\\", issue = \\\"none\\\")] // ok!\\nfn unstable_fn() {}\\n\\n#[stable(feature = \\\"stable_fn\\\", since = \\\"1.0.0\\\")] // ok!\\nfn stable_fn() {}\\n```\\n\\nSee the [How Rust is Made and \\u{201c}Nightly Rust\\u{201d}][how-rust-made-nightly] appendix\\nof the Book and the [Stability attributes][stability-attributes] section of the\\nRustc Dev Guide for more details.\\n\\n[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\\n[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html\\n\")),\n  (\"E0547\",\n   Some(\"The `issue` value is missing in a stability attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0547\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[unstable(feature = \\\"_unstable_fn\\\")] // invalid\\nfn _unstable_fn() {}\\n\\n#[rustc_const_unstable(feature = \\\"_unstable_const_fn\\\")] // invalid\\nconst fn _unstable_const_fn() {}\\n```\\n\\nTo fix this issue, you need to provide the `issue` field. Example:\\n\\n```\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[unstable(feature = \\\"_unstable_fn\\\", issue = \\\"none\\\")] // ok!\\nfn _unstable_fn() {}\\n\\n#[rustc_const_unstable(\\n    feature = \\\"_unstable_const_fn\\\",\\n    issue = \\\"none\\\"\\n)] // ok!\\nconst fn _unstable_const_fn() {}\\n```\\n\\nSee the [How Rust is Made and \\u{201c}Nightly Rust\\u{201d}][how-rust-made-nightly] appendix\\nof the Book and the [Stability attributes][stability-attributes] section of the\\nRustc Dev Guide for more details.\\n\\n[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\\n[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html\\n\")),\n  (\"E0549\",\n   Some(\"A `rustc_deprecated` attribute wasn\\'t paired with a `stable`/`unstable`\\nattribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0549\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[rustc_deprecated(\\n    since = \\\"1.0.1\\\",\\n    reason = \\\"explanation for deprecation\\\"\\n)] // invalid\\nfn _deprecated_fn() {}\\n```\\n\\nTo fix this issue, you need to add also an attribute `stable` or `unstable`.\\nExample:\\n\\n```\\n#![feature(staged_api)]\\n#![stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n\\n#[stable(since = \\\"1.0.0\\\", feature = \\\"test\\\")]\\n#[rustc_deprecated(\\n    since = \\\"1.0.1\\\",\\n    reason = \\\"explanation for deprecation\\\"\\n)] // ok!\\nfn _deprecated_fn() {}\\n```\\n\\nSee the [How Rust is Made and \\u{201c}Nightly Rust\\u{201d}][how-rust-made-nightly] appendix\\nof the Book and the [Stability attributes][stability-attributes] section of the\\nRustc Dev Guide for more details.\\n\\n[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\\n[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html\\n\")),\n  (\"E0550\",\n   Some(\"More than one `deprecated` attribute has been put on an item.\\n\\nErroneous code example:\\n\\n```compile_fail,E0550\\n#[deprecated(note = \\\"because why not?\\\")]\\n#[deprecated(note = \\\"right?\\\")] // error!\\nfn the_banished() {}\\n```\\n\\nThe `deprecated` attribute can only be present **once** on an item.\\n\\n```\\n#[deprecated(note = \\\"because why not, right?\\\")]\\nfn the_banished() {} // ok!\\n```\\n\")),\n  (\"E0551\",\n   Some(\"An invalid meta-item was used inside an attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0551\\n#[deprecated(note)] // error!\\nfn i_am_deprecated() {}\\n```\\n\\nMeta items are the key-value pairs inside of an attribute. To fix this issue,\\nyou need to give a value to the `note` key. Example:\\n\\n```\\n#[deprecated(note = \\\"because\\\")] // ok!\\nfn i_am_deprecated() {}\\n```\\n\")),\n  (\"E0552\",\n   Some(\"A unrecognized representation attribute was used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0552\\n#[repr(D)] // error: unrecognized representation hint\\nstruct MyStruct {\\n    my_field: usize\\n}\\n```\\n\\nYou can use a `repr` attribute to tell the compiler how you want a struct or\\nenum to be laid out in memory.\\n\\nMake sure you\\'re using one of the supported options:\\n\\n```\\n#[repr(C)] // ok!\\nstruct MyStruct {\\n    my_field: usize\\n}\\n```\\n\\nFor more information about specifying representations, see the [\\\"Alternative\\nRepresentations\\\" section] of the Rustonomicon.\\n\\n[\\\"Alternative Representations\\\" section]: https://doc.rust-lang.org/nomicon/other-reprs.html\\n\")),\n  (\"E0554\",\n   Some(\"Feature attributes are only allowed on the nightly release channel. Stable or\\nbeta compilers will not comply.\\n\\nErroneous code example:\\n\\n```ignore (depends on release channel)\\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\\n                        //        stable release channel\\n```\\n\\nIf you need the feature, make sure to use a nightly release of the compiler\\n(but be warned that the feature may be removed or altered in the future).\\n\")),\n  (\"E0556\",\n   Some(\"The `feature` attribute was badly formed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0556\\n#![feature(foo_bar_baz, foo(bar), foo = \\\"baz\\\", foo)] // error!\\n#![feature] // error!\\n#![feature = \\\"foo\\\"] // error!\\n```\\n\\nThe `feature` attribute only accept a \\\"feature flag\\\" and can only be used on\\nnightly. Example:\\n\\n```ignore (only works in nightly)\\n#![feature(flag)]\\n```\\n\")),\n  (\"E0557\",\n   Some(\"A feature attribute named a feature that has been removed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0557\\n#![feature(managed_boxes)] // error: feature has been removed\\n```\\n\\nDelete the offending feature attribute.\\n\")),\n  (\"E0559\",\n   Some(\"An unknown field was specified into an enum\\'s structure variant.\\n\\nErroneous code example:\\n\\n```compile_fail,E0559\\nenum Field {\\n    Fool { x: u32 },\\n}\\n\\nlet s = Field::Fool { joke: 0 };\\n// error: struct variant `Field::Fool` has no field named `joke`\\n```\\n\\nVerify you didn\\'t misspell the field\\'s name or that the field exists. Example:\\n\\n```\\nenum Field {\\n    Fool { joke: u32 },\\n}\\n\\nlet s = Field::Fool { joke: 0 }; // ok!\\n```\\n\")),\n  (\"E0560\",\n   Some(\"An unknown field was specified into a structure.\\n\\nErroneous code example:\\n\\n```compile_fail,E0560\\nstruct Simba {\\n    mother: u32,\\n}\\n\\nlet s = Simba { mother: 1, father: 0 };\\n// error: structure `Simba` has no field named `father`\\n```\\n\\nVerify you didn\\'t misspell the field\\'s name or that the field exists. Example:\\n\\n```\\nstruct Simba {\\n    mother: u32,\\n    father: u32,\\n}\\n\\nlet s = Simba { mother: 1, father: 0 }; // ok!\\n```\\n\")),\n  (\"E0561\",\n   Some(\"A non-ident or non-wildcard pattern has been used as a parameter of a function\\npointer type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0561\\ntype A1 = fn(mut param: u8); // error!\\ntype A2 = fn(&param: u32); // error!\\n```\\n\\nWhen using an alias over a function type, you cannot e.g. denote a parameter as\\nbeing mutable.\\n\\nTo fix the issue, remove patterns (`_` is allowed though). Example:\\n\\n```\\ntype A1 = fn(param: u8); // ok!\\ntype A2 = fn(_: u32); // ok!\\n```\\n\\nYou can also omit the parameter name:\\n\\n```\\ntype A3 = fn(i16); // ok!\\n```\\n\")),\n  (\"E0562\",\n   Some(\"Abstract return types (written `impl Trait` for some trait `Trait`) are only\\nallowed as function and inherent impl return types.\\n\\nErroneous code example:\\n\\n```compile_fail,E0562\\nfn main() {\\n    let count_to_ten: impl Iterator<Item=usize> = 0..10;\\n    // error: `impl Trait` not allowed outside of function and inherent method\\n    //        return types\\n    for i in count_to_ten {\\n        println!(\\\"{}\\\", i);\\n    }\\n}\\n```\\n\\nMake sure `impl Trait` only appears in return-type position.\\n\\n```\\nfn count_to_n(n: usize) -> impl Iterator<Item=usize> {\\n    0..n\\n}\\n\\nfn main() {\\n    for i in count_to_n(10) {  // ok!\\n        println!(\\\"{}\\\", i);\\n    }\\n}\\n```\\n\\nSee [RFC 1522] for more details.\\n\\n[RFC 1522]: https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md\\n\")),\n  (\"E0565\",\n   Some(\"A literal was used in a built-in attribute that doesn\\'t support literals.\\n\\nErroneous code example:\\n\\n```compile_fail,E0565\\n#[repr(\\\"C\\\")] // error: meta item in `repr` must be an identifier\\nstruct Repr {}\\n\\nfn main() {}\\n```\\n\\nLiterals in attributes are new and largely unsupported in built-in attributes.\\nWork to support literals where appropriate is ongoing. Try using an unquoted\\nname instead:\\n\\n```\\n#[repr(C)] // ok!\\nstruct Repr {}\\n\\nfn main() {}\\n```\\n\")),\n  (\"E0566\",\n   Some(\"Conflicting representation hints have been used on a same item.\\n\\nErroneous code example:\\n\\n```compile_fail,E0566\\n#[repr(u32, u64)]\\nenum Repr { A }\\n```\\n\\nIn most cases (if not all), using just one representation hint is more than\\nenough. If you want to have a representation hint depending on the current\\narchitecture, use `cfg_attr`. Example:\\n\\n```\\n#[cfg_attr(linux, repr(u32))]\\n#[cfg_attr(not(linux), repr(u64))]\\nenum Repr { A }\\n```\\n\")),\n  (\"E0567\",\n   Some(\"Generics have been used on an auto trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0567\\n#![feature(auto_traits)]\\n\\nauto trait Generic<T> {} // error!\\n# fn main() {}\\n```\\n\\nSince an auto trait is implemented on all existing types, the\\ncompiler would not be able to infer the types of the trait\\'s generic\\nparameters.\\n\\nTo fix this issue, just remove the generics:\\n\\n```\\n#![feature(auto_traits)]\\n\\nauto trait Generic {} // ok!\\n# fn main() {}\\n```\\n\")),\n  (\"E0568\",\n   Some(\"A super trait has been added to an auto trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0568\\n#![feature(auto_traits)]\\n\\nauto trait Bound : Copy {} // error!\\n\\nfn main() {}\\n```\\n\\nSince an auto trait is implemented on all existing types, adding a super trait\\nwould filter out a lot of those types. In the current example, almost none of\\nall the existing types could implement `Bound` because very few of them have the\\n`Copy` trait.\\n\\nTo fix this issue, just remove the super trait:\\n\\n```\\n#![feature(auto_traits)]\\n\\nauto trait Bound {} // ok!\\n\\nfn main() {}\\n```\\n\")),\n  (\"E0569\",\n   Some(\"If an impl has a generic parameter with the `#[may_dangle]` attribute, then\\nthat impl must be declared as an `unsafe impl`.\\n\\nErroneous code example:\\n\\n```compile_fail,E0569\\n#![feature(dropck_eyepatch)]\\n\\nstruct Foo<X>(X);\\nimpl<#[may_dangle] X> Drop for Foo<X> {\\n    fn drop(&mut self) { }\\n}\\n```\\n\\nIn this example, we are asserting that the destructor for `Foo` will not\\naccess any data of type `X`, and require this assertion to be true for\\noverall safety in our program. The compiler does not currently attempt to\\nverify this assertion; therefore we must tag this `impl` as unsafe.\\n\")),\n  (\"E0570\",\n   Some(\"The requested ABI is unsupported by the current target.\\n\\nThe rust compiler maintains for each target a list of unsupported ABIs on\\nthat target. If an ABI is present in such a list this usually means that the\\ntarget / ABI combination is currently unsupported by llvm.\\n\\nIf necessary, you can circumvent this check using custom target specifications.\\n\")),\n  (\"E0571\",\n   Some(\"A `break` statement with an argument appeared in a non-`loop` loop.\\n\\nExample of erroneous code:\\n\\n```compile_fail,E0571\\n# let mut i = 1;\\n# fn satisfied(n: usize) -> bool { n % 23 == 0 }\\nlet result = while true {\\n    if satisfied(i) {\\n        break 2 * i; // error: `break` with value from a `while` loop\\n    }\\n    i += 1;\\n};\\n```\\n\\nThe `break` statement can take an argument (which will be the value of the loop\\nexpression if the `break` statement is executed) in `loop` loops, but not\\n`for`, `while`, or `while let` loops.\\n\\nMake sure `break value;` statements only occur in `loop` loops:\\n\\n```\\n# let mut i = 1;\\n# fn satisfied(n: usize) -> bool { n % 23 == 0 }\\nlet result = loop { // This is now a \\\"loop\\\" loop.\\n    if satisfied(i) {\\n        break 2 * i; // ok!\\n    }\\n    i += 1;\\n};\\n```\\n\")),\n  (\"E0572\",\n   Some(\"A return statement was found outside of a function body.\\n\\nErroneous code example:\\n\\n```compile_fail,E0572\\nconst FOO: u32 = return 0; // error: return statement outside of function body\\n\\nfn main() {}\\n```\\n\\nTo fix this issue, just remove the return keyword or move the expression into a\\nfunction. Example:\\n\\n```\\nconst FOO: u32 = 0;\\n\\nfn some_fn() -> u32 {\\n    return FOO;\\n}\\n\\nfn main() {\\n    some_fn();\\n}\\n```\\n\")),\n  (\"E0573\",\n   Some(\"Something other than a type has been used when one was expected.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0573\\nenum Dragon {\\n    Born,\\n}\\n\\nfn oblivion() -> Dragon::Born { // error!\\n    Dragon::Born\\n}\\n\\nconst HOBBIT: u32 = 2;\\nimpl HOBBIT {} // error!\\n\\nenum Wizard {\\n    Gandalf,\\n    Saruman,\\n}\\n\\ntrait Isengard {\\n    fn wizard(_: Wizard::Saruman); // error!\\n}\\n```\\n\\nIn all these errors, a type was expected. For example, in the first error, if\\nwe want to return the `Born` variant from the `Dragon` enum, we must set the\\nfunction to return the enum and not its variant:\\n\\n```\\nenum Dragon {\\n    Born,\\n}\\n\\nfn oblivion() -> Dragon { // ok!\\n    Dragon::Born\\n}\\n```\\n\\nIn the second error, you can\\'t implement something on an item, only on types.\\nWe would need to create a new type if we wanted to do something similar:\\n\\n```\\nstruct Hobbit(u32); // we create a new type\\n\\nconst HOBBIT: Hobbit = Hobbit(2);\\nimpl Hobbit {} // ok!\\n```\\n\\nIn the third case, we tried to only expect one variant of the `Wizard` enum,\\nwhich is not possible. To make this work, we need to using pattern matching\\nover the `Wizard` enum:\\n\\n```\\nenum Wizard {\\n    Gandalf,\\n    Saruman,\\n}\\n\\ntrait Isengard {\\n    fn wizard(w: Wizard) { // ok!\\n        match w {\\n            Wizard::Saruman => {\\n                // do something\\n            }\\n            _ => {} // ignore everything else\\n        }\\n    }\\n}\\n```\\n\")),\n  (\"E0574\",\n   Some(\"Something other than a struct, variant or union has been used when one was\\nexpected.\\n\\nErroneous code example:\\n\\n```compile_fail,E0574\\nmod Mordor {}\\n\\nlet sauron = Mordor { x: () }; // error!\\n\\nenum Jak {\\n    Daxter { i: isize },\\n}\\n\\nlet eco = Jak::Daxter { i: 1 };\\nmatch eco {\\n    Jak { i } => {} // error!\\n}\\n```\\n\\nIn all these errors, a type was expected. For example, in the first error,\\nwe tried to instantiate the `Mordor` module, which is impossible. If you want\\nto instantiate a type inside a module, you can do it as follow:\\n\\n```\\nmod Mordor {\\n    pub struct TheRing {\\n        pub x: usize,\\n    }\\n}\\n\\nlet sauron = Mordor::TheRing { x: 1 }; // ok!\\n```\\n\\nIn the second error, we tried to bind the `Jak` enum directly, which is not\\npossible: you can only bind one of its variants. To do so:\\n\\n```\\nenum Jak {\\n    Daxter { i: isize },\\n}\\n\\nlet eco = Jak::Daxter { i: 1 };\\nmatch eco {\\n    Jak::Daxter { i } => {} // ok!\\n}\\n```\\n\")),\n  (\"E0575\",\n   Some(\"Something other than a type or an associated type was given.\\n\\nErroneous code example:\\n\\n```compile_fail,E0575\\nenum Rick { Morty }\\n\\nlet _: <u8 as Rick>::Morty; // error!\\n\\ntrait Age {\\n    type Empire;\\n    fn Mythology() {}\\n}\\n\\nimpl Age for u8 {\\n    type Empire = u16;\\n}\\n\\nlet _: <u8 as Age>::Mythology; // error!\\n```\\n\\nIn both cases, we\\'re declaring a variable (called `_`) and we\\'re giving it a\\ntype. However, `<u8 as Rick>::Morty` and `<u8 as Age>::Mythology` aren\\'t types,\\ntherefore the compiler throws an error.\\n\\n`<u8 as Rick>::Morty` is an enum variant, you cannot use a variant as a type,\\nyou have to use the enum directly:\\n\\n```\\nenum Rick { Morty }\\n\\nlet _: Rick; // ok!\\n```\\n\\n`<u8 as Age>::Mythology` is a trait method, which is definitely not a type.\\nHowever, the `Age` trait provides an associated type `Empire` which can be\\nused as a type:\\n\\n```\\ntrait Age {\\n    type Empire;\\n    fn Mythology() {}\\n}\\n\\nimpl Age for u8 {\\n    type Empire = u16;\\n}\\n\\nlet _: <u8 as Age>::Empire; // ok!\\n```\\n\")),\n  (\"E0576\",\n   Some(\"An associated item wasn\\'t found in the given type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0576\\ntrait Hello {\\n    type Who;\\n\\n    fn hello() -> <Self as Hello>::You; // error!\\n}\\n```\\n\\nIn this example, we tried to use the non-existent associated type `You` of the\\n`Hello` trait. To fix this error, use an existing associated type:\\n\\n```\\ntrait Hello {\\n    type Who;\\n\\n    fn hello() -> <Self as Hello>::Who; // ok!\\n}\\n```\\n\")),\n  (\"E0577\",\n   Some(\"Something other than a module was found in visibility scope.\\n\\nErroneous code example:\\n\\n```compile_fail,E0577,edition2018\\npub struct Sea;\\n\\npub (in crate::Sea) struct Shark; // error!\\n\\nfn main() {}\\n```\\n\\n`Sea` is not a module, therefore it is invalid to use it in a visibility path.\\nTo fix this error we need to ensure `Sea` is a module.\\n\\nPlease note that the visibility scope can only be applied on ancestors!\\n\\n```edition2018\\npub mod Sea {\\n    pub (in crate::Sea) struct Shark; // ok!\\n}\\n\\nfn main() {}\\n```\\n\")),\n  (\"E0578\",\n   Some(\"A module cannot be found and therefore, the visibility cannot be determined.\\n\\nErroneous code example:\\n\\n```compile_fail,E0578,edition2018\\nfoo!();\\n\\npub (in ::Sea) struct Shark; // error!\\n\\nfn main() {}\\n```\\n\\nBecause of the call to the `foo` macro, the compiler guesses that the missing\\nmodule could be inside it and fails because the macro definition cannot be\\nfound.\\n\\nTo fix this error, please be sure that the module is in scope:\\n\\n```edition2018\\npub mod Sea {\\n    pub (in crate::Sea) struct Shark;\\n}\\n\\nfn main() {}\\n```\\n\")),\n  (\"E0579\",\n   Some(\"A lower range wasn\\'t less than the upper range.\\n\\nErroneous code example:\\n\\n```compile_fail,E0579\\n#![feature(exclusive_range_pattern)]\\n\\nfn main() {\\n    match 5u32 {\\n        // This range is ok, albeit pointless.\\n        1 .. 2 => {}\\n        // This range is empty, and the compiler can tell.\\n        5 .. 5 => {} // error!\\n    }\\n}\\n```\\n\\nWhen matching against an exclusive range, the compiler verifies that the range\\nis non-empty. Exclusive range patterns include the start point but not the end\\npoint, so this is equivalent to requiring the start of the range to be less\\nthan the end of the range.\\n\")),\n  (\"E0580\",\n   Some(\"The `main` function was incorrectly declared.\\n\\nErroneous code example:\\n\\n```compile_fail,E0580\\nfn main(x: i32) { // error: main function has wrong type\\n    println!(\\\"{}\\\", x);\\n}\\n```\\n\\nThe `main` function prototype should never take arguments.\\nExample:\\n\\n```\\nfn main() {\\n    // your code\\n}\\n```\\n\\nIf you want to get command-line arguments, use `std::env::args`. To exit with a\\nspecified exit code, use `std::process::exit`.\\n\")),\n  (\"E0581\",\n   Some(\"In a `fn` type, a lifetime appears only in the return type\\nand not in the arguments types.\\n\\nErroneous code example:\\n\\n```compile_fail,E0581\\nfn main() {\\n    // Here, `\\'a` appears only in the return type:\\n    let x: for<\\'a> fn() -> &\\'a i32;\\n}\\n```\\n\\nThe problem here is that the lifetime isn\\'t contrained by any of the arguments,\\nmaking it impossible to determine how long it\\'s supposed to live.\\n\\nTo fix this issue, either use the lifetime in the arguments, or use the\\n`\\'static` lifetime. Example:\\n\\n```\\nfn main() {\\n    // Here, `\\'a` appears only in the return type:\\n    let x: for<\\'a> fn(&\\'a i32) -> &\\'a i32;\\n    let y: fn() -> &\\'static i32;\\n}\\n```\\n\\nNote: The examples above used to be (erroneously) accepted by the\\ncompiler, but this was since corrected. See [issue #33685] for more\\ndetails.\\n\\n[issue #33685]: https://github.com/rust-lang/rust/issues/33685\\n\")),\n  (\"E0582\",\n   Some(\"A lifetime is only present in an associated-type binding, and not in the input\\ntypes to the trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0582\\nfn bar<F>(t: F)\\n    // No type can satisfy this requirement, since `\\'a` does not\\n    // appear in any of the input types (here, `i32`):\\n    where F: for<\\'a> Fn(i32) -> Option<&\\'a i32>\\n{\\n}\\n\\nfn main() { }\\n```\\n\\nTo fix this issue, either use the lifetime in the inputs, or use\\n`\\'static`. Example:\\n\\n```\\nfn bar<F, G>(t: F, u: G)\\n    where F: for<\\'a> Fn(&\\'a i32) -> Option<&\\'a i32>,\\n          G: Fn(i32) -> Option<&\\'static i32>,\\n{\\n}\\n\\nfn main() { }\\n```\\n\\nNote: The examples above used to be (erroneously) accepted by the\\ncompiler, but this was since corrected. See [issue #33685] for more\\ndetails.\\n\\n[issue #33685]: https://github.com/rust-lang/rust/issues/33685\\n\")),\n  (\"E0583\",\n   Some(\"A file wasn\\'t found for an out-of-line module.\\n\\nErroneous code example:\\n\\n```compile_fail,E0583\\nmod file_that_doesnt_exist; // error: file not found for module\\n\\nfn main() {}\\n```\\n\\nPlease be sure that a file corresponding to the module exists. If you\\nwant to use a module named `file_that_doesnt_exist`, you need to have a file\\nnamed `file_that_doesnt_exist.rs` or `file_that_doesnt_exist/mod.rs` in the\\nsame directory.\\n\")),\n  (\"E0584\",\n   Some(\"A doc comment that is not attached to anything has been encountered.\\n\\nErroneous code example:\\n\\n```compile_fail,E0584\\ntrait Island {\\n    fn lost();\\n\\n    /// I\\'m lost!\\n}\\n```\\n\\nA little reminder: a doc comment has to be placed before the item it\\'s supposed\\nto document. So if you want to document the `Island` trait, you need to put a\\ndoc comment before it, not inside it. Same goes for the `lost` method: the doc\\ncomment needs to be before it:\\n\\n```\\n/// I\\'m THE island!\\ntrait Island {\\n    /// I\\'m lost!\\n    fn lost();\\n}\\n```\\n\")),\n  (\"E0585\",\n   Some(\"A documentation comment that doesn\\'t document anything was found.\\n\\nErroneous code example:\\n\\n```compile_fail,E0585\\nfn main() {\\n    // The following doc comment will fail:\\n    /// This is a useless doc comment!\\n}\\n```\\n\\nDocumentation comments need to be followed by items, including functions,\\ntypes, modules, etc. Examples:\\n\\n```\\n/// I\\'m documenting the following struct:\\nstruct Foo;\\n\\n/// I\\'m documenting the following function:\\nfn foo() {}\\n```\\n\")),\n  (\"E0586\",\n   Some(\"An inclusive range was used with no end.\\n\\nErroneous code example:\\n\\n```compile_fail,E0586\\nfn main() {\\n    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\\n    let x = &tmp[1..=]; // error: inclusive range was used with no end\\n}\\n```\\n\\nAn inclusive range needs an end in order to *include* it. If you just need a\\nstart and no end, use a non-inclusive range (with `..`):\\n\\n```\\nfn main() {\\n    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\\n    let x = &tmp[1..]; // ok!\\n}\\n```\\n\\nOr put an end to your inclusive range:\\n\\n```\\nfn main() {\\n    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\\n    let x = &tmp[1..=3]; // ok!\\n}\\n```\\n\")),\n  (\"E0587\",\n   Some(\"A type has both `packed` and `align` representation hints.\\n\\nErroneous code example:\\n\\n```compile_fail,E0587\\n#[repr(packed, align(8))] // error!\\nstruct Umbrella(i32);\\n```\\n\\nYou cannot use `packed` and `align` hints on a same type. If you want to pack a\\ntype to a given size, you should provide a size to packed:\\n\\n```\\n#[repr(packed)] // ok!\\nstruct Umbrella(i32);\\n```\\n\")),\n  (\"E0588\",\n   Some(\"A type with `packed` representation hint has a field with `align`\\nrepresentation hint.\\n\\nErroneous code example:\\n\\n```compile_fail,E0588\\n#[repr(align(16))]\\nstruct Aligned(i32);\\n\\n#[repr(packed)] // error!\\nstruct Packed(Aligned);\\n```\\n\\nJust like you cannot have both `align` and `packed` representation hints on a\\nsame type, a `packed` type cannot contain another type with the `align`\\nrepresentation hint. However, you can do the opposite:\\n\\n```\\n#[repr(packed)]\\nstruct Packed(i32);\\n\\n#[repr(align(16))] // ok!\\nstruct Aligned(Packed);\\n```\\n\")),\n  (\"E0589\",\n   Some(\"The value of `N` that was specified for `repr(align(N))` was not a power\\nof two, or was greater than 2^29.\\n\\nErroneous code example:\\n\\n```compile_fail,E0589\\n#[repr(align(15))] // error: invalid `repr(align)` attribute: not a power of two\\nenum Foo {\\n    Bar(u64),\\n}\\n```\\n\")),\n  (\"E0590\",\n   Some(\"`break` or `continue` keywords were used in a condition of a `while` loop\\nwithout a label.\\n\\nErroneous code code:\\n\\n```compile_fail,E0590\\nwhile break {}\\n```\\n\\n`break` or `continue` must include a label when used in the condition of a\\n`while` loop.\\n\\nTo fix this, add a label specifying which loop is being broken out of:\\n\\n```\\n\\'foo: while break \\'foo {}\\n```\\n\")),\n  (\"E0591\",\n   Some(\"Per [RFC 401][rfc401], if you have a function declaration `foo`:\\n\\n```\\nstruct S;\\n\\n// For the purposes of this explanation, all of these\\n// different kinds of `fn` declarations are equivalent:\\n\\nfn foo(x: S) { /* ... */ }\\n# #[cfg(for_demonstration_only)]\\nextern \\\"C\\\" {\\n    fn foo(x: S);\\n}\\n# #[cfg(for_demonstration_only)]\\nimpl S {\\n    fn foo(self) { /* ... */ }\\n}\\n```\\n\\nthe type of `foo` is **not** `fn(S)`, as one might expect.\\nRather, it is a unique, zero-sized marker type written here as `typeof(foo)`.\\nHowever, `typeof(foo)` can be _coerced_ to a function pointer `fn(S)`,\\nso you rarely notice this:\\n\\n```\\n# struct S;\\n# fn foo(_: S) {}\\nlet x: fn(S) = foo; // OK, coerces\\n```\\n\\nThe reason that this matter is that the type `fn(S)` is not specific to\\nany particular function: it\\'s a function _pointer_. So calling `x()` results\\nin a virtual call, whereas `foo()` is statically dispatched, because the type\\nof `foo` tells us precisely what function is being called.\\n\\nAs noted above, coercions mean that most code doesn\\'t have to be\\nconcerned with this distinction. However, you can tell the difference\\nwhen using **transmute** to convert a fn item into a fn pointer.\\n\\nThis is sometimes done as part of an FFI:\\n\\n```compile_fail,E0591\\nextern \\\"C\\\" fn foo(userdata: Box<i32>) {\\n    /* ... */\\n}\\n\\n# fn callback(_: extern \\\"C\\\" fn(*mut i32)) {}\\n# use std::mem::transmute;\\nunsafe {\\n    let f: extern \\\"C\\\" fn(*mut i32) = transmute(foo);\\n    callback(f);\\n}\\n```\\n\\nHere, transmute is being used to convert the types of the fn arguments.\\nThis pattern is incorrect because, because the type of `foo` is a function\\n**item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\\nis a function pointer, which is not zero-sized.\\nThis pattern should be rewritten. There are a few possible ways to do this:\\n\\n- change the original fn declaration to match the expected signature,\\n  and do the cast in the fn body (the preferred option)\\n- cast the fn item of a fn pointer before calling transmute, as shown here:\\n\\n    ```\\n    # extern \\\"C\\\" fn foo(_: Box<i32>) {}\\n    # use std::mem::transmute;\\n    # unsafe {\\n    let f: extern \\\"C\\\" fn(*mut i32) = transmute(foo as extern \\\"C\\\" fn(_));\\n    let f: extern \\\"C\\\" fn(*mut i32) = transmute(foo as usize); // works too\\n    # }\\n    ```\\n\\nThe same applies to transmutes to `*mut fn()`, which were observed in practice.\\nNote though that use of this type is generally incorrect.\\nThe intention is typically to describe a function pointer, but just `fn()`\\nalone suffices for that. `*mut fn()` is a pointer to a fn pointer.\\n(Since these values are typically just passed to C code, however, this rarely\\nmakes a difference in practice.)\\n\\n[rfc401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\\n\")),\n  (\"E0592\",\n   Some(\"This error occurs when you defined methods or associated functions with same\\nname.\\n\\nErroneous code example:\\n\\n```compile_fail,E0592\\nstruct Foo;\\n\\nimpl Foo {\\n    fn bar() {} // previous definition here\\n}\\n\\nimpl Foo {\\n    fn bar() {} // duplicate definition here\\n}\\n```\\n\\nA similar error is E0201. The difference is whether there is one declaration\\nblock or not. To avoid this error, you must give each `fn` a unique name.\\n\\n```\\nstruct Foo;\\n\\nimpl Foo {\\n    fn bar() {}\\n}\\n\\nimpl Foo {\\n    fn baz() {} // define with different name\\n}\\n```\\n\")),\n  (\"E0593\",\n   Some(\"You tried to supply an `Fn`-based type with an incorrect number of arguments\\nthan what was expected.\\n\\nErroneous code example:\\n\\n```compile_fail,E0593\\nfn foo<F: Fn()>(x: F) { }\\n\\nfn main() {\\n    // [E0593] closure takes 1 argument but 0 arguments are required\\n    foo(|y| { });\\n}\\n```\\n\\nYou have to provide the same number of arguments as expected by the `Fn`-based\\ntype. So to fix the previous example, we need to remove the `y` argument:\\n\\n```\\nfn foo<F: Fn()>(x: F) { }\\n\\nfn main() {\\n    foo(|| { }); // ok!\\n}\\n```\\n\")),\n  (\"E0594\",\n   Some(\"A non-mutable value was assigned a value.\\n\\nErroneous code example:\\n\\n```compile_fail,E0594\\nstruct SolarSystem {\\n    earth: i32,\\n}\\n\\nlet ss = SolarSystem { earth: 3 };\\nss.earth = 2; // error!\\n```\\n\\nTo fix this error, declare `ss` as mutable by using the `mut` keyword:\\n\\n```\\nstruct SolarSystem {\\n    earth: i32,\\n}\\n\\nlet mut ss = SolarSystem { earth: 3 }; // declaring `ss` as mutable\\nss.earth = 2; // ok!\\n```\\n\")),\n  (\"E0595\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nClosures cannot mutate immutable captured variables.\\n\\nErroneous code example:\\n\\n```compile_fail,E0594\\nlet x = 3; // error: closure cannot assign to immutable local variable `x`\\nlet mut c = || { x += 1 };\\n```\\n\\nMake the variable binding mutable:\\n\\n```\\nlet mut x = 3; // ok!\\nlet mut c = || { x += 1 };\\n```\\n\")),\n  (\"E0596\",\n   Some(\"This error occurs because you tried to mutably borrow a non-mutable variable.\\n\\nErroneous code example:\\n\\n```compile_fail,E0596\\nlet x = 1;\\nlet y = &mut x; // error: cannot borrow mutably\\n```\\n\\nIn here, `x` isn\\'t mutable, so when we try to mutably borrow it in `y`, it\\nfails. To fix this error, you need to make `x` mutable:\\n\\n```\\nlet mut x = 1;\\nlet y = &mut x; // ok!\\n```\\n\")),\n  (\"E0597\",\n   Some(\"This error occurs because a value was dropped while it was still borrowed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0597\\nstruct Foo<\\'a> {\\n    x: Option<&\\'a u32>,\\n}\\n\\nlet mut x = Foo { x: None };\\n{\\n    let y = 0;\\n    x.x = Some(&y); // error: `y` does not live long enough\\n}\\nprintln!(\\\"{:?}\\\", x.x);\\n```\\n\\nHere, `y` is dropped at the end of the inner scope, but it is borrowed by\\n`x` until the `println`. To fix the previous example, just remove the scope\\nso that `y` isn\\'t dropped until after the println\\n\\n```\\nstruct Foo<\\'a> {\\n    x: Option<&\\'a u32>,\\n}\\n\\nlet mut x = Foo { x: None };\\n\\nlet y = 0;\\nx.x = Some(&y);\\n\\nprintln!(\\\"{:?}\\\", x.x);\\n```\\n\")),\n  (\"E0599\",\n   Some(\"This error occurs when a method is used on a type which doesn\\'t implement it:\\n\\nErroneous code example:\\n\\n```compile_fail,E0599\\nstruct Mouth;\\n\\nlet x = Mouth;\\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\\n               //        in the current scope\\n```\\n\\nIn this case, you need to implement the `chocolate` method to fix the error:\\n\\n```\\nstruct Mouth;\\n\\nimpl Mouth {\\n    fn chocolate(&self) { // We implement the `chocolate` method here.\\n        println!(\\\"Hmmm! I love chocolate!\\\");\\n    }\\n}\\n\\nlet x = Mouth;\\nx.chocolate(); // ok!\\n```\\n\")),\n  (\"E0600\",\n   Some(\"An unary operator was used on a type which doesn\\'t implement it.\\n\\nErroneous code example:\\n\\n```compile_fail,E0600\\nenum Question {\\n    Yes,\\n    No,\\n}\\n\\n!Question::Yes; // error: cannot apply unary operator `!` to type `Question`\\n```\\n\\nIn this case, `Question` would need to implement the `std::ops::Not` trait in\\norder to be able to use `!` on it. Let\\'s implement it:\\n\\n```\\nuse std::ops::Not;\\n\\nenum Question {\\n    Yes,\\n    No,\\n}\\n\\n// We implement the `Not` trait on the enum.\\nimpl Not for Question {\\n    type Output = bool;\\n\\n    fn not(self) -> bool {\\n        match self {\\n            Question::Yes => false, // If the `Answer` is `Yes`, then it\\n                                    // returns false.\\n            Question::No => true, // And here we do the opposite.\\n        }\\n    }\\n}\\n\\nassert_eq!(!Question::Yes, false);\\nassert_eq!(!Question::No, true);\\n```\\n\")),\n  (\"E0601\",\n   Some(\"No `main` function was found in a binary crate.\\n\\nTo fix this error, add a `main` function:\\n\\n```\\nfn main() {\\n    // Your program will start here.\\n    println!(\\\"Hello world!\\\");\\n}\\n```\\n\\nIf you don\\'t know the basics of Rust, you can look at the\\n[Rust Book][rust-book] to get started.\\n\\n[rust-book]: https://doc.rust-lang.org/book/\\n\")),\n  (\"E0602\",\n   Some(\"An unknown or invalid lint was used on the command line.\\n\\nErroneous code example:\\n\\n```sh\\nrustc -D bogus rust_file.rs\\n```\\n\\nMaybe you just misspelled the lint name or the lint doesn\\'t exist anymore.\\nEither way, try to update/remove it in order to fix the error.\\n\")),\n  (\"E0603\",\n   Some(\"A private item was used outside its scope.\\n\\nErroneous code example:\\n\\n```compile_fail,E0603\\nmod SomeModule {\\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\\n                                            // can\\'t use it outside of the\\n                                            // `SomeModule` module.\\n}\\n\\nprintln!(\\\"const value: {}\\\", SomeModule::PRIVATE); // error: constant `PRIVATE`\\n                                                  //        is private\\n```\\n\\nIn order to fix this error, you need to make the item public by using the `pub`\\nkeyword. Example:\\n\\n```\\nmod SomeModule {\\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\\n                                                // `pub` keyword.\\n}\\n\\nprintln!(\\\"const value: {}\\\", SomeModule::PRIVATE); // ok!\\n```\\n\")),\n  (\"E0604\",\n   Some(\"A cast to `char` was attempted on a type other than `u8`.\\n\\nErroneous code example:\\n\\n```compile_fail,E0604\\n0u32 as char; // error: only `u8` can be cast as `char`, not `u32`\\n```\\n\\nAs the error message indicates, only `u8` can be cast into `char`. Example:\\n\\n```\\nlet c = 86u8 as char; // ok!\\nassert_eq!(c, \\'V\\');\\n```\\n\\nFor more information about casts, take a look at the Type cast section in\\n[The Reference Book][1].\\n\\n[1]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\\n\")),\n  (\"E0605\",\n   Some(\"An invalid cast was attempted.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0605\\nlet x = 0u8;\\nx as Vec<u8>; // error: non-primitive cast: `u8` as `std::vec::Vec<u8>`\\n\\n// Another example\\n\\nlet v = core::ptr::null::<u8>(); // So here, `v` is a `*const u8`.\\nv as &u8; // error: non-primitive cast: `*const u8` as `&u8`\\n```\\n\\nOnly primitive types can be cast into each other. Examples:\\n\\n```\\nlet x = 0u8;\\nx as u32; // ok!\\n\\nlet v = core::ptr::null::<u8>();\\nv as *const i8; // ok!\\n```\\n\\nFor more information about casts, take a look at the Type cast section in\\n[The Reference Book][1].\\n\\n[1]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\\n\")),\n  (\"E0606\",\n   Some(\"An incompatible cast was attempted.\\n\\nErroneous code example:\\n\\n```compile_fail,E0606\\nlet x = &0u8; // Here, `x` is a `&u8`.\\nlet y: u32 = x as u32; // error: casting `&u8` as `u32` is invalid\\n```\\n\\nWhen casting, keep in mind that only primitive types can be cast into each\\nother. Example:\\n\\n```\\nlet x = &0u8;\\nlet y: u32 = *x as u32; // We dereference it first and then cast it.\\n```\\n\\nFor more information about casts, take a look at the Type cast section in\\n[The Reference Book][1].\\n\\n[1]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\\n\")),\n  (\"E0607\",\n   Some(\"A cast between a thin and a fat pointer was attempted.\\n\\nErroneous code example:\\n\\n```compile_fail,E0607\\nlet v = core::ptr::null::<u8>();\\nv as *const [u8];\\n```\\n\\nFirst: what are thin and fat pointers?\\n\\nThin pointers are \\\"simple\\\" pointers: they are purely a reference to a memory\\naddress.\\n\\nFat pointers are pointers referencing Dynamically Sized Types (also called\\nDSTs). DSTs don\\'t have a statically known size, therefore they can only exist\\nbehind some kind of pointer that contains additional information. For example,\\nslices and trait objects are DSTs. In the case of slices, the additional\\ninformation the fat pointer holds is their size.\\n\\nTo fix this error, don\\'t try to cast directly between thin and fat pointers.\\n\\nFor more information about type casts, take a look at the section of the\\n[The Rust Reference][1] on type cast expressions.\\n\\n[1]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\\n\")),\n  (\"E0608\",\n   Some(\"An attempt to use index on a type which doesn\\'t implement the `std::ops::Index`\\ntrait was performed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0608\\n0u8[2]; // error: cannot index into a value of type `u8`\\n```\\n\\nTo be able to index into a type it needs to implement the `std::ops::Index`\\ntrait. Example:\\n\\n```\\nlet v: Vec<u8> = vec![0, 1, 2, 3];\\n\\n// The `Vec` type implements the `Index` trait so you can do:\\nprintln!(\\\"{}\\\", v[2]);\\n```\\n\")),\n  (\"E0609\",\n   Some(\"Attempted to access a non-existent field in a struct.\\n\\nErroneous code example:\\n\\n```compile_fail,E0609\\nstruct StructWithFields {\\n    x: u32,\\n}\\n\\nlet s = StructWithFields { x: 0 };\\nprintln!(\\\"{}\\\", s.foo); // error: no field `foo` on type `StructWithFields`\\n```\\n\\nTo fix this error, check that you didn\\'t misspell the field\\'s name or that the\\nfield actually exists. Example:\\n\\n```\\nstruct StructWithFields {\\n    x: u32,\\n}\\n\\nlet s = StructWithFields { x: 0 };\\nprintln!(\\\"{}\\\", s.x); // ok!\\n```\\n\")),\n  (\"E0610\",\n   Some(\"Attempted to access a field on a primitive type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0610\\nlet x: u32 = 0;\\nprintln!(\\\"{}\\\", x.foo); // error: `{integer}` is a primitive type, therefore\\n                       //        doesn\\'t have fields\\n```\\n\\nPrimitive types are the most basic types available in Rust and don\\'t have\\nfields. To access data via named fields, struct types are used. Example:\\n\\n```\\n// We declare struct called `Foo` containing two fields:\\nstruct Foo {\\n    x: u32,\\n    y: i64,\\n}\\n\\n// We create an instance of this struct:\\nlet variable = Foo { x: 0, y: -12 };\\n// And we can now access its fields:\\nprintln!(\\\"x: {}, y: {}\\\", variable.x, variable.y);\\n```\\n\\nFor more information about [primitives] and [structs], take a look at the Book.\\n\\n[primitives]: https://doc.rust-lang.org/book/ch03-02-data-types.html\\n[structs]: https://doc.rust-lang.org/book/ch05-00-structs.html\\n\")),\n  (\"E0614\",\n   Some(\"Attempted to dereference a variable which cannot be dereferenced.\\n\\nErroneous code example:\\n\\n```compile_fail,E0614\\nlet y = 0u32;\\n*y; // error: type `u32` cannot be dereferenced\\n```\\n\\nOnly types implementing `std::ops::Deref` can be dereferenced (such as `&T`).\\nExample:\\n\\n```\\nlet y = 0u32;\\nlet x = &y;\\n// So here, `x` is a `&u32`, so we can dereference it:\\n*x; // ok!\\n```\\n\")),\n  (\"E0615\",\n   Some(\"Attempted to access a method like a field.\\n\\nErroneous code example:\\n\\n```compile_fail,E0615\\nstruct Foo {\\n    x: u32,\\n}\\n\\nimpl Foo {\\n    fn method(&self) {}\\n}\\n\\nlet f = Foo { x: 0 };\\nf.method; // error: attempted to take value of method `method` on type `Foo`\\n```\\n\\nIf you want to use a method, add `()` after it:\\n\\n```\\n# struct Foo { x: u32 }\\n# impl Foo { fn method(&self) {} }\\n# let f = Foo { x: 0 };\\nf.method();\\n```\\n\\nHowever, if you wanted to access a field of a struct check that the field name\\nis spelled correctly. Example:\\n\\n```\\n# struct Foo { x: u32 }\\n# impl Foo { fn method(&self) {} }\\n# let f = Foo { x: 0 };\\nprintln!(\\\"{}\\\", f.x);\\n```\\n\")),\n  (\"E0616\",\n   Some(\"Attempted to access a private field on a struct.\\n\\nErroneous code example:\\n\\n```compile_fail,E0616\\nmod some_module {\\n    pub struct Foo {\\n        x: u32, // So `x` is private in here.\\n    }\\n\\n    impl Foo {\\n        pub fn new() -> Foo { Foo { x: 0 } }\\n    }\\n}\\n\\nlet f = some_module::Foo::new();\\nprintln!(\\\"{}\\\", f.x); // error: field `x` of struct `some_module::Foo` is private\\n```\\n\\nIf you want to access this field, you have two options:\\n\\n1) Set the field public:\\n\\n```\\nmod some_module {\\n    pub struct Foo {\\n        pub x: u32, // `x` is now public.\\n    }\\n\\n    impl Foo {\\n        pub fn new() -> Foo { Foo { x: 0 } }\\n    }\\n}\\n\\nlet f = some_module::Foo::new();\\nprintln!(\\\"{}\\\", f.x); // ok!\\n```\\n\\n2) Add a getter function:\\n\\n```\\nmod some_module {\\n    pub struct Foo {\\n        x: u32, // So `x` is still private in here.\\n    }\\n\\n    impl Foo {\\n        pub fn new() -> Foo { Foo { x: 0 } }\\n\\n        // We create the getter function here:\\n        pub fn get_x(&self) -> &u32 { &self.x }\\n    }\\n}\\n\\nlet f = some_module::Foo::new();\\nprintln!(\\\"{}\\\", f.get_x()); // ok!\\n```\\n\")),\n  (\"E0617\",\n   Some(\"Attempted to pass an invalid type of variable into a variadic function.\\n\\nErroneous code example:\\n\\n```compile_fail,E0617\\n# use std::os::raw::{c_char, c_int};\\nextern \\\"C\\\" {\\n    fn printf(format: *const c_char, ...) -> c_int;\\n}\\n\\nunsafe {\\n    printf(\\\"%f\\\\n\\\\0\\\".as_ptr() as _, 0f32);\\n    // error: cannot pass an `f32` to variadic function, cast to `c_double`\\n}\\n```\\n\\nCertain Rust types must be cast before passing them to a variadic function,\\nbecause of arcane ABI rules dictated by the C standard. To fix the error,\\ncast the value to the type specified by the error message (which you may need\\nto import from `std::os::raw`).\\n\\nIn this case, `c_double` has the same size as `f64` so we can use it directly:\\n\\n```no_run\\n# use std::os::raw::{c_char, c_int};\\n# extern \\\"C\\\" {\\n#     fn printf(format: *const c_char, ...) -> c_int;\\n# }\\n\\nunsafe {\\n    printf(\\\"%f\\\\n\\\\0\\\".as_ptr() as _, 0f64); // ok!\\n}\\n```\\n\")),\n  (\"E0618\",\n   Some(\"Attempted to call something which isn\\'t a function nor a method.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0618\\nenum X {\\n    Entry,\\n}\\n\\nX::Entry(); // error: expected function, tuple struct or tuple variant,\\n            // found `X::Entry`\\n\\n// Or even simpler:\\nlet x = 0i32;\\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\\n```\\n\\nOnly functions and methods can be called using `()`. Example:\\n\\n```\\n// We declare a function:\\nfn i_am_a_function() {}\\n\\n// And we call it:\\ni_am_a_function();\\n```\\n\")),\n  (\"E0619\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThe type-checker needed to know the type of an expression, but that type had not\\nyet been inferred.\\n\\nErroneous code example:\\n\\n```compile_fail\\nlet mut x = vec![];\\nmatch x.pop() {\\n    Some(v) => {\\n        // Here, the type of `v` is not (yet) known, so we\\n        // cannot resolve this method call:\\n        v.to_uppercase(); // error: the type of this value must be known in\\n                          //        this context\\n    }\\n    None => {}\\n}\\n```\\n\\nType inference typically proceeds from the top of the function to the bottom,\\nfiguring out types as it goes. In some cases -- notably method calls and\\noverloadable operators like `*` -- the type checker may not have enough\\ninformation *yet* to make progress. This can be true even if the rest of the\\nfunction provides enough context (because the type-checker hasn\\'t looked that\\nfar ahead yet). In this case, type annotations can be used to help it along.\\n\\nTo fix this error, just specify the type of the variable. Example:\\n\\n```\\nlet mut x: Vec<String> = vec![]; // We precise the type of the vec elements.\\nmatch x.pop() {\\n    Some(v) => {\\n        v.to_uppercase(); // Since rustc now knows the type of the vec elements,\\n                          // we can use `v`\\'s methods.\\n    }\\n    None => {}\\n}\\n```\\n\")),\n  (\"E0620\",\n   Some(\"A cast to an unsized type was attempted.\\n\\nErroneous code example:\\n\\n```compile_fail,E0620\\nlet x = &[1_usize, 2] as [usize]; // error: cast to unsized type: `&[usize; 2]`\\n                                  //        as `[usize]`\\n```\\n\\nIn Rust, some types don\\'t have a known size at compile-time. For example, in a\\nslice type like `[u32]`, the number of elements is not known at compile-time and\\nhence the overall size cannot be computed. As a result, such types can only be\\nmanipulated through a reference (e.g., `&T` or `&mut T`) or other pointer-type\\n(e.g., `Box` or `Rc`). Try casting to a reference instead:\\n\\n```\\nlet x = &[1_usize, 2] as &[usize]; // ok!\\n```\\n\")),\n  (\"E0621\",\n   Some(\"This error code indicates a mismatch between the lifetimes appearing in the\\nfunction signature (i.e., the parameter types and the return type) and the\\ndata-flow found in the function body.\\n\\nErroneous code example:\\n\\n```compile_fail,E0621\\nfn foo<\\'a>(x: &\\'a i32, y: &i32) -> &\\'a i32 { // error: explicit lifetime\\n                                             //        required in the type of\\n                                             //        `y`\\n    if x > y { x } else { y }\\n}\\n```\\n\\nIn the code above, the function is returning data borrowed from either `x` or\\n`y`, but the `\\'a` annotation indicates that it is returning data only from `x`.\\nTo fix the error, the signature and the body must be made to match. Typically,\\nthis is done by updating the function signature. So, in this case, we change\\nthe type of `y` to `&\\'a i32`, like so:\\n\\n```\\nfn foo<\\'a>(x: &\\'a i32, y: &\\'a i32) -> &\\'a i32 {\\n    if x > y { x } else { y }\\n}\\n```\\n\\nNow the signature indicates that the function data borrowed from either `x` or\\n`y`. Alternatively, you could change the body to not return data from `y`:\\n\\n```\\nfn foo<\\'a>(x: &\\'a i32, y: &i32) -> &\\'a i32 {\\n    x\\n}\\n```\\n\")),\n  (\"E0622\",\n   Some(\"An intrinsic was declared without being a function.\\n\\nErroneous code example:\\n\\n```compile_fail,E0622\\n#![feature(intrinsics)]\\nextern \\\"rust-intrinsic\\\" {\\n    pub static breakpoint : fn(); // error: intrinsic must be a function\\n}\\n\\nfn main() { unsafe { breakpoint(); } }\\n```\\n\\nAn intrinsic is a function available for use in a given programming language\\nwhose implementation is handled specially by the compiler. In order to fix this\\nerror, just declare a function. Example:\\n\\n```no_run\\n#![feature(intrinsics)]\\nextern \\\"rust-intrinsic\\\" {\\n    pub fn breakpoint(); // ok!\\n}\\n\\nfn main() { unsafe { breakpoint(); } }\\n```\\n\")),\n  (\"E0623\",\n   Some(\"A lifetime didn\\'t match what was expected.\\n\\nErroneous code example:\\n\\n```compile_fail,E0623\\nstruct Foo<\\'a> {\\n    x: &\\'a isize,\\n}\\n\\nfn bar<\\'short, \\'long>(c: Foo<\\'short>, l: &\\'long isize) {\\n    let _: Foo<\\'long> = c; // error!\\n}\\n```\\n\\nIn this example, we tried to set a value with an incompatible lifetime to\\nanother one (`\\'long` is unrelated to `\\'short`). We can solve this issue in\\ntwo different ways:\\n\\nEither we make `\\'short` live at least as long as `\\'long`:\\n\\n```\\nstruct Foo<\\'a> {\\n    x: &\\'a isize,\\n}\\n\\n// we set \\'short to live at least as long as \\'long\\nfn bar<\\'short: \\'long, \\'long>(c: Foo<\\'short>, l: &\\'long isize) {\\n    let _: Foo<\\'long> = c; // ok!\\n}\\n```\\n\\nOr we use only one lifetime:\\n\\n```\\nstruct Foo<\\'a> {\\n    x: &\\'a isize,\\n}\\nfn bar<\\'short>(c: Foo<\\'short>, l: &\\'short isize) {\\n    let _: Foo<\\'short> = c; // ok!\\n}\\n```\\n\")),\n  (\"E0624\",\n   Some(\"A private item was used outside of its scope.\\n\\nErroneous code example:\\n\\n```compile_fail,E0624\\nmod inner {\\n    pub struct Foo;\\n\\n    impl Foo {\\n        fn method(&self) {}\\n    }\\n}\\n\\nlet foo = inner::Foo;\\nfoo.method(); // error: method `method` is private\\n```\\n\\nTwo possibilities are available to solve this issue:\\n\\n1. Only use the item in the scope it has been defined:\\n\\n```\\nmod inner {\\n    pub struct Foo;\\n\\n    impl Foo {\\n        fn method(&self) {}\\n    }\\n\\n    pub fn call_method(foo: &Foo) { // We create a public function.\\n        foo.method(); // Which calls the item.\\n    }\\n}\\n\\nlet foo = inner::Foo;\\ninner::call_method(&foo); // And since the function is public, we can call the\\n                          // method through it.\\n```\\n\\n2. Make the item public:\\n\\n```\\nmod inner {\\n    pub struct Foo;\\n\\n    impl Foo {\\n        pub fn method(&self) {} // It\\'s now public.\\n    }\\n}\\n\\nlet foo = inner::Foo;\\nfoo.method(); // Ok!\\n```\\n\")),\n  (\"E0625\",\n   Some(\"A compile-time const variable is referring to a thread-local static variable.\\n\\nErroneous code example:\\n\\n```compile_fail,E0625\\n#![feature(thread_local)]\\n\\n#[thread_local]\\nstatic X: usize = 12;\\n\\nconst Y: usize = 2 * X;\\n```\\n\\nStatic and const variables can refer to other const variables but a const\\nvariable cannot refer to a thread-local static variable. In this example,\\n`Y` cannot refer to `X`. To fix this, the value can be extracted as a const\\nand then used:\\n\\n```\\n#![feature(thread_local)]\\n\\nconst C: usize = 12;\\n\\n#[thread_local]\\nstatic X: usize = C;\\n\\nconst Y: usize = 2 * C;\\n```\\n\")),\n  (\"E0626\",\n   Some(\"This error occurs because a borrow in a generator persists across a\\nyield point.\\n\\nErroneous code example:\\n\\n```compile_fail,E0626\\n# #![feature(generators, generator_trait, pin)]\\n# use std::ops::Generator;\\n# use std::pin::Pin;\\nlet mut b = || {\\n    let a = &String::new(); // <-- This borrow...\\n    yield (); // ...is still in scope here, when the yield occurs.\\n    println!(\\\"{}\\\", a);\\n};\\nPin::new(&mut b).resume(());\\n```\\n\\nAt present, it is not permitted to have a yield that occurs while a\\nborrow is still in scope. To resolve this error, the borrow must\\neither be \\\"contained\\\" to a smaller scope that does not overlap the\\nyield or else eliminated in another way. So, for example, we might\\nresolve the previous example by removing the borrow and just storing\\nthe integer by value:\\n\\n```\\n# #![feature(generators, generator_trait, pin)]\\n# use std::ops::Generator;\\n# use std::pin::Pin;\\nlet mut b = || {\\n    let a = 3;\\n    yield ();\\n    println!(\\\"{}\\\", a);\\n};\\nPin::new(&mut b).resume(());\\n```\\n\\nThis is a very simple case, of course. In more complex cases, we may\\nwish to have more than one reference to the value that was borrowed --\\nin those cases, something like the `Rc` or `Arc` types may be useful.\\n\\nThis error also frequently arises with iteration:\\n\\n```compile_fail,E0626\\n# #![feature(generators, generator_trait, pin)]\\n# use std::ops::Generator;\\n# use std::pin::Pin;\\nlet mut b = || {\\n  let v = vec![1,2,3];\\n  for &x in &v { // <-- borrow of `v` is still in scope...\\n    yield x; // ...when this yield occurs.\\n  }\\n};\\nPin::new(&mut b).resume(());\\n```\\n\\nSuch cases can sometimes be resolved by iterating \\\"by value\\\" (or using\\n`into_iter()`) to avoid borrowing:\\n\\n```\\n# #![feature(generators, generator_trait, pin)]\\n# use std::ops::Generator;\\n# use std::pin::Pin;\\nlet mut b = || {\\n  let v = vec![1,2,3];\\n  for x in v { // <-- Take ownership of the values instead!\\n    yield x; // <-- Now yield is OK.\\n  }\\n};\\nPin::new(&mut b).resume(());\\n```\\n\\nIf taking ownership is not an option, using indices can work too:\\n\\n```\\n# #![feature(generators, generator_trait, pin)]\\n# use std::ops::Generator;\\n# use std::pin::Pin;\\nlet mut b = || {\\n  let v = vec![1,2,3];\\n  let len = v.len(); // (*)\\n  for i in 0..len {\\n    let x = v[i]; // (*)\\n    yield x; // <-- Now yield is OK.\\n  }\\n};\\nPin::new(&mut b).resume(());\\n\\n// (*) -- Unfortunately, these temporaries are currently required.\\n// See <https://github.com/rust-lang/rust/issues/43122>.\\n```\\n\")),\n  (\"E0627\",\n   Some(\"A yield expression was used outside of the generator literal.\\n\\nErroneous code example:\\n\\n```compile_fail,E0627\\n#![feature(generators, generator_trait)]\\n\\nfn fake_generator() -> &\\'static str {\\n    yield 1;\\n    return \\\"foo\\\"\\n}\\n\\nfn main() {\\n    let mut generator = fake_generator;\\n}\\n```\\n\\nThe error occurs because keyword `yield` can only be used inside the generator\\nliteral. This can be fixed by constructing the generator correctly.\\n\\n```\\n#![feature(generators, generator_trait)]\\n\\nfn main() {\\n    let mut generator = || {\\n        yield 1;\\n        return \\\"foo\\\"\\n    };\\n}\\n```\\n\")),\n  (\"E0628\",\n   Some(\"More than one parameter was used for a generator.\\n\\nErroneous code example:\\n\\n```compile_fail,E0628\\n#![feature(generators, generator_trait)]\\n\\nfn main() {\\n    let generator = |a: i32, b: i32| {\\n        // error: too many parameters for a generator\\n        // Allowed only 0 or 1 parameter\\n        yield a;\\n    };\\n}\\n```\\n\\nAt present, it is not permitted to pass more than one explicit\\nparameter for a generator.This can be fixed by using\\nat most 1 parameter for the generator. For example, we might resolve\\nthe previous example by passing only one parameter.\\n\\n```\\n#![feature(generators, generator_trait)]\\n\\nfn main() {\\n    let generator = |a: i32| {\\n        yield a;\\n    };\\n}\\n```\\n\")),\n  (\"E0631\",\n   Some(\"This error indicates a type mismatch in closure arguments.\\n\\nErroneous code example:\\n\\n```compile_fail,E0631\\nfn foo<F: Fn(i32)>(f: F) {\\n}\\n\\nfn main() {\\n    foo(|x: &str| {});\\n}\\n```\\n\\nThe error occurs because `foo` accepts a closure that takes an `i32` argument,\\nbut in `main`, it is passed a closure with a `&str` argument.\\n\\nThis can be resolved by changing the type annotation or removing it entirely\\nif it can be inferred.\\n\\n```\\nfn foo<F: Fn(i32)>(f: F) {\\n}\\n\\nfn main() {\\n    foo(|x: i32| {});\\n}\\n```\\n\")),\n  (\"E0632\",\n   Some(\"An explicit generic argument was provided when calling a function that\\nuses `impl Trait` in argument position.\\n\\nErroneous code example:\\n\\n```compile_fail,E0632\\nfn foo<T: Copy>(a: T, b: impl Clone) {}\\n\\nfoo::<i32>(0i32, \\\"abc\\\".to_string());\\n```\\n\\nEither all generic arguments should be inferred at the call site, or\\nthe function definition should use an explicit generic type parameter\\ninstead of `impl Trait`. Example:\\n\\n```\\nfn foo<T: Copy>(a: T, b: impl Clone) {}\\nfn bar<T: Copy, U: Clone>(a: T, b: U) {}\\n\\nfoo(0i32, \\\"abc\\\".to_string());\\n\\nbar::<i32, String>(0i32, \\\"abc\\\".to_string());\\nbar::<_, _>(0i32, \\\"abc\\\".to_string());\\nbar(0i32, \\\"abc\\\".to_string());\\n```\\n\")),\n  (\"E0633\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThe `unwind` attribute was malformed.\\n\\nErroneous code example:\\n\\n```compile_fail\\n#![feature(unwind_attributes)]\\n\\n#[unwind()] // error: expected one argument\\npub extern \\\"C\\\" fn something() {}\\n\\nfn main() {}\\n```\\n\\nThe `#[unwind]` attribute should be used as follows:\\n\\n- `#[unwind(aborts)]` -- specifies that if a non-Rust ABI function\\n  should abort the process if it attempts to unwind. This is the safer\\n  and preferred option.\\n\\n- `#[unwind(allowed)]` -- specifies that a non-Rust ABI function\\n  should be allowed to unwind. This can easily result in Undefined\\n  Behavior (UB), so be careful.\\n\\nNB. The default behavior here is \\\"allowed\\\", but this is unspecified\\nand likely to change in the future.\\n\")),\n  (\"E0634\",\n   Some(\"A type has conflicting `packed` representation hints.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0634\\n#[repr(packed, packed(2))] // error!\\nstruct Company(i32);\\n\\n#[repr(packed(2))] // error!\\n#[repr(packed)]\\nstruct Company(i32);\\n```\\n\\nYou cannot use conflicting `packed` hints on a same type. If you want to pack a\\ntype to a given size, you should provide a size to packed:\\n\\n```\\n#[repr(packed)] // ok!\\nstruct Company(i32);\\n```\\n\")),\n  (\"E0635\",\n   Some(\"The `#![feature]` attribute specified an unknown feature.\\n\\nErroneous code example:\\n\\n```compile_fail,E0635\\n#![feature(nonexistent_rust_feature)] // error: unknown feature\\n```\\n\")),\n  (\"E0636\",\n   Some(\"A `#![feature]` attribute was declared multiple times.\\n\\nErroneous code example:\\n\\n```compile_fail,E0636\\n#![allow(stable_features)]\\n#![feature(rust1)]\\n#![feature(rust1)] // error: the feature `rust1` has already been declared\\n```\\n\")),\n  (\"E0637\",\n   Some(\"`\\'_` lifetime name or `&T` without an explicit lifetime name has been used\\non illegal place.\\n\\nErroneous code example:\\n\\n```compile_fail,E0106,E0637\\nfn underscore_lifetime<\\'_>(str1: &\\'_ str, str2: &\\'_ str) -> &\\'_ str {\\n                     //^^ `\\'_` is a reserved lifetime name\\n    if str1.len() > str2.len() {\\n        str1\\n    } else {\\n        str2\\n    }\\n}\\n\\nfn and_without_explicit_lifetime<T>()\\nwhere\\n    T: Into<&u32>,\\n          //^ `&` without an explicit lifetime name\\n{\\n}\\n```\\n\\nFirst, `\\'_` cannot be used as a lifetime identifier in some places\\nbecause it is a reserved for the anonymous lifetime. Second, `&T`\\nwithout an explicit lifetime name cannot also be used in some places.\\nTo fix them, use a lowercase letter such as `\\'a`, or a series\\nof lowercase letters such as `\\'foo`. For more information about lifetime\\nidentifier, see [the book][bk-no]. For more information on using\\nthe anonymous lifetime in Rust 2018, see [the Rust 2018 blog post][blog-al].\\n\\nCorrected example:\\n\\n```\\nfn underscore_lifetime<\\'a>(str1: &\\'a str, str2: &\\'a str) -> &\\'a str {\\n    if str1.len() > str2.len() {\\n        str1\\n    } else {\\n        str2\\n    }\\n}\\n\\nfn and_without_explicit_lifetime<\\'foo, T>()\\nwhere\\n    T: Into<&\\'foo u32>,\\n{\\n}\\n```\\n\\n[bk-no]: https://doc.rust-lang.org/book/appendix-02-operators.html#non-operator-symbols\\n[blog-al]: https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#more-lifetime-elision-rules\\n\")),\n  (\"E0638\",\n   Some(\"This error indicates that the struct, enum or enum variant must be matched\\nnon-exhaustively as it has been marked as `non_exhaustive`.\\n\\nWhen applied within a crate, downstream users of the crate will need to use the\\n`_` pattern when matching enums and use the `..` pattern when matching structs.\\nDownstream crates cannot match against non-exhaustive enum variants.\\n\\nFor example, in the below example, since the enum is marked as\\n`non_exhaustive`, it is required that downstream crates match non-exhaustively\\non it.\\n\\n```rust,ignore (pseudo-Rust)\\n#[non_exhaustive]\\npub enum Error {\\n    Message(String),\\n    Other,\\n}\\n\\nimpl Display for Error {\\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\\n        // This will not error, despite being marked as non_exhaustive, as this\\n        // enum is defined within the current crate, it can be matched\\n        // exhaustively.\\n        let display = match self {\\n            Message(s) => s,\\n            Other => \\\"other or unknown error\\\",\\n        };\\n        formatter.write_str(display)\\n    }\\n}\\n```\\n\\nAn example of matching non-exhaustively on the above enum is provided below:\\n\\n```rust,ignore (pseudo-Rust)\\nuse mycrate::Error;\\n\\n// This will not error as the non_exhaustive Error enum has been matched with a\\n// wildcard.\\nmatch error {\\n    Message(s) => ...,\\n    Other => ...,\\n    _ => ...,\\n}\\n```\\n\\nSimilarly, for structs, match with `..` to avoid this error.\\n\")),\n  (\"E0639\",\n   Some(\"This error indicates that the struct, enum or enum variant cannot be\\ninstantiated from outside of the defining crate as it has been marked\\nas `non_exhaustive` and as such more fields/variants may be added in\\nfuture that could cause adverse side effects for this code.\\n\\nErroneous code example:\\n\\n```ignore (it only works cross-crate)\\n#[non_exhaustive]\\npub struct NormalStruct {\\n    pub first_field: u16,\\n    pub second_field: u16,\\n}\\n\\nlet ns = NormalStruct { first_field: 640, second_field: 480 }; // error!\\n```\\n\\nIt is recommended that you look for a `new` function or equivalent in the\\ncrate\\'s documentation.\\n\")),\n  (\"E0641\",\n   Some(\"Attempted to cast to/from a pointer with an unknown kind.\\n\\nErroneous code example:\\n\\n```compile_fail,E0641\\nlet b = 0 as *const _; // error\\n```\\n\\nType information must be provided if a pointer type being cast from/into another\\ntype which cannot be inferred:\\n\\n```\\n// Creating a pointer from reference: type can be inferred\\nlet a = &(String::from(\\\"Hello world!\\\")) as *const _; // ok!\\n\\nlet b = 0 as *const i32; // ok!\\n\\nlet c: *const i32 = 0 as *const _; // ok!\\n```\\n\")),\n  (\"E0642\",\n   Some(\"Trait methods currently cannot take patterns as arguments.\\n\\nErroneous code example:\\n\\n```compile_fail,E0642\\ntrait Foo {\\n    fn foo((x, y): (i32, i32)); // error: patterns aren\\'t allowed\\n                                //        in trait methods\\n}\\n```\\n\\nYou can instead use a single name for the argument:\\n\\n```\\ntrait Foo {\\n    fn foo(x_and_y: (i32, i32)); // ok!\\n}\\n```\\n\")),\n  (\"E0643\",\n   Some(\"This error indicates that there is a mismatch between generic parameters and\\nimpl Trait parameters in a trait declaration versus its impl.\\n\\n```compile_fail,E0643\\ntrait Foo {\\n    fn foo(&self, _: &impl Iterator);\\n}\\nimpl Foo for () {\\n    fn foo<U: Iterator>(&self, _: &U) { } // error method `foo` has incompatible\\n                                          // signature for trait\\n}\\n```\\n\")),\n  (\"E0644\",\n   Some(\"A closure or generator was constructed that references its own type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0644\\nfn fix<F>(f: &F)\\n  where F: Fn(&F)\\n{\\n    f(&f);\\n}\\n\\nfn main() {\\n    fix(&|y| {\\n        // Here, when `x` is called, the parameter `y` is equal to `x`.\\n    });\\n}\\n```\\n\\nRust does not permit a closure to directly reference its own type,\\neither through an argument (as in the example above) or by capturing\\nitself through its environment. This restriction helps keep closure\\ninference tractable.\\n\\nThe easiest fix is to rewrite your closure into a top-level function,\\nor into a method. In some cases, you may also be able to have your\\nclosure call itself by capturing a `&Fn()` object or `fn()` pointer\\nthat refers to itself. That is permitting, since the closure would be\\ninvoking itself via a virtual call, and hence does not directly\\nreference its own *type*.\\n\")),\n  (\"E0646\",\n   Some(\"It is not possible to define `main` with a where clause.\\n\\nErroneous code example:\\n\\n```compile_fail,E0646\\nfn main() where i32: Copy { // error: main function is not allowed to have\\n                            // a where clause\\n}\\n```\\n\")),\n  (\"E0647\",\n   Some(\"The `start` function was defined with a where clause.\\n\\nErroneous code example:\\n\\n```compile_fail,E0647\\n#![feature(start)]\\n\\n#[start]\\nfn start(_: isize, _: *const *const u8) -> isize where (): Copy {\\n    //^ error: start function is not allowed to have a where clause\\n    0\\n}\\n```\\n\")),\n  (\"E0648\",\n   Some(\"An `export_name` attribute contains null characters (`\\\\0`).\\n\\nErroneous code example:\\n\\n```compile_fail,E0648\\n#[export_name=\\\"\\\\0foo\\\"] // error: `export_name` may not contain null characters\\npub fn bar() {}\\n```\\n\\nTo fix this error, remove the null characters:\\n\\n```\\n#[export_name=\\\"foo\\\"] // ok!\\npub fn bar() {}\\n```\\n\")),\n  (\"E0657\",\n   Some(\"A lifetime bound on a trait implementation was captured at an incorrect place.\\n\\nErroneous code example:\\n\\n```compile_fail,E0657\\ntrait Id<T> {}\\ntrait Lt<\\'a> {}\\n\\nimpl<\\'a> Lt<\\'a> for () {}\\nimpl<T> Id<T> for T {}\\n\\nfn free_fn_capture_hrtb_in_impl_trait()\\n    -> Box<for<\\'a> Id<impl Lt<\\'a>>> // error!\\n{\\n    Box::new(())\\n}\\n\\nstruct Foo;\\nimpl Foo {\\n    fn impl_fn_capture_hrtb_in_impl_trait()\\n        -> Box<for<\\'a> Id<impl Lt<\\'a>>> // error!\\n    {\\n        Box::new(())\\n    }\\n}\\n```\\n\\nHere, you have used the inappropriate lifetime in the `impl Trait`,\\nThe `impl Trait` can only capture lifetimes bound at the fn or impl\\nlevel.\\n\\nTo fix this we have to define the lifetime at the function or impl\\nlevel and use that lifetime in the `impl Trait`. For example you can\\ndefine the lifetime at the function:\\n\\n```\\ntrait Id<T> {}\\ntrait Lt<\\'a> {}\\n\\nimpl<\\'a> Lt<\\'a> for () {}\\nimpl<T> Id<T> for T {}\\n\\nfn free_fn_capture_hrtb_in_impl_trait<\\'b>()\\n    -> Box<for<\\'a> Id<impl Lt<\\'b>>> // ok!\\n{\\n    Box::new(())\\n}\\n\\nstruct Foo;\\nimpl Foo {\\n    fn impl_fn_capture_hrtb_in_impl_trait<\\'b>()\\n        -> Box<for<\\'a> Id<impl Lt<\\'b>>> // ok!\\n    {\\n        Box::new(())\\n    }\\n}\\n```\\n\")),\n  (\"E0658\",\n   Some(\"An unstable feature was used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0658\\n#[repr(u128)] // error: use of unstable library feature \\'repr128\\'\\nenum Foo {\\n    Bar(u64),\\n}\\n```\\n\\nIf you\\'re using a stable or a beta version of rustc, you won\\'t be able to use\\nany unstable features. In order to do so, please switch to a nightly version of\\nrustc (by using [rustup]).\\n\\nIf you\\'re using a nightly version of rustc, just add the corresponding feature\\nto be able to use it:\\n\\n```\\n#![feature(repr128)]\\n\\n#[repr(u128)] // ok!\\nenum Foo {\\n    Bar(u64),\\n}\\n```\\n\\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\\n\")),\n  (\"E0659\",\n   Some(\"An item usage is ambiguous.\\n\\nErroneous code example:\\n\\n```compile_fail,edition2018,E0659\\npub mod moon {\\n    pub fn foo() {}\\n}\\n\\npub mod earth {\\n    pub fn foo() {}\\n}\\n\\nmod collider {\\n    pub use crate::moon::*;\\n    pub use crate::earth::*;\\n}\\n\\nfn main() {\\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\\n}\\n```\\n\\nThis error generally appears when two items with the same name are imported into\\na module. Here, the `foo` functions are imported and reexported from the\\n`collider` module and therefore, when we\\'re using `collider::foo()`, both\\nfunctions collide.\\n\\nTo solve this error, the best solution is generally to keep the path before the\\nitem when using it. Example:\\n\\n```edition2018\\npub mod moon {\\n    pub fn foo() {}\\n}\\n\\npub mod earth {\\n    pub fn foo() {}\\n}\\n\\nmod collider {\\n    pub use crate::moon;\\n    pub use crate::earth;\\n}\\n\\nfn main() {\\n    crate::collider::moon::foo(); // ok!\\n    crate::collider::earth::foo(); // ok!\\n}\\n```\\n\")),\n  (\"E0660\",\n   Some(\"The argument to the `llvm_asm` macro is not well-formed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0660\\nllvm_asm!(\\\"nop\\\" \\\"nop\\\");\\n```\\n\\nConsidering that this would be a long explanation, we instead recommend you\\ntake a look at the [`llvm_asm`] chapter of the Unstable book:\\n\\n[`llvm_asm`]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html\\n\")),\n  (\"E0661\",\n   Some(\"An invalid syntax was passed to the second argument of an `llvm_asm` macro line.\\n\\nErroneous code example:\\n\\n```compile_fail,E0661\\nlet a;\\nllvm_asm!(\\\"nop\\\" : \\\"r\\\"(a));\\n```\\n\\nConsidering that this would be a long explanation, we instead recommend you\\ntake a look at the [`llvm_asm`] chapter of the Unstable book:\\n\\n[`llvm_asm`]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html\\n\")),\n  (\"E0662\",\n   Some(\"An invalid input operand constraint was passed to the `llvm_asm` macro\\n(third line).\\n\\nErroneous code example:\\n\\n```compile_fail,E0662\\nllvm_asm!(\\\"xor %eax, %eax\\\"\\n          :\\n          : \\\"=test\\\"(\\\"a\\\")\\n         );\\n```\\n\\nConsidering that this would be a long explanation, we instead recommend you\\ntake a look at the [`llvm_asm`] chapter of the Unstable book:\\n\\n[`llvm_asm`]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html\\n\")),\n  (\"E0663\",\n   Some(\"An invalid input operand constraint was passed to the `llvm_asm` macro\\n(third line).\\n\\nErroneous code example:\\n\\n```compile_fail,E0663\\nllvm_asm!(\\\"xor %eax, %eax\\\"\\n          :\\n          : \\\"+test\\\"(\\\"a\\\")\\n         );\\n```\\n\\nConsidering that this would be a long explanation, we instead recommend you\\ntake a look at the [`llvm_asm`] chapter of the Unstable book:\\n\\n[`llvm_asm`]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html\\n\")),\n  (\"E0664\",\n   Some(\"A clobber was surrounded by braces in the `llvm_asm` macro.\\n\\nErroneous code example:\\n\\n```compile_fail,E0664\\nllvm_asm!(\\\"mov $$0x200, %eax\\\"\\n          :\\n          :\\n          : \\\"{eax}\\\"\\n         );\\n```\\n\\nConsidering that this would be a long explanation, we instead recommend you\\ntake a look at the [`llvm_asm`] chapter of the Unstable book:\\n\\n[`llvm_asm`]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html\\n\")),\n  (\"E0665\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nThe `Default` trait was derived on an enum.\\n\\nErroneous code example:\\n\\n```compile_fail\\n#[derive(Default)]\\nenum Food {\\n    Sweet,\\n    Salty,\\n}\\n```\\n\\nThe `Default` cannot be derived on an enum for the simple reason that the\\ncompiler doesn\\'t know which value to pick by default whereas it can for a\\nstruct as long as all its fields implement the `Default` trait as well.\\n\\nIf you still want to implement `Default` on your enum, you\\'ll have to do it \\\"by\\nhand\\\":\\n\\n```\\nenum Food {\\n    Sweet,\\n    Salty,\\n}\\n\\nimpl Default for Food {\\n    fn default() -> Food {\\n        Food::Sweet\\n    }\\n}\\n```\\n\")),\n  (\"E0666\",\n   Some(\"`impl Trait` types cannot appear nested in the generic arguments of other\\n`impl Trait` types.\\n\\nErroneous code example:\\n\\n```compile_fail,E0666\\ntrait MyGenericTrait<T> {}\\ntrait MyInnerTrait {}\\n\\nfn foo(\\n    bar: impl MyGenericTrait<impl MyInnerTrait>, // error!\\n) {}\\n```\\n\\nType parameters for `impl Trait` types must be explicitly defined as named\\ngeneric parameters:\\n\\n```\\ntrait MyGenericTrait<T> {}\\ntrait MyInnerTrait {}\\n\\nfn foo<T: MyInnerTrait>(\\n    bar: impl MyGenericTrait<T>, // ok!\\n) {}\\n```\\n\")),\n  (\"E0668\",\n   Some(\"Malformed inline assembly rejected by LLVM.\\n\\nErroneous code example:\\n\\n```compile_fail,E0668\\n#![feature(llvm_asm)]\\n\\nfn main() {\\n    let rax: u64;\\n    unsafe {\\n        llvm_asm!(\\\"\\\" :\\\"={rax\\\"(rax));\\n        println!(\\\"Accumulator is: {}\\\", rax);\\n    }\\n}\\n```\\n\\nLLVM checks the validity of the constraints and the assembly string passed to\\nit. This error implies that LLVM seems something wrong with the inline\\nassembly call.\\n\\nIn particular, it can happen if you forgot the closing bracket of a register\\nconstraint (see issue #51430), like in the previous code example.\\n\")),\n  (\"E0669\",\n   Some(\"Cannot convert inline assembly operand to a single LLVM value.\\n\\nErroneous code example:\\n\\n```compile_fail,E0669\\n#![feature(llvm_asm)]\\n\\nfn main() {\\n    unsafe {\\n        llvm_asm!(\\\"\\\" :: \\\"r\\\"(\\\"\\\")); // error!\\n    }\\n}\\n```\\n\\nThis error usually happens when trying to pass in a value to an input inline\\nassembly operand that is actually a pair of values. In particular, this can\\nhappen when trying to pass in a slice, for instance a `&str`. In Rust, these\\nvalues are represented internally as a pair of values, the pointer and its\\nlength. When passed as an input operand, this pair of values can not be\\ncoerced into a register and thus we must fail with an error.\\n\")),\n  (\"E0670\",\n   Some(\"Rust 2015 does not permit the use of `async fn`.\\n\\nErroneous code example:\\n\\n```compile_fail,E0670\\nasync fn foo() {}\\n```\\n\\nSwitch to the Rust 2018 edition to use `async fn`.\\n\")),\n  (\"E0671\",\n   Some(\"#### Note: this error code is no longer emitted by the compiler.\\n\\nConst parameters cannot depend on type parameters.\\nThe following is therefore invalid:\\n\\n```compile_fail,E0770\\nfn const_id<T, const N: T>() -> T { // error\\n    N\\n}\\n```\\n\")),\n  (\"E0687\",\n   Some(\"In-band lifetimes cannot be used in `fn`/`Fn` syntax.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0687\\n#![feature(in_band_lifetimes)]\\n\\nfn foo(x: fn(&\\'a u32)) {} // error!\\n\\nfn bar(x: &Fn(&\\'a u32)) {} // error!\\n\\nfn baz(x: fn(&\\'a u32), y: &\\'a u32) {} // error!\\n\\nstruct Foo<\\'a> { x: &\\'a u32 }\\n\\nimpl Foo<\\'a> {\\n    fn bar(&self, x: fn(&\\'a u32)) {} // error!\\n}\\n```\\n\\nLifetimes used in `fn` or `Fn` syntax must be explicitly\\ndeclared using `<...>` binders. For example:\\n\\n```\\nfn foo<\\'a>(x: fn(&\\'a u32)) {} // ok!\\n\\nfn bar<\\'a>(x: &Fn(&\\'a u32)) {} // ok!\\n\\nfn baz<\\'a>(x: fn(&\\'a u32), y: &\\'a u32) {} // ok!\\n\\nstruct Foo<\\'a> { x: &\\'a u32 }\\n\\nimpl<\\'a> Foo<\\'a> {\\n    fn bar(&self, x: fn(&\\'a u32)) {} // ok!\\n}\\n```\\n\")),\n  (\"E0688\",\n   Some(\"In-band lifetimes were mixed with explicit lifetime binders.\\n\\nErroneous code example:\\n\\n```compile_fail,E0688\\n#![feature(in_band_lifetimes)]\\n\\nfn foo<\\'a>(x: &\\'a u32, y: &\\'b u32) {}   // error!\\n\\nstruct Foo<\\'a> { x: &\\'a u32 }\\n\\nimpl Foo<\\'a> {\\n    fn bar<\\'b>(x: &\\'a u32, y: &\\'b u32, z: &\\'c u32) {}   // error!\\n}\\n\\nimpl<\\'b> Foo<\\'a> {  // error!\\n    fn baz() {}\\n}\\n```\\n\\nIn-band lifetimes cannot be mixed with explicit lifetime binders.\\nFor example:\\n\\n```\\nfn foo<\\'a, \\'b>(x: &\\'a u32, y: &\\'b u32) {}   // ok!\\n\\nstruct Foo<\\'a> { x: &\\'a u32 }\\n\\nimpl<\\'a> Foo<\\'a> {\\n    fn bar<\\'b,\\'c>(x: &\\'a u32, y: &\\'b u32, z: &\\'c u32) {}    // ok!\\n}\\n\\nimpl<\\'a> Foo<\\'a> {  // ok!\\n    fn baz() {}\\n}\\n```\\n\")),\n  (\"E0689\",\n   Some(\"A method was called on an ambiguous numeric type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0689\\n2.0.neg(); // error!\\n```\\n\\nThis error indicates that the numeric value for the method being passed exists\\nbut the type of the numeric value or binding could not be identified.\\n\\nThe error happens on numeric literals and on numeric bindings without an\\nidentified concrete type:\\n\\n```compile_fail,E0689\\nlet x = 2.0;\\nx.neg();  // same error as above\\n```\\n\\nBecause of this, you must give the numeric literal or binding a type:\\n\\n```\\nuse std::ops::Neg;\\n\\nlet _ = 2.0_f32.neg(); // ok!\\nlet x: f32 = 2.0;\\nlet _ = x.neg(); // ok!\\nlet _ = (2.0 as f32).neg(); // ok!\\n```\\n\")),\n  (\"E0690\",\n   Some(\"A struct with the representation hint `repr(transparent)` had two or more fields\\nthat were not guaranteed to be zero-sized.\\n\\nErroneous code example:\\n\\n```compile_fail,E0690\\n#[repr(transparent)]\\nstruct LengthWithUnit<U> { // error: transparent struct needs at most one\\n    value: f32,            //        non-zero-sized field, but has 2\\n    unit: U,\\n}\\n```\\n\\nBecause transparent structs are represented exactly like one of their fields at\\nrun time, said field must be uniquely determined. If there are multiple fields,\\nit is not clear how the struct should be represented.\\nNote that fields of zero-sized types (e.g., `PhantomData`) can also exist\\nalongside the field that contains the actual data, they do not count for this\\nerror. When generic types are involved (as in the above example), an error is\\nreported because the type parameter could be non-zero-sized.\\n\\nTo combine `repr(transparent)` with type parameters, `PhantomData` may be\\nuseful:\\n\\n```\\nuse std::marker::PhantomData;\\n\\n#[repr(transparent)]\\nstruct LengthWithUnit<U> {\\n    value: f32,\\n    unit: PhantomData<U>,\\n}\\n```\\n\")),\n  (\"E0691\",\n   Some(\"A struct, enum, or union with the `repr(transparent)` representation hint\\ncontains a zero-sized field that requires non-trivial alignment.\\n\\nErroneous code example:\\n\\n```compile_fail,E0691\\n#![feature(repr_align)]\\n\\n#[repr(align(32))]\\nstruct ForceAlign32;\\n\\n#[repr(transparent)]\\nstruct Wrapper(f32, ForceAlign32); // error: zero-sized field in transparent\\n                                   //        struct has alignment larger than 1\\n```\\n\\nA transparent struct, enum, or union is supposed to be represented exactly like\\nthe piece of data it contains. Zero-sized fields with different alignment\\nrequirements potentially conflict with this property. In the example above,\\n`Wrapper` would have to be aligned to 32 bytes even though `f32` has a smaller\\nalignment requirement.\\n\\nConsider removing the over-aligned zero-sized field:\\n\\n```\\n#[repr(transparent)]\\nstruct Wrapper(f32);\\n```\\n\\nAlternatively, `PhantomData<T>` has alignment 1 for all `T`, so you can use it\\nif you need to keep the field for some reason:\\n\\n```\\n#![feature(repr_align)]\\n\\nuse std::marker::PhantomData;\\n\\n#[repr(align(32))]\\nstruct ForceAlign32;\\n\\n#[repr(transparent)]\\nstruct Wrapper(f32, PhantomData<ForceAlign32>);\\n```\\n\\nNote that empty arrays `[T; 0]` have the same alignment requirement as the\\nelement type `T`. Also note that the error is conservatively reported even when\\nthe alignment of the zero-sized type is less than or equal to the data field\\'s\\nalignment.\\n\")),\n  (\"E0692\",\n   Some(\"A `repr(transparent)` type was also annotated with other, incompatible\\nrepresentation hints.\\n\\nErroneous code example:\\n\\n```compile_fail,E0692\\n#[repr(transparent, C)] // error: incompatible representation hints\\nstruct Grams(f32);\\n```\\n\\nA type annotated as `repr(transparent)` delegates all representation concerns to\\nanother type, so adding more representation hints is contradictory. Remove\\neither the `transparent` hint or the other hints, like this:\\n\\n```\\n#[repr(transparent)]\\nstruct Grams(f32);\\n```\\n\\nAlternatively, move the other attributes to the contained type:\\n\\n```\\n#[repr(C)]\\nstruct Foo {\\n    x: i32,\\n    // ...\\n}\\n\\n#[repr(transparent)]\\nstruct FooWrapper(Foo);\\n```\\n\\nNote that introducing another `struct` just to have a place for the other\\nattributes may have unintended side effects on the representation:\\n\\n```\\n#[repr(transparent)]\\nstruct Grams(f32);\\n\\n#[repr(C)]\\nstruct Float(f32);\\n\\n#[repr(transparent)]\\nstruct Grams2(Float); // this is not equivalent to `Grams` above\\n```\\n\\nHere, `Grams2` is a not equivalent to `Grams` -- the former transparently wraps\\na (non-transparent) struct containing a single float, while `Grams` is a\\ntransparent wrapper around a float. This can make a difference for the ABI.\\n\")),\n  (\"E0693\",\n   Some(\"`align` representation hint was incorrectly declared.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0693\\n#[repr(align=8)] // error!\\nstruct Align8(i8);\\n\\n#[repr(align=\\\"8\\\")] // error!\\nstruct Align8(i8);\\n```\\n\\nThis is a syntax error at the level of attribute declarations. The proper\\nsyntax for `align` representation hint is the following:\\n\\n```\\n#[repr(align(8))] // ok!\\nstruct Align8(i8);\\n```\\n\")),\n  (\"E0695\",\n   Some(\"A `break` statement without a label appeared inside a labeled block.\\n\\nErroneous code example:\\n\\n```compile_fail,E0695\\n# #![feature(label_break_value)]\\nloop {\\n    \\'a: {\\n        break;\\n    }\\n}\\n```\\n\\nMake sure to always label the `break`:\\n\\n```\\n# #![feature(label_break_value)]\\n\\'l: loop {\\n    \\'a: {\\n        break \\'l;\\n    }\\n}\\n```\\n\\nOr if you want to `break` the labeled block:\\n\\n```\\n# #![feature(label_break_value)]\\nloop {\\n    \\'a: {\\n        break \\'a;\\n    }\\n    break;\\n}\\n```\\n\")),\n  (\"E0696\",\n   Some(\"A function is using `continue` keyword incorrectly.\\n\\nErroneous code example:\\n\\n```compile_fail,E0696\\nfn continue_simple() {\\n    \\'b: {\\n        continue; // error!\\n    }\\n}\\nfn continue_labeled() {\\n    \\'b: {\\n        continue \\'b; // error!\\n    }\\n}\\nfn continue_crossing() {\\n    loop {\\n        \\'b: {\\n            continue; // error!\\n        }\\n    }\\n}\\n```\\n\\nHere we have used the `continue` keyword incorrectly. As we\\nhave seen above that `continue` pointing to a labeled block.\\n\\nTo fix this we have to use the labeled block properly.\\nFor example:\\n\\n```\\nfn continue_simple() {\\n    \\'b: loop {\\n        continue ; // ok!\\n    }\\n}\\nfn continue_labeled() {\\n    \\'b: loop {\\n        continue \\'b; // ok!\\n    }\\n}\\nfn continue_crossing() {\\n    loop {\\n        \\'b: loop {\\n            continue; // ok!\\n        }\\n    }\\n}\\n```\\n\")),\n  (\"E0697\",\n   Some(\"A closure has been used as `static`.\\n\\nErroneous code example:\\n\\n```compile_fail,E0697\\nfn main() {\\n    static || {}; // used as `static`\\n}\\n```\\n\\nClosures cannot be used as `static`. They \\\"save\\\" the environment,\\nand as such a static closure would save only a static environment\\nwhich would consist only of variables with a static lifetime. Given\\nthis it would be better to use a proper function. The easiest fix\\nis to remove the `static` keyword.\\n\")),\n  (\"E0698\",\n   Some(\"When using generators (or async) all type variables must be bound so a\\ngenerator can be constructed.\\n\\nErroneous code example:\\n\\n```edition2018,compile_fail,E0698\\nasync fn bar<T>() -> () {}\\n\\nasync fn foo() {\\n    bar().await; // error: cannot infer type for `T`\\n}\\n```\\n\\nIn the above example `T` is unknowable by the compiler.\\nTo fix this you must bind `T` to a concrete type such as `String`\\nso that a generator can then be constructed:\\n\\n```edition2018\\nasync fn bar<T>() -> () {}\\n\\nasync fn foo() {\\n    bar::<String>().await;\\n    //   ^^^^^^^^ specify type explicitly\\n}\\n```\\n\")),\n  (\"E0699\",\n   Some(\"A method was called on a raw pointer whose inner type wasn\\'t completely known.\\n\\nErroneous code example:\\n\\n```compile_fail,edition2018,E0699\\n# #![deny(warnings)]\\n# fn main() {\\nlet foo = &1;\\nlet bar = foo as *const _;\\nif bar.is_null() {\\n    // ...\\n}\\n# }\\n```\\n\\nHere, the type of `bar` isn\\'t known; it could be a pointer to anything. Instead,\\nspecify a type for the pointer (preferably something that makes sense for the\\nthing you\\'re pointing to):\\n\\n```\\nlet foo = &1;\\nlet bar = foo as *const i32;\\nif bar.is_null() {\\n    // ...\\n}\\n```\\n\\nEven though `is_null()` exists as a method on any raw pointer, Rust shows this\\nerror because  Rust allows for `self` to have arbitrary types (behind the\\narbitrary_self_types feature flag).\\n\\nThis means that someone can specify such a function:\\n\\n```ignore (cannot-doctest-feature-doesnt-exist-yet)\\nimpl Foo {\\n    fn is_null(self: *const Self) -> bool {\\n        // do something else\\n    }\\n}\\n```\\n\\nand now when you call `.is_null()` on a raw pointer to `Foo`, there\\'s ambiguity.\\n\\nGiven that we don\\'t know what type the pointer is, and there\\'s potential\\nambiguity for some types, we disallow calling methods on raw pointers when\\nthe type is unknown.\\n\")),\n  (\"E0700\",\n   Some(\"The `impl Trait` return type captures lifetime parameters that do not\\nappear within the `impl Trait` itself.\\n\\nErroneous code example:\\n\\n```compile_fail,E0700\\nuse std::cell::Cell;\\n\\ntrait Trait<\\'a> { }\\n\\nimpl<\\'a, \\'b> Trait<\\'b> for Cell<&\\'a u32> { }\\n\\nfn foo<\\'x, \\'y>(x: Cell<&\\'x u32>) -> impl Trait<\\'y>\\nwhere \\'x: \\'y\\n{\\n    x\\n}\\n```\\n\\nHere, the function `foo` returns a value of type `Cell<&\\'x u32>`,\\nwhich references the lifetime `\\'x`. However, the return type is\\ndeclared as `impl Trait<\\'y>` -- this indicates that `foo` returns\\n\\\"some type that implements `Trait<\\'y>`\\\", but it also indicates that\\nthe return type **only captures data referencing the lifetime `\\'y`**.\\nIn this case, though, we are referencing data with lifetime `\\'x`, so\\nthis function is in error.\\n\\nTo fix this, you must reference the lifetime `\\'x` from the return\\ntype. For example, changing the return type to `impl Trait<\\'y> + \\'x`\\nwould work:\\n\\n```\\nuse std::cell::Cell;\\n\\ntrait Trait<\\'a> { }\\n\\nimpl<\\'a,\\'b> Trait<\\'b> for Cell<&\\'a u32> { }\\n\\nfn foo<\\'x, \\'y>(x: Cell<&\\'x u32>) -> impl Trait<\\'y> + \\'x\\nwhere \\'x: \\'y\\n{\\n    x\\n}\\n```\\n\")),\n  (\"E0701\",\n   Some(\"This error indicates that a `#[non_exhaustive]` attribute was incorrectly placed\\non something other than a struct or enum.\\n\\nErroneous code example:\\n\\n```compile_fail,E0701\\n#[non_exhaustive]\\ntrait Foo { }\\n```\\n\")),\n  (\"E0703\",\n   Some(\"Invalid ABI (Application Binary Interface) used in the code.\\n\\nErroneous code example:\\n\\n```compile_fail,E0703\\nextern \\\"invalid\\\" fn foo() {} // error!\\n# fn main() {}\\n```\\n\\nAt present few predefined ABI\\'s (like Rust, C, system, etc.) can be\\nused in Rust. Verify that the ABI is predefined. For example you can\\nreplace the given ABI from \\'Rust\\'.\\n\\n```\\nextern \\\"Rust\\\" fn foo() {} // ok!\\n# fn main() { }\\n```\\n\")),\n  (\"E0704\",\n   Some(\"An incorrect visibility restriction was specified.\\n\\nErroneous code example:\\n\\n```compile_fail,E0704\\nmod foo {\\n    pub(foo) struct Bar {\\n        x: i32\\n    }\\n}\\n```\\n\\nTo make struct `Bar` only visible in module `foo` the `in` keyword should be\\nused:\\n\\n```\\nmod foo {\\n    pub(in crate::foo) struct Bar {\\n        x: i32\\n    }\\n}\\n# fn main() {}\\n```\\n\\nFor more information see the Rust Reference on [Visibility].\\n\\n[Visibility]: https://doc.rust-lang.org/reference/visibility-and-privacy.html\\n\")),\n  (\"E0705\",\n   Some(\"A `#![feature]` attribute was declared for a feature that is stable in the\\ncurrent edition, but not in all editions.\\n\\nErroneous code example:\\n\\n```ignore (limited to a warning during 2018 edition development)\\n#![feature(rust_2018_preview)]\\n#![feature(test_2018_feature)] // error: the feature\\n                               // `test_2018_feature` is\\n                               // included in the Rust 2018 edition\\n```\\n\")),\n  (\"E0706\",\n   Some(\"`async fn`s are not yet supported in traits in Rust.\\n\\nErroneous code example:\\n\\n```compile_fail,edition2018\\ntrait T {\\n    // Neither case is currently supported.\\n    async fn foo() {}\\n    async fn bar(&self) {}\\n}\\n```\\n\\n`async fn`s return an `impl Future`, making the following two examples\\nequivalent:\\n\\n```edition2018,ignore (example-of-desugaring-equivalence)\\nasync fn foo() -> User {\\n    unimplemented!()\\n}\\n// The async fn above gets desugared as follows:\\nfn foo(&self) -> impl Future<Output = User> + \\'_ {\\n    unimplemented!()\\n}\\n```\\n\\nBut when it comes to supporting this in traits, there are [a few implementation\\nissues][async-is-hard]. One of them is returning `impl Trait` in traits is not\\nsupported, as it would require [Generic Associated Types] to be supported:\\n\\n```edition2018,ignore (example-of-desugaring-equivalence)\\nimpl MyDatabase {\\n    async fn get_user(&self) -> User {\\n        unimplemented!()\\n    }\\n}\\n\\nimpl MyDatabase {\\n    fn get_user(&self) -> impl Future<Output = User> + \\'_ {\\n        unimplemented!()\\n    }\\n}\\n```\\n\\nUntil these issues are resolved, you can use the [`async-trait` crate], allowing\\nyou to use `async fn` in traits by desugaring to \\\"boxed futures\\\"\\n(`Pin<Box<dyn Future + Send + \\'async>>`).\\n\\nNote that using these trait methods will result in a heap allocation\\nper-function-call. This is not a significant cost for the vast majority of\\napplications, but should be considered when deciding whether to use this\\nfunctionality in the public API of a low-level function that is expected to be\\ncalled millions of times a second.\\n\\nYou might be interested in visiting the [async book] for further information.\\n\\n[`async-trait` crate]: https://crates.io/crates/async-trait\\n[async-is-hard]: https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/\\n[Generic Associated Types]: https://github.com/rust-lang/rust/issues/44265\\n[async book]: https://rust-lang.github.io/async-book/07_workarounds/06_async_in_traits.html\\n\")),\n  (\"E0708\",\n   Some(\"`async` non-`move` closures with parameters are currently not supported.\\n\\nErroneous code example:\\n\\n```compile_fail,edition2018,E0708\\n#![feature(async_closure)]\\n\\nfn main() {\\n    let add_one = async |num: u8| { // error!\\n        num + 1\\n    };\\n}\\n```\\n\\n`async` with non-move is currently not supported with the current\\nversion, you can use successfully by using move:\\n\\n```edition2018\\n#![feature(async_closure)]\\n\\nfn main() {\\n    let add_one = async move |num: u8| { // ok!\\n        num + 1\\n    };\\n}\\n```\\n\")),\n  (\"E0710\",\n   Some(\"An unknown tool name was found in a scoped lint.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0710\\n#[allow(clipp::filter_map)] // error!`\\nfn main() {\\n    // business logic\\n}\\n```\\n\\n```compile_fail,E0710\\n#[warn(clipp::filter_map)] // error!`\\nfn main() {\\n    // business logic\\n}\\n```\\n\\nPlease verify you didn\\'t misspell the tool\\'s name or that you didn\\'t\\nforget to import it in you project:\\n\\n```\\n#[allow(clippy::filter_map)] // ok!\\nfn main() {\\n    // business logic\\n}\\n```\\n\\n```\\n#[warn(clippy::filter_map)] // ok!\\nfn main() {\\n    // business logic\\n}\\n```\\n\")),\n  (\"E0712\",\n   Some(\"A borrow of a thread-local variable was made inside a function which outlived\\nthe lifetime of the function.\\n\\nErroneous code example:\\n\\n```compile_fail,E0712\\n#![feature(thread_local)]\\n\\n#[thread_local]\\nstatic FOO: u8 = 3;\\n\\nfn main() {\\n    let a = &FOO; // error: thread-local variable borrowed past end of function\\n\\n    std::thread::spawn(move || {\\n        println!(\\\"{}\\\", a);\\n    });\\n}\\n```\\n\")),\n  (\"E0713\",\n   Some(\"This error occurs when an attempt is made to borrow state past the end of the\\nlifetime of a type that implements the `Drop` trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0713\\n#![feature(nll)]\\n\\npub struct S<\\'a> { data: &\\'a mut String }\\n\\nimpl<\\'a> Drop for S<\\'a> {\\n    fn drop(&mut self) { self.data.push_str(\\\"being dropped\\\"); }\\n}\\n\\nfn demo<\\'a>(s: S<\\'a>) -> &\\'a mut String { let p = &mut *s.data; p }\\n```\\n\\nHere, `demo` tries to borrow the string data held within its\\nargument `s` and then return that borrow. However, `S` is\\ndeclared as implementing `Drop`.\\n\\nStructs implementing the `Drop` trait have an implicit destructor that\\ngets called when they go out of scope. This destructor gets exclusive\\naccess to the fields of the struct when it runs.\\n\\nThis means that when `s` reaches the end of `demo`, its destructor\\ngets exclusive access to its `&mut`-borrowed string data.  allowing\\nanother borrow of that string data (`p`), to exist across the drop of\\n`s` would be a violation of the principle that `&mut`-borrows have\\nexclusive, unaliased access to their referenced data.\\n\\nThis error can be fixed by changing `demo` so that the destructor does\\nnot run while the string-data is borrowed; for example by taking `S`\\nby reference:\\n\\n```\\npub struct S<\\'a> { data: &\\'a mut String }\\n\\nimpl<\\'a> Drop for S<\\'a> {\\n    fn drop(&mut self) { self.data.push_str(\\\"being dropped\\\"); }\\n}\\n\\nfn demo<\\'a>(s: &\\'a mut S<\\'a>) -> &\\'a mut String { let p = &mut *(*s).data; p }\\n```\\n\\nNote that this approach needs a reference to S with lifetime `\\'a`.\\nNothing shorter than `\\'a` will suffice: a shorter lifetime would imply\\nthat after `demo` finishes executing, something else (such as the\\ndestructor!) could access `s.data` after the end of that shorter\\nlifetime, which would again violate the `&mut`-borrow\\'s exclusive\\naccess.\\n\")),\n  (\"E0714\",\n   Some(\"A `#[marker]` trait contained an associated item.\\n\\nErroneous code example:\\n\\n```compile_fail,E0714\\n#![feature(marker_trait_attr)]\\n#![feature(associated_type_defaults)]\\n\\n#[marker]\\ntrait MarkerConst {\\n    const N: usize; // error!\\n}\\n\\nfn main() {}\\n```\\n\\nThe items of marker traits cannot be overridden, so there\\'s no need to have them\\nwhen they cannot be changed per-type anyway.  If you wanted them for ergonomic\\nreasons, consider making an extension trait instead.\\n\")),\n  (\"E0715\",\n   Some(\"An `impl` for a `#[marker]` trait tried to override an associated item.\\n\\nErroneous code example:\\n\\n```compile_fail,E0715\\n#![feature(marker_trait_attr)]\\n\\n#[marker]\\ntrait Marker {\\n    const N: usize = 0;\\n    fn do_something() {}\\n}\\n\\nstruct OverrideConst;\\nimpl Marker for OverrideConst { // error!\\n    const N: usize = 1;\\n}\\n# fn main() {}\\n```\\n\\nBecause marker traits are allowed to have multiple implementations for the same\\ntype, it\\'s not allowed to override anything in those implementations, as it\\nwould be ambiguous which override should actually be used.\\n\")),\n  (\"E0716\",\n   Some(\"A temporary value is being dropped while a borrow is still in active use.\\n\\nErroneous code example:\\n\\n```compile_fail,E0716\\nfn foo() -> i32 { 22 }\\nfn bar(x: &i32) -> &i32 { x }\\nlet p = bar(&foo());\\n         // ------ creates a temporary\\nlet q = *p;\\n```\\n\\nHere, the expression `&foo()` is borrowing the expression `foo()`. As `foo()` is\\na call to a function, and not the name of a variable, this creates a\\n**temporary** -- that temporary stores the return value from `foo()` so that it\\ncan be borrowed. You could imagine that `let p = bar(&foo());` is equivalent to\\nthe following, which uses an explicit temporary variable.\\n\\nErroneous code example:\\n\\n```compile_fail,E0597\\n# fn foo() -> i32 { 22 }\\n# fn bar(x: &i32) -> &i32 { x }\\nlet p = {\\n  let tmp = foo(); // the temporary\\n  bar(&tmp) // error: `tmp` does not live long enough\\n}; // <-- tmp is freed as we exit this block\\nlet q = p;\\n```\\n\\nWhenever a temporary is created, it is automatically dropped (freed) according\\nto fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing\\nstatement -- in this case, after the `let`. This is illustrated in the example\\nabove by showing that `tmp` would be freed as we exit the block.\\n\\nTo fix this problem, you need to create a local variable to store the value in\\nrather than relying on a temporary. For example, you might change the original\\nprogram to the following:\\n\\n```\\nfn foo() -> i32 { 22 }\\nfn bar(x: &i32) -> &i32 { x }\\nlet value = foo(); // dropped at the end of the enclosing block\\nlet p = bar(&value);\\nlet q = *p;\\n```\\n\\nBy introducing the explicit `let value`, we allocate storage that will last\\nuntil the end of the enclosing block (when `value` goes out of scope). When we\\nborrow `&value`, we are borrowing a local variable that already exists, and\\nhence no temporary is created.\\n\\nTemporaries are not always dropped at the end of the enclosing statement. In\\nsimple cases where the `&` expression is immediately stored into a variable, the\\ncompiler will automatically extend the lifetime of the temporary until the end\\nof the enclosing block. Therefore, an alternative way to fix the original\\nprogram is to write `let tmp = &foo()` and not `let tmp = foo()`:\\n\\n```\\nfn foo() -> i32 { 22 }\\nfn bar(x: &i32) -> &i32 { x }\\nlet value = &foo();\\nlet p = bar(value);\\nlet q = *p;\\n```\\n\\nHere, we are still borrowing `foo()`, but as the borrow is assigned directly\\ninto a variable, the temporary will not be dropped until the end of the\\nenclosing block. Similar rules apply when temporaries are stored into aggregate\\nstructures like a tuple or struct:\\n\\n```\\n// Here, two temporaries are created, but\\n// as they are stored directly into `value`,\\n// they are not dropped until the end of the\\n// enclosing block.\\nfn foo() -> i32 { 22 }\\nlet value = (&foo(), &foo());\\n```\\n\")),\n  (\"E0718\",\n   Some(\"A `#[lang = \\\"..\\\"]` attribute was placed on the wrong item type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0718\\n#![feature(lang_items)]\\n\\n#[lang = \\\"owned_box\\\"]\\nstatic X: u32 = 42;\\n```\\n\")),\n  (\"E0719\",\n   Some(\"An associated type value was specified more than once.\\n\\nErroneous code example:\\n\\n```compile_fail,E0719\\n#![feature(associated_type_bounds)]\\n\\ntrait FooTrait {}\\ntrait BarTrait {}\\n\\n// error: associated type `Item` in trait `Iterator` is specified twice\\nstruct Foo<T: Iterator<Item: FooTrait, Item: BarTrait>> { f: T }\\n```\\n\\n`Item` in trait `Iterator` cannot be specified multiple times for struct `Foo`.\\nTo fix this, create a new trait that is a combination of the desired traits and\\nspecify the associated type with the new trait.\\n\\nCorrected example:\\n\\n```\\n#![feature(associated_type_bounds)]\\n\\ntrait FooTrait {}\\ntrait BarTrait {}\\ntrait FooBarTrait: FooTrait + BarTrait {}\\n\\nstruct Foo<T: Iterator<Item: FooBarTrait>> { f: T } // ok!\\n```\\n\\nFor more information about associated types, see [the book][bk-at]. For more\\ninformation on associated type bounds, see [RFC 2289][rfc-2289].\\n\\n[bk-at]: https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types\\n[rfc-2289]: https://rust-lang.github.io/rfcs/2289-associated-type-bounds.html\\n\")),\n  (\"E0720\",\n   Some(\"An `impl Trait` type expands to a recursive type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0720\\nfn make_recursive_type() -> impl Sized {\\n    [make_recursive_type(), make_recursive_type()]\\n}\\n```\\n\\nAn `impl Trait` type must be expandable to a concrete type that contains no\\n`impl Trait` types. For example the previous example tries to create an\\n`impl Trait` type `T` that is equal to `[T, T]`.\\n\")),\n  (\"E0722\",\n   Some(\"The `optimize` attribute was malformed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0722\\n#![feature(optimize_attribute)]\\n\\n#[optimize(something)] // error: invalid argument\\npub fn something() {}\\n```\\n\\nThe `#[optimize]` attribute should be used as follows:\\n\\n- `#[optimize(size)]` -- instructs the optimization pipeline to generate code\\n  that\\'s smaller rather than faster\\n\\n- `#[optimize(speed)]` -- instructs the optimization pipeline to generate code\\n  that\\'s faster rather than smaller\\n\\nFor example:\\n\\n```\\n#![feature(optimize_attribute)]\\n\\n#[optimize(size)]\\npub fn something() {}\\n```\\n\\nSee [RFC 2412] for more details.\\n\\n[RFC 2412]: https://rust-lang.github.io/rfcs/2412-optimize-attr.html\\n\")),\n  (\"E0724\",\n   Some(\"`#[ffi_returns_twice]` was used on something other than a foreign function\\ndeclaration.\\n\\nErroneous code example:\\n\\n```compile_fail,E0724\\n#![feature(ffi_returns_twice)]\\n#![crate_type = \\\"lib\\\"]\\n\\n#[ffi_returns_twice] // error!\\npub fn foo() {}\\n```\\n\\n`#[ffi_returns_twice]` can only be used on foreign function declarations.\\nFor example, we might correct the previous example by declaring\\nthe function inside of an\\u{a0}`extern`\\u{a0}block.\\n\\n```\\n#![feature(ffi_returns_twice)]\\n\\nextern \\\"C\\\" {\\n   #[ffi_returns_twice] // ok!\\n   pub fn foo();\\n}\\n```\\n\")),\n  (\"E0725\",\n   Some(\"A feature attribute named a feature that was disallowed in the compiler\\ncommand line flags.\\n\\nErroneous code example:\\n\\n```ignore (can\\'t specify compiler flags from doctests)\\n#![feature(never_type)] // error: the feature `never_type` is not in\\n                        // the list of allowed features\\n```\\n\\nDelete the offending feature attribute, or add it to the list of allowed\\nfeatures in the `-Z allow_features` flag.\\n\")),\n  (\"E0727\",\n   Some(\"A `yield` clause was used in an `async` context.\\n\\nErroneous code example:\\n\\n```compile_fail,E0727,edition2018\\n#![feature(generators)]\\n\\nfn main() {\\n    let generator = || {\\n        async {\\n            yield;\\n        }\\n    };\\n}\\n```\\n\\nHere, the `yield` keyword is used in an `async` block,\\nwhich is not yet supported.\\n\\nTo fix this error, you have to move `yield` out of the `async` block:\\n\\n```edition2018\\n#![feature(generators)]\\n\\nfn main() {\\n    let generator = || {\\n        yield;\\n    };\\n}\\n```\\n\")),\n  (\"E0728\",\n   Some(\"[`await`] has been used outside [`async`] function or [`async`] block.\\n\\nErroneous code example:\\n\\n```edition2018,compile_fail,E0728\\n# use std::pin::Pin;\\n# use std::future::Future;\\n# use std::task::{Context, Poll};\\n#\\n# struct WakeOnceThenComplete(bool);\\n#\\n# fn wake_and_yield_once() -> WakeOnceThenComplete {\\n#     WakeOnceThenComplete(false)\\n# }\\n#\\n# impl Future for WakeOnceThenComplete {\\n#     type Output = ();\\n#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<\\'_>) -> Poll<()> {\\n#         if self.0 {\\n#             Poll::Ready(())\\n#         } else {\\n#             cx.waker().wake_by_ref();\\n#             self.0 = true;\\n#             Poll::Pending\\n#         }\\n#     }\\n# }\\n#\\nfn foo() {\\n    wake_and_yield_once().await // `await` is used outside `async` context\\n}\\n```\\n\\n[`await`] is used to suspend the current computation until the given\\nfuture is ready to produce a value. So it is legal only within\\nan [`async`] context, like an `async` function or an `async` block.\\n\\n```edition2018\\n# use std::pin::Pin;\\n# use std::future::Future;\\n# use std::task::{Context, Poll};\\n#\\n# struct WakeOnceThenComplete(bool);\\n#\\n# fn wake_and_yield_once() -> WakeOnceThenComplete {\\n#     WakeOnceThenComplete(false)\\n# }\\n#\\n# impl Future for WakeOnceThenComplete {\\n#     type Output = ();\\n#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<\\'_>) -> Poll<()> {\\n#         if self.0 {\\n#             Poll::Ready(())\\n#         } else {\\n#             cx.waker().wake_by_ref();\\n#             self.0 = true;\\n#             Poll::Pending\\n#         }\\n#     }\\n# }\\n#\\nasync fn foo() {\\n    wake_and_yield_once().await // `await` is used within `async` function\\n}\\n\\nfn bar(x: u8) -> impl Future<Output = u8> {\\n    async move {\\n        wake_and_yield_once().await; // `await` is used within `async` block\\n        x\\n    }\\n}\\n```\\n\\n[`async`]: https://doc.rust-lang.org/std/keyword.async.html\\n[`await`]: https://doc.rust-lang.org/std/keyword.await.html\\n\")),\n  (\"E0729\",\n   Some(\"Support for Non-Lexical Lifetimes (NLL) has been included in the Rust compiler\\nsince 1.31, and has been enabled on the 2015 edition since 1.36. The new borrow\\nchecker for NLL uncovered some bugs in the old borrow checker, which in some\\ncases allowed unsound code to compile, resulting in memory safety issues.\\n\\n### What do I do?\\n\\nChange your code so the warning does no longer trigger. For backwards\\ncompatibility, this unsound code may still compile (with a warning) right now.\\nHowever, at some point in the future, the compiler will no longer accept this\\ncode and will throw a hard error.\\n\\n### Shouldn\\'t you fix the old borrow checker?\\n\\nThe old borrow checker has known soundness issues that are basically impossible\\nto fix. The new NLL-based borrow checker is the fix.\\n\\n### Can I turn these warnings into errors by denying a lint?\\n\\nNo.\\n\\n### When are these warnings going to turn into errors?\\n\\nNo formal timeline for turning the warnings into errors has been set. See\\n[GitHub issue 58781](https://github.com/rust-lang/rust/issues/58781) for more\\ninformation.\\n\\n### Why do I get this message with code that doesn\\'t involve borrowing?\\n\\nThere are some known bugs that trigger this message.\\n\")),\n  (\"E0730\",\n   Some(\"An array without a fixed length was pattern-matched.\\n\\nErroneous code example:\\n\\n```compile_fail,E0730\\nfn is_123<const N: usize>(x: [u32; N]) -> bool {\\n    match x {\\n        [1, 2, ..] => true, // error: cannot pattern-match on an\\n                            //        array without a fixed length\\n        _ => false\\n    }\\n}\\n```\\n\\nTo fix this error, you have two solutions:\\n 1. Use an array with a fixed length.\\n 2. Use a slice.\\n\\nExample with an array with a fixed length:\\n\\n```\\nfn is_123(x: [u32; 3]) -> bool { // We use an array with a fixed size\\n    match x {\\n        [1, 2, ..] => true, // ok!\\n        _ => false\\n    }\\n}\\n```\\n\\nExample with a slice:\\n\\n```\\nfn is_123(x: &[u32]) -> bool { // We use a slice\\n    match x {\\n        [1, 2, ..] => true, // ok!\\n        _ => false\\n    }\\n}\\n```\\n\")),\n  (\"E0731\",\n   Some(\"An enum with the representation hint `repr(transparent)` had zero or more than\\none variants.\\n\\nErroneous code example:\\n\\n```compile_fail,E0731\\n#[repr(transparent)]\\nenum Status { // error: transparent enum needs exactly one variant, but has 2\\n    Errno(u32),\\n    Ok,\\n}\\n```\\n\\nBecause transparent enums are represented exactly like one of their variants at\\nrun time, said variant must be uniquely determined. If there is no variant, or\\nif there are multiple variants, it is not clear how the enum should be\\nrepresented.\\n\")),\n  (\"E0732\",\n   Some(\"An `enum` with a discriminant must specify a `#[repr(inttype)]`.\\n\\nErroneous code example:\\n\\n```compile_fail,E0732\\n#![feature(arbitrary_enum_discriminant)]\\n\\nenum Enum { // error!\\n    Unit = 1,\\n    Tuple() = 2,\\n    Struct{} = 3,\\n}\\n# fn main() {}\\n```\\n\\nA `#[repr(inttype)]` must be provided on an `enum` if it has a non-unit\\nvariant with a discriminant, or where there are both unit variants with\\ndiscriminants and non-unit variants. This restriction ensures that there\\nis a well-defined way to extract a variant\\'s discriminant from a value;\\nfor instance:\\n\\n```\\n#![feature(arbitrary_enum_discriminant)]\\n\\n#[repr(u8)]\\nenum Enum {\\n    Unit = 3,\\n    Tuple(u16) = 2,\\n    Struct {\\n        a: u8,\\n        b: u16,\\n    } = 1,\\n}\\n\\nfn discriminant(v : &Enum) -> u8 {\\n    unsafe { *(v as *const Enum as *const u8) }\\n}\\n\\nfn main() {\\n    assert_eq!(3, discriminant(&Enum::Unit));\\n    assert_eq!(2, discriminant(&Enum::Tuple(5)));\\n    assert_eq!(1, discriminant(&Enum::Struct{a: 7, b: 11}));\\n}\\n```\\n\")),\n  (\"E0733\",\n   Some(\"An [`async`] function used recursion without boxing.\\n\\nErroneous code example:\\n\\n```edition2018,compile_fail,E0733\\nasync fn foo(n: usize) {\\n    if n > 0 {\\n        foo(n - 1).await;\\n    }\\n}\\n```\\n\\nTo perform async recursion, the `async fn` needs to be desugared such that the\\n`Future` is explicit in the return type:\\n\\n```edition2018,compile_fail,E0720\\nuse std::future::Future;\\nfn foo_desugared(n: usize) -> impl Future<Output = ()> {\\n    async move {\\n        if n > 0 {\\n            foo_desugared(n - 1).await;\\n        }\\n    }\\n}\\n```\\n\\nFinally, the future is wrapped in a pinned box:\\n\\n```edition2018\\nuse std::future::Future;\\nuse std::pin::Pin;\\nfn foo_recursive(n: usize) -> Pin<Box<dyn Future<Output = ()>>> {\\n    Box::pin(async move {\\n        if n > 0 {\\n            foo_recursive(n - 1).await;\\n        }\\n    })\\n}\\n```\\n\\nThe `Box<...>` ensures that the result is of known size, and the pin is\\nrequired to keep it in the same place in memory.\\n\\n[`async`]: https://doc.rust-lang.org/std/keyword.async.html\\n\")),\n  (\"E0734\",\n   Some(\"A stability attribute has been used outside of the standard library.\\n\\nErroneous code example:\\n\\n```compile_fail,E0734\\n#[rustc_deprecated(since = \\\"b\\\", reason = \\\"text\\\")] // invalid\\n#[stable(feature = \\\"a\\\", since = \\\"b\\\")] // invalid\\n#[unstable(feature = \\\"b\\\", issue = \\\"none\\\")] // invalid\\nfn foo(){}\\n```\\n\\nThese attributes are meant to only be used by the standard library and are\\nrejected in your own crates.\\n\")),\n  (\"E0735\",\n   Some(\"Type parameter defaults cannot use `Self` on structs, enums, or unions.\\n\\nErroneous code example:\\n\\n```compile_fail,E0735\\nstruct Foo<X = Box<Self>> {\\n    field1: Option<X>,\\n    field2: Option<X>,\\n}\\n// error: type parameters cannot use `Self` in their defaults.\\n```\\n\")),\n  (\"E0736\",\n   Some(\"`#[track_caller]` and `#[naked]` cannot both be applied to the same function.\\n\\nErroneous code example:\\n\\n```compile_fail,E0736\\n#[naked]\\n#[track_caller]\\nfn foo() {}\\n```\\n\\nThis is primarily due to ABI incompatibilities between the two attributes.\\nSee [RFC 2091] for details on this and other limitations.\\n\\n[RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\\n\")),\n  (\"E0737\",\n   Some(\"`#[track_caller]` requires functions to have the `\\\"Rust\\\"` ABI for implicitly\\nreceiving caller location. See [RFC 2091] for details on this and other\\nrestrictions.\\n\\nErroneous code example:\\n\\n```compile_fail,E0737\\n#[track_caller]\\nextern \\\"C\\\" fn foo() {}\\n```\\n\\n[RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\\n\")),\n  (\"E0739\",\n   Some(\"`#[track_caller]` can not be applied on struct.\\n\\nErroneous code example:\\n\\n```compile_fail,E0739\\n#[track_caller]\\nstruct Bar {\\n    a: u8,\\n}\\n```\\n\\n[RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\\n\")),\n  (\"E0740\",\n   Some(\"A `union` was declared with fields with destructors.\\n\\nErroneous code example:\\n\\n```compile_fail,E0740\\nunion Test {\\n    a: A, // error!\\n}\\n\\n#[derive(Debug)]\\nstruct A(i32);\\n\\nimpl Drop for A {\\n    fn drop(&mut self) { println!(\\\"A\\\"); }\\n}\\n```\\n\\nA `union` cannot have fields with destructors.\\n\")),\n  (\"E0741\",\n   Some(\"A non-structural-match type was used as the type of a const generic parameter.\\n\\nErroneous code example:\\n\\n```compile_fail,E0741\\n#![feature(adt_const_params)]\\n\\nstruct A;\\n\\nstruct B<const X: A>; // error!\\n```\\n\\nOnly structural-match types (that is, types that derive `PartialEq` and `Eq`)\\nmay be used as the types of const generic parameters.\\n\\nTo fix the previous code example, we derive `PartialEq` and `Eq`:\\n\\n```\\n#![feature(adt_const_params)]\\n\\n#[derive(PartialEq, Eq)] // We derive both traits here.\\nstruct A;\\n\\nstruct B<const X: A>; // ok!\\n```\\n\")),\n  (\"E0742\",\n   Some(\"Visibility is restricted to a module which isn\\'t an ancestor of the current\\nitem.\\n\\nErroneous code example:\\n\\n```compile_fail,E0742,edition2018\\npub mod Sea {}\\n\\npub (in crate::Sea) struct Shark; // error!\\n\\nfn main() {}\\n```\\n\\nTo fix this error, we need to move the `Shark` struct inside the `Sea` module:\\n\\n```edition2018\\npub mod Sea {\\n    pub (in crate::Sea) struct Shark; // ok!\\n}\\n\\nfn main() {}\\n```\\n\\nOf course, you can do it as long as the module you\\'re referring to is an\\nancestor:\\n\\n```edition2018\\npub mod Earth {\\n    pub mod Sea {\\n        pub (in crate::Earth) struct Shark; // ok!\\n    }\\n}\\n\\nfn main() {}\\n```\\n\")),\n  (\"E0743\",\n   Some(\"The C-variadic type `...` has been nested inside another type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0743\\n#![feature(c_variadic)]\\n\\nfn foo2(x: u8, y: &...) {} // error!\\n```\\n\\nOnly foreign functions can use the C-variadic type (`...`). In such functions,\\n`...` may only occur non-nested. That is, `y: &\\'a ...` is not allowed.\\n\\nA C-variadic type is used to give an undefined number of parameters to a given\\nfunction (like `printf` in C). The equivalent in Rust would be to use macros\\ndirectly (like `println!` for example).\\n\")),\n  (\"E0744\",\n   Some(\"An unsupported expression was used inside a const context.\\n\\nErroneous code example:\\n\\n```compile_fail,edition2018,E0744\\nconst _: i32 = {\\n    async { 0 }.await\\n};\\n```\\n\\nAt the moment, `.await` is forbidden inside a `const`, `static`, or `const fn`.\\n\\nThis may be allowed at some point in the future, but the implementation is not\\nyet complete. See the tracking issue for [`async`] in `const fn`.\\n\\n[`async`]: https://github.com/rust-lang/rust/issues/69431\\n\")),\n  (\"E0745\",\n   Some(\"The address of temporary value was taken.\\n\\nErroneous code example:\\n\\n```compile_fail,E0745\\n# #![feature(raw_ref_op)]\\nfn temp_address() {\\n    let ptr = &raw const 2; // error!\\n}\\n```\\n\\nIn this example, `2` is destroyed right after the assignment, which means that\\n`ptr` now points to an unavailable location.\\n\\nTo avoid this error, first bind the temporary to a named local variable:\\n\\n```\\n# #![feature(raw_ref_op)]\\nfn temp_address() {\\n    let val = 2;\\n    let ptr = &raw const val; // ok!\\n}\\n```\\n\")),\n  (\"E0746\",\n   Some(\"An unboxed trait object was used as a return value.\\n\\nErroneous code example:\\n\\n```compile_fail,E0746\\ntrait T {\\n    fn bar(&self);\\n}\\nstruct S(usize);\\nimpl T for S {\\n    fn bar(&self) {}\\n}\\n\\n// Having the trait `T` as return type is invalid because\\n// unboxed trait objects do not have a statically known size:\\nfn foo() -> dyn T { // error!\\n    S(42)\\n}\\n```\\n\\nReturn types cannot be `dyn Trait`s as they must be `Sized`.\\n\\nTo avoid the error there are a couple of options.\\n\\nIf there is a single type involved, you can use [`impl Trait`]:\\n\\n```\\n# trait T {\\n#     fn bar(&self);\\n# }\\n# struct S(usize);\\n# impl T for S {\\n#     fn bar(&self) {}\\n# }\\n// The compiler will select `S(usize)` as the materialized return type of this\\n// function, but callers will only know that the return type implements `T`.\\nfn foo() -> impl T { // ok!\\n    S(42)\\n}\\n```\\n\\nIf there are multiple types involved, the only way you care to interact with\\nthem is through the trait\\'s interface, and having to rely on dynamic dispatch\\nis acceptable, then you can use [trait objects] with `Box`, or other container\\ntypes like `Rc` or `Arc`:\\n\\n```\\n# trait T {\\n#     fn bar(&self);\\n# }\\n# struct S(usize);\\n# impl T for S {\\n#     fn bar(&self) {}\\n# }\\nstruct O(&\\'static str);\\nimpl T for O {\\n    fn bar(&self) {}\\n}\\n\\n// This now returns a \\\"trait object\\\" and callers are only be able to access\\n// associated items from `T`.\\nfn foo(x: bool) -> Box<dyn T> { // ok!\\n    if x {\\n        Box::new(S(42))\\n    } else {\\n        Box::new(O(\\\"val\\\"))\\n    }\\n}\\n```\\n\\nFinally, if you wish to still be able to access the original type, you can\\ncreate a new `enum` with a variant for each type:\\n\\n```\\n# trait T {\\n#     fn bar(&self);\\n# }\\n# struct S(usize);\\n# impl T for S {\\n#     fn bar(&self) {}\\n# }\\n# struct O(&\\'static str);\\n# impl T for O {\\n#     fn bar(&self) {}\\n# }\\nenum E {\\n    S(S),\\n    O(O),\\n}\\n\\n// The caller can access the original types directly, but it needs to match on\\n// the returned `enum E`.\\nfn foo(x: bool) -> E {\\n    if x {\\n        E::S(S(42))\\n    } else {\\n        E::O(O(\\\"val\\\"))\\n    }\\n}\\n```\\n\\nYou can even implement the `trait` on the returned `enum` so the callers\\n*don\\'t* have to match on the returned value to invoke the associated items:\\n\\n```\\n# trait T {\\n#     fn bar(&self);\\n# }\\n# struct S(usize);\\n# impl T for S {\\n#     fn bar(&self) {}\\n# }\\n# struct O(&\\'static str);\\n# impl T for O {\\n#     fn bar(&self) {}\\n# }\\n# enum E {\\n#     S(S),\\n#     O(O),\\n# }\\nimpl T for E {\\n    fn bar(&self) {\\n        match self {\\n            E::S(s) => s.bar(),\\n            E::O(o) => o.bar(),\\n        }\\n    }\\n}\\n```\\n\\nIf you decide to use trait objects, be aware that these rely on\\n[dynamic dispatch], which has performance implications, as the compiler needs\\nto emit code that will figure out which method to call *at runtime* instead of\\nduring compilation. Using trait objects we are trading flexibility for\\nperformance.\\n\\n[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\\n[trait objects]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\\n[dynamic dispatch]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch\\n\")),\n  (\"E0747\",\n   Some(\"Generic arguments were not provided in the same order as the corresponding\\ngeneric parameters are declared.\\n\\nErroneous code example:\\n\\n```compile_fail,E0747\\nstruct S<\\'a, T>(&\\'a T);\\n\\ntype X = S<(), \\'static>; // error: the type argument is provided before the\\n                         // lifetime argument\\n```\\n\\nThe argument order should be changed to match the parameter declaration\\norder, as in the following:\\n\\n```\\nstruct S<\\'a, T>(&\\'a T);\\n\\ntype X = S<\\'static, ()>; // ok\\n```\\n\")),\n  (\"E0748\",\n   Some(\"A raw string isn\\'t correctly terminated because the trailing `#` count doesn\\'t\\nmatch its leading `#` count.\\n\\nErroneous code example:\\n\\n```compile_fail,E0748\\nlet dolphins = r##\\\"Dolphins!\\\"#; // error!\\n```\\n\\nTo terminate a raw string, you have to have the same number of `#` at the end\\nas at the beginning. Example:\\n\\n```\\nlet dolphins = r#\\\"Dolphins!\\\"#; // One `#` at the beginning, one at the end so\\n                               // all good!\\n```\\n\")),\n  (\"E0749\",\n   Some(\"An item was added on a negative impl.\\n\\nErroneous code example:\\n\\n```compile_fail,E0749\\n# #![feature(negative_impls)]\\ntrait MyTrait {\\n    type Foo;\\n}\\n\\nimpl !MyTrait for u32 {\\n    type Foo = i32; // error!\\n}\\n```\\n\\nNegative impls are not allowed to have any items. Negative impls declare that a\\ntrait is **not** implemented (and never will be) and hence there is no need to\\nspecify the values for trait methods or other items.\\n\\nOne way to fix this is to remove the items in negative impls:\\n\\n```\\n# #![feature(negative_impls)]\\ntrait MyTrait {\\n    type Foo;\\n}\\n\\nimpl !MyTrait for u32 {}\\n```\\n\")),\n  (\"E0750\",\n   Some(\"A negative impl was made default impl.\\n\\nErroneous code example:\\n\\n```compile_fail,E0750\\n# #![feature(negative_impls)]\\n# #![feature(specialization)]\\ntrait MyTrait {\\n    type Foo;\\n}\\n\\ndefault impl !MyTrait for u32 {} // error!\\n# fn main() {}\\n```\\n\\nNegative impls cannot be default impls. A default impl supplies default values\\nfor the items within to be used by other impls, whereas a negative impl declares\\nthat there are no other impls. Combining it does not make sense.\\n\")),\n  (\"E0751\",\n   Some(\"There are both a positive and negative trait implementation for the same type.\\n\\nErroneous code example:\\n\\n```compile_fail,E0751\\ntrait MyTrait {}\\nimpl MyTrait for i32 { }\\nimpl !MyTrait for i32 { } // error!\\n```\\n\\nNegative implementations are a promise that the trait will never be implemented\\nfor the given types. Therefore, both cannot exists at the same time.\\n\")),\n  (\"E0752\",\n   Some(\"The entry point of the program was marked as `async`.\\n\\nErroneous code example:\\n\\n```compile_fail,E0752\\nasync fn main() -> Result<(), ()> { // error!\\n    Ok(())\\n}\\n```\\n\\n`fn main()` or the specified start function is not allowed to be `async`. Not\\nhaving a correct async runtime library setup may cause this error. To fix it,\\ndeclare the entry point without `async`:\\n\\n```\\nfn main() -> Result<(), ()> { // ok!\\n    Ok(())\\n}\\n```\\n\")),\n  (\"E0753\",\n   Some(\"An inner doc comment was used in an invalid context.\\n\\nErroneous code example:\\n\\n```compile_fail,E0753\\nfn foo() {}\\n//! foo\\n// ^ error!\\nfn main() {}\\n```\\n\\nInner document can only be used before items. For example:\\n\\n```\\n//! A working comment applied to the module!\\nfn foo() {\\n    //! Another working comment!\\n}\\nfn main() {}\\n```\\n\\nIn case you want to document the item following the doc comment, you might want\\nto use outer doc comment:\\n\\n```\\n/// I am an outer doc comment\\n#[doc = \\\"I am also an outer doc comment!\\\"]\\nfn foo() {\\n    // ...\\n}\\n```\\n\")),\n  (\"E0754\",\n   Some(\"A non-ASCII identifier was used in an invalid context.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0754\\n\\nmod \\u{159}\\u{173}\\u{15b}\\u{165}; // error!\\n\\n#[no_mangle]\\nfn \\u{159}\\u{173}\\u{15b}\\u{165}() {} // error!\\n\\nfn main() {}\\n```\\n\\nNon-ASCII can be used as module names if it is inlined or if a `#[path]`\\nattribute is specified. For example:\\n\\n```\\nmod \\u{159}\\u{173}\\u{15b}\\u{165} { // ok!\\n    const IS_GREAT: bool = true;\\n}\\n\\nfn main() {}\\n```\\n\")),\n  (\"E0755\",\n   Some(\"The `ffi_pure` attribute was used on a non-foreign function.\\n\\nErroneous code example:\\n\\n```compile_fail,E0755\\n#![feature(ffi_pure)]\\n\\n#[ffi_pure] // error!\\npub fn foo() {}\\n# fn main() {}\\n```\\n\\nThe `ffi_pure` attribute can only be used on foreign functions which do not have\\nside effects or infinite loops:\\n\\n```\\n#![feature(ffi_pure)]\\n\\nextern \\\"C\\\" {\\n    #[ffi_pure] // ok!\\n    pub fn strlen(s: *const i8) -> isize;\\n}\\n# fn main() {}\\n```\\n\\nYou can find more information about it in the [unstable Rust Book].\\n\\n[unstable Rust Book]: https://doc.rust-lang.org/unstable-book/language-features/ffi-pure.html\\n\")),\n  (\"E0756\",\n   Some(\"The `ffi_const` attribute was used on something other than a foreign function\\ndeclaration.\\n\\nErroneous code example:\\n\\n```compile_fail,E0756\\n#![feature(ffi_const)]\\n\\n#[ffi_const] // error!\\npub fn foo() {}\\n# fn main() {}\\n```\\n\\nThe `ffi_const` attribute can only be used on foreign function declarations\\nwhich have no side effects except for their return value:\\n\\n```\\n#![feature(ffi_const)]\\n\\nextern \\\"C\\\" {\\n    #[ffi_const] // ok!\\n    pub fn strlen(s: *const i8) -> i32;\\n}\\n# fn main() {}\\n```\\n\\nYou can get more information about it in the [unstable Rust Book].\\n\\n[unstable Rust Book]: https://doc.rust-lang.org/nightly/unstable-book/language-features/ffi-const.html\\n\")),\n  (\"E0757\",\n   Some(\"A function was given both the `ffi_const` and `ffi_pure` attributes.\\n\\nErroneous code example:\\n\\n```compile_fail,E0757\\n#![feature(ffi_const, ffi_pure)]\\n\\nextern \\\"C\\\" {\\n    #[ffi_const]\\n    #[ffi_pure] // error: `#[ffi_const]` function cannot be `#[ffi_pure]`\\n    pub fn square(num: i32) -> i32;\\n}\\n```\\n\\nAs `ffi_const` provides stronger guarantees than `ffi_pure`, remove the\\n`ffi_pure` attribute:\\n\\n```\\n#![feature(ffi_const)]\\n\\nextern \\\"C\\\" {\\n    #[ffi_const]\\n    pub fn square(num: i32) -> i32;\\n}\\n```\\n\\nYou can get more information about `const` and `pure` in the [GCC documentation\\non Common Function Attributes]. The unstable Rust Book has more information\\nabout [`ffi_const`] and [`ffi_pure`].\\n\\n[GCC documentation on Common Function Attributes]: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html\\n[`ffi_const`]: https://doc.rust-lang.org/nightly/unstable-book/language-features/ffi-const.html\\n[`ffi_pure`]: https://doc.rust-lang.org/nightly/unstable-book/language-features/ffi-pure.html\\n\")),\n  (\"E0758\",\n   Some(\"A multi-line (doc-)comment is unterminated.\\n\\nErroneous code example:\\n\\n```compile_fail,E0758\\n/* I am not terminated!\\n```\\n\\nThe same goes for doc comments:\\n\\n```compile_fail,E0758\\n/*! I am not terminated!\\n```\\n\\nYou need to end your multi-line comment with `*/` in order to fix this error:\\n\\n```\\n/* I am terminated! */\\n/*! I am also terminated! */\\n```\\n\")),\n  (\"E0759\",\n   Some(\"Return type involving a trait did not require `\\'static` lifetime.\\n\\nErroneous code examples:\\n\\n```compile_fail,E0759\\nuse std::fmt::Debug;\\n\\nfn foo(x: &i32) -> impl Debug { // error!\\n    x\\n}\\n\\nfn bar(x: &i32) -> Box<dyn Debug> { // error!\\n    Box::new(x)\\n}\\n```\\n\\nAdd `\\'static` requirement to fix them:\\n\\n```\\n# use std::fmt::Debug;\\nfn foo(x: &\\'static i32) -> impl Debug + \\'static { // ok!\\n    x\\n}\\n\\nfn bar(x: &\\'static i32) -> Box<dyn Debug + \\'static> { // ok!\\n    Box::new(x)\\n}\\n```\\n\\nBoth [`dyn Trait`] and [`impl Trait`] in return types have an implicit\\n`\\'static` requirement, meaning that the value implementing them that is being\\nreturned has to be either a `\\'static` borrow or an owned value.\\n\\nIn order to change the requirement from `\\'static` to be a lifetime derived from\\nits arguments, you can add an explicit bound, either to an anonymous lifetime\\n`\\'_` or some appropriate named lifetime.\\n\\n```\\n# use std::fmt::Debug;\\nfn foo(x: &i32) -> impl Debug + \\'_ {\\n    x\\n}\\nfn bar(x: &i32) -> Box<dyn Debug + \\'_> {\\n    Box::new(x)\\n}\\n```\\n\\nThese are equivalent to the following explicit lifetime annotations:\\n\\n```\\n# use std::fmt::Debug;\\nfn foo<\\'a>(x: &\\'a i32) -> impl Debug + \\'a {\\n    x\\n}\\nfn bar<\\'a>(x: &\\'a i32) -> Box<dyn Debug + \\'a> {\\n    Box::new(x)\\n}\\n```\\n\\n[`dyn Trait`]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\\n[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\\n\")),\n  (\"E0760\",\n   Some(\"`async fn`/`impl trait` return type cannot contain a projection\\nor `Self` that references lifetimes from a parent scope.\\n\\nErroneous code example:\\n\\n```compile_fail,E0760,edition2018\\nstruct S<\\'a>(&\\'a i32);\\n\\nimpl<\\'a> S<\\'a> {\\n    async fn new(i: &\\'a i32) -> Self {\\n        S(&22)\\n    }\\n}\\n```\\n\\nTo fix this error we need to spell out `Self` to `S<\\'a>`:\\n\\n```edition2018\\nstruct S<\\'a>(&\\'a i32);\\n\\nimpl<\\'a> S<\\'a> {\\n    async fn new(i: &\\'a i32) -> S<\\'a> {\\n        S(&22)\\n    }\\n}\\n```\\n\\nThis will be allowed at some point in the future,\\nbut the implementation is not yet complete.\\nSee the [issue-61949] for this limitation.\\n\\n[issue-61949]: https://github.com/rust-lang/rust/issues/61949\\n\")),\n  (\"E0761\",\n   Some(\"Multiple candidate files were found for an out-of-line module.\\n\\nErroneous code example:\\n\\n```ignore (Multiple source files are required for compile_fail.)\\n// file: ambiguous_module/mod.rs\\n\\nfn foo() {}\\n\\n// file: ambiguous_module.rs\\n\\nfn foo() {}\\n\\n// file: lib.rs\\n\\nmod ambiguous_module; // error: file for module `ambiguous_module`\\n                      // found at both ambiguous_module.rs and\\n                      // ambiguous_module.rs/mod.rs\\n```\\n\\nPlease remove this ambiguity by deleting/renaming one of the candidate files.\\n\")),\n  (\"E0762\",\n   Some(\"A character literal wasn\\'t ended with a quote.\\n\\nErroneous code example:\\n\\n```compile_fail,E0762\\nstatic C: char = \\'\\u{25cf}; // error!\\n```\\n\\nTo fix this error, add the missing quote:\\n\\n```\\nstatic C: char = \\'\\u{25cf}\\'; // ok!\\n```\\n\")),\n  (\"E0763\",\n   Some(\"A byte constant wasn\\'t correctly ended.\\n\\nErroneous code example:\\n\\n```compile_fail,E0763\\nlet c = b\\'a; // error!\\n```\\n\\nTo fix this error, add the missing quote:\\n\\n```\\nlet c = b\\'a\\'; // ok!\\n```\\n\")),\n  (\"E0764\",\n   Some(\"A mutable reference was used in a constant.\\n\\nErroneous code example:\\n\\n```compile_fail,E0764\\n#![feature(const_mut_refs)]\\n\\nfn main() {\\n    const OH_NO: &\\'static mut usize = &mut 1; // error!\\n}\\n```\\n\\nMutable references (`&mut`) can only be used in constant functions, not statics\\nor constants. This limitation exists to prevent the creation of constants that\\nhave a mutable reference in their final value. If you had a constant of\\n`&mut i32` type, you could modify the value through that reference, making the\\nconstant essentially mutable.\\n\\nWhile there could be a more fine-grained scheme in the future that allows\\nmutable references if they are not \\\"leaked\\\" to the final value, a more\\nconservative approach was chosen for now. `const fn` do not have this problem,\\nas the borrow checker will prevent the `const fn` from returning new mutable\\nreferences.\\n\\nRemember: you cannot use a function call inside a constant or static. However,\\nyou can totally use it in constant functions:\\n\\n```\\n#![feature(const_mut_refs)]\\n\\nconst fn foo(x: usize) -> usize {\\n    let mut y = 1;\\n    let z = &mut y;\\n    *z += x;\\n    y\\n}\\n\\nfn main() {\\n    const FOO: usize = foo(10); // ok!\\n}\\n```\\n\")),\n  (\"E0765\",\n   Some(\"A double quote string (`\\\"`) was not terminated.\\n\\nErroneous code example:\\n\\n```compile_fail,E0765\\nlet s = \\\"; // error!\\n```\\n\\nTo fix this error, add the missing double quote at the end of the string:\\n\\n```\\nlet s = \\\"\\\"; // ok!\\n```\\n\")),\n  (\"E0766\",\n   Some(\"A double quote byte string (`b\\\"`) was not terminated.\\n\\nErroneous code example:\\n\\n```compile_fail,E0766\\nlet s = b\\\"; // error!\\n```\\n\\nTo fix this error, add the missing double quote at the end of the string:\\n\\n```\\nlet s = b\\\"\\\"; // ok!\\n```\\n\")),\n  (\"E0767\",\n   Some(\"An unreachable label was used.\\n\\nErroneous code example:\\n\\n```compile_fail,E0767\\n\\'a: loop {\\n    || {\\n        loop { break \\'a } // error: use of unreachable label `\\'a`\\n    };\\n}\\n```\\n\\nEnsure that the label is within scope. Labels are not reachable through\\nfunctions, closures, async blocks or modules. Example:\\n\\n```\\n\\'a: loop {\\n    break \\'a; // ok!\\n}\\n```\\n\")),\n  (\"E0768\",\n   Some(\"A number in a non-decimal base has no digits.\\n\\nErroneous code example:\\n\\n```compile_fail,E0768\\nlet s: i32 = 0b; // error!\\n```\\n\\nTo fix this error, add the missing digits:\\n\\n```\\nlet s: i32 = 0b1; // ok!\\n```\\n\")),\n  (\"E0769\",\n   Some(\"A tuple struct or tuple variant was used in a pattern as if it were a struct or\\nstruct variant.\\n\\nErroneous code example:\\n\\n```compile_fail,E0769\\nenum E {\\n    A(i32),\\n}\\n\\nlet e = E::A(42);\\n\\nmatch e {\\n    E::A { number } => { // error!\\n        println!(\\\"{}\\\", number);\\n    }\\n}\\n```\\n\\nTo fix this error, you can use the tuple pattern:\\n\\n```\\n# enum E {\\n#     A(i32),\\n# }\\n# let e = E::A(42);\\nmatch e {\\n    E::A(number) => { // ok!\\n        println!(\\\"{}\\\", number);\\n    }\\n}\\n```\\n\\nAlternatively, you can also use the struct pattern by using the correct field\\nnames and binding them to new identifiers:\\n\\n```\\n# enum E {\\n#     A(i32),\\n# }\\n# let e = E::A(42);\\nmatch e {\\n    E::A { 0: number } => { // ok!\\n        println!(\\\"{}\\\", number);\\n    }\\n}\\n```\\n\")),\n  (\"E0770\",\n   Some(\"The type of a const parameter references other generic parameters.\\n\\nErroneous code example:\\n\\n```compile_fail,E0770\\nfn foo<T, const N: T>() {} // error!\\n```\\n\\nTo fix this error, use a concrete type for the const parameter:\\n\\n```\\nfn foo<T, const N: usize>() {}\\n```\\n\")),\n  (\"E0771\",\n   Some(\"A non-`\\'static` lifetime was used in a const generic. This is currently not\\nallowed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0771\\n#![feature(adt_const_params)]\\n\\nfn function_with_str<\\'a, const STRING: &\\'a str>() {} // error!\\n```\\n\\nTo fix this issue, the lifetime in the const generic need to be changed to\\n`\\'static`:\\n\\n```\\n#![feature(adt_const_params)]\\n\\nfn function_with_str<const STRING: &\\'static str>() {} // ok!\\n```\\n\\nFor more information, see [GitHub issue #74052].\\n\\n[GitHub issue #74052]: https://github.com/rust-lang/rust/issues/74052\\n\")),\n  (\"E0773\",\n   Some(\"A builtin-macro was defined more than once.\\n\\nErroneous code example:\\n\\n```compile_fail,E0773\\n#![feature(decl_macro)]\\n#![feature(rustc_attrs)]\\n\\n#[rustc_builtin_macro]\\npub macro test($item:item) {\\n    /* compiler built-in */\\n}\\n\\nmod inner {\\n    #[rustc_builtin_macro]\\n    pub macro test($item:item) {\\n        /* compiler built-in */\\n    }\\n}\\n```\\n\\nTo fix the issue, remove the duplicate declaration:\\n\\n```\\n#![feature(decl_macro)]\\n#![feature(rustc_attrs)]\\n\\n#[rustc_builtin_macro]\\npub macro test($item:item) {\\n    /* compiler built-in */\\n}\\n```\\n\\nIn very rare edge cases, this may happen when loading `core` or `std` twice,\\nonce with `check` metadata and once with `build` metadata.\\nFor more information, see [#75176].\\n\\n[#75176]: https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468\\n\")),\n  (\"E0774\",\n   Some(\"`derive` was applied on something which is not a struct, a union or an enum.\\n\\nErroneous code example:\\n\\n```compile_fail,E0774\\ntrait Foo {\\n    #[derive(Clone)] // error!\\n    type Bar;\\n}\\n```\\n\\nAs said above, the `derive` attribute is only allowed on structs, unions or\\nenums:\\n\\n```\\n#[derive(Clone)] // ok!\\nstruct Bar {\\n    field: u32,\\n}\\n```\\n\\nYou can find more information about `derive` in the [Rust Book].\\n\\n[Rust Book]: https://doc.rust-lang.org/book/appendix-03-derivable-traits.html\\n\")),\n  (\"E0775\",\n   Some(\"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M\\nextension.\\n\\nErroneous code example:\\n\\n```compile_fail,E0775\\n#![feature(cmse_nonsecure_entry)]\\n\\n#[cmse_nonsecure_entry]\\npub extern \\\"C\\\" fn entry_function() {}\\n```\\n\\nTo fix this error, compile your code for a Rust target that supports the\\nTrustZone-M extension. The current possible targets are:\\n* `thumbv8m.main-none-eabi`\\n* `thumbv8m.main-none-eabihf`\\n* `thumbv8m.base-none-eabi`\\n\")),\n  (\"E0776\",\n   Some(\"`#[cmse_nonsecure_entry]` functions require a C ABI\\n\\nErroneous code example:\\n\\n```compile_fail,E0776\\n#![feature(cmse_nonsecure_entry)]\\n\\n#[no_mangle]\\n#[cmse_nonsecure_entry]\\npub fn entry_function(input: Vec<u32>) {}\\n```\\n\\nTo fix this error, declare your entry function with a C ABI, using `extern \\\"C\\\"`.\\n\")),\n  (\"E0777\",\n   Some(\"A literal value was used inside `#[derive]`.\\n\\nErroneous code example:\\n\\n```compile_fail,E0777\\n#[derive(\\\"Clone\\\")] // error!\\nstruct Foo;\\n```\\n\\nOnly paths to traits are allowed as argument inside `#[derive]`. You can find\\nmore information about the `#[derive]` attribute in the [Rust Book].\\n\\n\\n```\\n#[derive(Clone)] // ok!\\nstruct Foo;\\n```\\n\\n[Rust Book]: https://doc.rust-lang.org/book/appendix-03-derivable-traits.html\\n\")),\n  (\"E0778\",\n   Some(\"The `instruction_set` attribute was malformed.\\n\\nErroneous code example:\\n\\n```compile_fail,E0778\\n#![feature(isa_attribute)]\\n\\n#[instruction_set()] // error: expected one argument\\npub fn something() {}\\nfn main() {}\\n```\\n\\nThe parenthesized `instruction_set` attribute requires the parameter to be\\nspecified:\\n\\n```\\n#![feature(isa_attribute)]\\n\\n#[cfg_attr(target_arch=\\\"arm\\\", instruction_set(arm::a32))]\\nfn something() {}\\n```\\n\\nor:\\n\\n```\\n#![feature(isa_attribute)]\\n\\n#[cfg_attr(target_arch=\\\"arm\\\", instruction_set(arm::t32))]\\nfn something() {}\\n```\\n\\nFor more information see the [`instruction_set` attribute][isa-attribute]\\nsection of the Reference.\\n\\n[isa-attribute]: https://doc.rust-lang.org/reference/attributes/codegen.html\\n\")),\n  (\"E0779\",\n   Some(\"An unknown argument was given to the `instruction_set` attribute.\\n\\nErroneous code example:\\n\\n```compile_fail,E0779\\n#![feature(isa_attribute)]\\n\\n#[instruction_set(intel::x64)] // error: invalid argument\\npub fn something() {}\\nfn main() {}\\n```\\n\\nThe `instruction_set` attribute only supports two arguments currently:\\n\\n * arm::a32\\n * arm::t32\\n\\nAll other arguments given to the `instruction_set` attribute will return this\\nerror. Example:\\n\\n```\\n#![feature(isa_attribute)]\\n\\n#[cfg_attr(target_arch=\\\"arm\\\", instruction_set(arm::a32))] // ok!\\npub fn something() {}\\nfn main() {}\\n```\\n\\nFor more information see the [`instruction_set` attribute][isa-attribute]\\nsection of the Reference.\\n\\n[isa-attribute]: https://doc.rust-lang.org/reference/attributes/codegen.html\\n\")),\n  (\"E0780\",\n   Some(\"Cannot use `doc(inline)` with anonymous imports\\n\\nErroneous code example:\\n\\n```ignore (cannot-doctest-multicrate-project)\\n\\n#[doc(inline)] // error: invalid doc argument\\npub use foo::Foo as _;\\n```\\n\\nAnonymous imports are always rendered with `#[doc(no_inline)]`. To fix this\\nerror, remove the `#[doc(inline)]` attribute.\\n\\nExample:\\n\\n```ignore (cannot-doctest-multicrate-project)\\n\\npub use foo::Foo as _;\\n```\\n\")),\n  (\"E0781\",\n   Some(\"The `C-cmse-nonsecure-call` ABI can only be used with function pointers.\\n\\nErroneous code example:\\n\\n```compile_fail,E0781\\n#![feature(abi_c_cmse_nonsecure_call)]\\n\\npub extern \\\"C-cmse-nonsecure-call\\\" fn test() {}\\n```\\n\\nThe `C-cmse-nonsecure-call` ABI should be used by casting function pointers to\\nspecific addresses.\\n\")),\n  (\"E0782\",\n   Some(\"Trait objects must include the `dyn` keyword.\\n\\nErroneous code example:\\n\\n```edition2021,compile_fail,E0782\\ntrait Foo {}\\nfn test(arg: Box<Foo>) {} // error!\\n```\\n\\nTrait objects are a way to call methods on types that are not known until\\nruntime but conform to some trait.\\n\\nTrait objects should be formed with `Box<dyn Foo>`, but in the code above\\n`dyn` is left off.\\n\\nThis makes it harder to see that `arg` is a trait object and not a\\nsimply a heap allocated type called `Foo`.\\n\\nTo fix this issue, add `dyn` before the trait name.\\n\\n```edition2021\\ntrait Foo {}\\nfn test(arg: Box<dyn Foo>) {} // ok!\\n```\\n\\nThis used to be allowed before edition 2021, but is now an error.\\n\")),\n  (\"E0783\",\n   Some(\"The range pattern `...` is no longer allowed.\\n\\nErroneous code example:\\n\\n```edition2021,compile_fail,E0783\\nmatch 2u8 {\\n    0...9 => println!(\\\"Got a number less than 10\\\"), // error!\\n    _ => println!(\\\"Got a number 10 or more\\\"),\\n}\\n```\\n\\nOlder Rust code using previous editions allowed `...` to stand for exclusive\\nranges which are now signified using `..=`.\\n\\nTo make this code compile replace the `...` with `..=`.\\n\\n```edition2021\\nmatch 2u8 {\\n    0..=9 => println!(\\\"Got a number less than 10\\\"), // ok!\\n    _ => println!(\\\"Got a number 10 or more\\\"),\\n}\\n```\\n\")),\n  (\"E0784\",\n   Some(\"A union expression does not have exactly one field.\\n\\nErroneous code example:\\n\\n```compile_fail,E0784\\nunion Bird {\\n    pigeon: u8,\\n    turtledove: u16,\\n}\\n\\nlet bird = Bird {}; // error\\nlet bird = Bird { pigeon: 0, turtledove: 1 }; // error\\n```\\n\\nThe key property of unions is that all fields of a union share common storage.\\nAs a result, writes to one field of a union can overwrite its other fields, and\\nsize of a union is determined by the size of its largest field.\\n\\nYou can find more information about the union types in the [Rust reference].\\n\\nWorking example:\\n\\n```\\nunion Bird {\\n    pigeon: u8,\\n    turtledove: u16,\\n}\\n\\nlet bird = Bird { pigeon: 0 }; // OK\\n```\\n\\n[Rust reference]: https://doc.rust-lang.org/reference/items/unions.html\\n\")),\n  (\"E0785\",\n   Some(\"An inherent `impl` was written on a dyn auto trait.\\n\\nErroneous code example:\\n\\n```compile_fail,E0785\\n#![feature(auto_traits)]\\n\\nauto trait AutoTrait {}\\n\\nimpl dyn AutoTrait {}\\n```\\n\\nDyn objects allow any number of auto traits, plus at most one non-auto trait.\\nThe non-auto trait becomes the \\\"principal trait\\\".\\n\\nWhen checking if an impl on a dyn trait is coherent, the principal trait is\\nnormally the only one considered. Since the erroneous code has no principal\\ntrait, it cannot be implemented at all.\\n\\nWorking example:\\n\\n```\\n#![feature(auto_traits)]\\n\\ntrait PrincipalTrait {}\\n\\nauto trait AutoTrait {}\\n\\nimpl dyn PrincipalTrait + AutoTrait + Send {}\\n```\\n\")),\n  (\"E0208\", None), (\"E0227\", None), (\"E0279\", None), (\"E0280\", None),\n  (\"E0311\", None), (\"E0313\", None), (\"E0320\", None), (\"E0377\", None),\n  (\"E0457\", None), (\"E0460\", None), (\"E0461\", None), (\"E0462\", None),\n  (\"E0465\", None), (\"E0472\", None), (\"E0476\", None), (\"E0490\", None),\n  (\"E0514\", None), (\"E0519\", None), (\"E0523\", None), (\"E0640\", None),\n  (\"E0667\", None), (\"E0711\", None), (\"E0717\", None), (\"E0726\", None),\n  (\"E0772\", None)]"}},"1:5526":{"id":"1:5526","crate_id":1,"name":"DirEntryExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5527"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3154":{"id":"2:3154","crate_id":2,"name":"BitAndAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3156"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12442":{"id":"2:12442","crate_id":2,"name":"escape_debug","span":null,"visibility":"public","docs":"Return an iterator that escapes each char in `self` with [`char::escape_debug`].\n\nNote: only extended grapheme codepoints that begin the string will be\nescaped.\n\n# Examples\n\nAs an iterator:\n\n```\nfor c in \"‚ù§\\n!\".escape_debug() {\n    print!(\"{}\", c);\n}\nprintln!();\n```\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"‚ù§\\n!\".escape_debug());\n```\n\n\nBoth are equivalent to:\n\n```\nprintln!(\"‚ù§\\\\n!\");\n```\n\nUsing `to_string`:\n\n```\nassert_eq!(\"‚ù§\\n!\".escape_debug().to_string(), \"‚ù§\\\\n!\");\n```","links":{"`char::escape_debug`":"1:15260"},"attrs":["#[must_use =\n  \"this returns the escaped string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"str_escape\", since = \"1.34.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"EscapeDebug","id":"2:45566","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12343":{"id":"2:12343","crate_id":2,"name":"chars","span":null,"visibility":"public","docs":"Returns an iterator over the [`char`]s of a string slice.\n\nAs a string slice consists of valid UTF-8, we can iterate through a\nstring slice by [`char`]. This method returns such an iterator.\n\nIt's important to remember that [`char`] represents a Unicode Scalar\nValue, and might not match your idea of what a 'character' is. Iteration\nover grapheme clusters may be what you actually want. This functionality\nis not provided by Rust's standard library, check crates.io instead.\n\n# Examples\n\nBasic usage:\n\n```\nlet word = \"goodbye\";\n\nlet count = word.chars().count();\nassert_eq!(7, count);\n\nlet mut chars = word.chars();\n\nassert_eq!(Some('g'), chars.next());\nassert_eq!(Some('o'), chars.next());\nassert_eq!(Some('o'), chars.next());\nassert_eq!(Some('d'), chars.next());\nassert_eq!(Some('b'), chars.next());\nassert_eq!(Some('y'), chars.next());\nassert_eq!(Some('e'), chars.next());\n\nassert_eq!(None, chars.next());\n```\n\nRemember, [`char`]s might not match your intuition about characters:\n\n[`char`]: prim@char\n\n```\nlet y = \"yÃÜ\";\n\nlet mut chars = y.chars();\n\nassert_eq!(Some('y'), chars.next()); // not 'yÃÜ'\nassert_eq!(Some('\\u{0306}'), chars.next());\n\nassert_eq!(None, chars.next());\n```","links":{"prim@char":"1:15260"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"Chars","id":"2:45237","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12326":{"id":"2:12326","crate_id":2,"name":"is_char_boundary","span":null,"visibility":"public","docs":"Checks that `index`-th byte is the first byte in a UTF-8 code point\nsequence or the end of the string.\n\nThe start and end of the string (when `index == self.len()`) are\nconsidered to be boundaries.\n\nReturns `false` if `index` is greater than `self.len()`.\n\n# Examples\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\nassert!(s.is_char_boundary(0));\n// start of `ËÄÅ`\nassert!(s.is_char_boundary(6));\nassert!(s.is_char_boundary(s.len()));\n\n// second byte of `√∂`\nassert!(!s.is_char_boundary(2));\n\n// third byte of `ËÄÅ`\nassert!(!s.is_char_boundary(8));\n```","links":{},"attrs":["#[must_use]","#[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["index",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:13091":{"id":"2:13091","crate_id":2,"name":"Allocator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":["2:13092","2:13093","2:13094","2:13095","2:13096","2:13097","2:13098"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12398":{"id":"2:12398","crate_id":2,"name":"rmatches","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within this string slice,\nyielded in reverse order.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse\nsearch, and it will be a [`DoubleEndedIterator`] if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`matches`] method can be used.\n\n[`matches`]: str::matches\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\nassert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n\nlet v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\nassert_eq!(v, [\"3\", \"2\", \"1\"]);\n```","links":{"self::pattern":"2:11957","str::matches":"1:15265","`DoubleEndedIterator`":"2:7470","prim@char":"1:15260"},"attrs":["#[stable(feature = \"str_matches\", since = \"1.2.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"RMatches","id":"2:45489","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3371":{"id":"2:3371","crate_id":2,"name":"RangeBounds","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3373","2:3374","2:3375"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"T"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[],"implementors":[]}},"2:3098":{"id":"2:3098","crate_id":2,"name":"Neg","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3099","2:3100"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12337":{"id":"2:12337","crate_id":2,"name":"get_unchecked_mut","span":null,"visibility":"public","docs":"Returns a mutable, unchecked subslice of `str`.\n\nThis is the unchecked alternative to indexing the `str`.\n\n# Safety\n\nCallers of this function are responsible that these preconditions are\nsatisfied:\n\n* The starting index must not exceed the ending index;\n* Indexes must be within bounds of the original slice;\n* Indexes must lie on UTF-8 sequence boundaries.\n\nFailing that, the returned string slice may reference invalid memory or\nviolate the invariants communicated by the `str` type.\n\n# Examples\n\n```\nlet mut v = String::from(\"üóª‚ààüåè\");\nunsafe {\n    assert_eq!(\"üóª\", v.get_unchecked_mut(0..4));\n    assert_eq!(\"‚àà\", v.get_unchecked_mut(4..7));\n    assert_eq!(\"üåè\", v.get_unchecked_mut(7..11));\n}\n```","links":{},"attrs":["#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}],["i",{"kind":"generic","inner":"I"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"qualified_path","inner":{"name":"Output","self_type":{"kind":"generic","inner":"I"},"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:9929","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}}}}}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"I"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"SliceIndex","id":"2:9929","args":{"angle_bracketed":{"args":[{"type":{"kind":"primitive","inner":"str"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":["unsafe"],"abi":"\"Rust\"","has_body":true}},"2:3245":{"id":"2:3245","crate_id":2,"name":"FnMut","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3247"],"generics":{"params":[{"name":"Args","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"FnOnce","id":"2:3248","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Args"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:3248":{"id":"2:3248","crate_id":2,"name":"FnOnce","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3250","2:3251"],"generics":{"params":[{"name":"Args","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:11987":{"id":"2:11987","crate_id":2,"name":"DoubleEndedSearcher","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:3158":{"id":"2:3158","crate_id":2,"name":"BitOrAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3160"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"1:6201":{"id":"1:6201","crate_id":1,"name":"ExitStatusExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6202","1:6203","1:6204","1:6205","1:6206","1:6207"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sealed","id":"1:10173","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:12414":{"id":"2:12414","crate_id":2,"name":"trim_right","span":null,"visibility":"public","docs":"Returns a string slice with trailing whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`.\n\n# Text directionality\n\nA string is a sequence of bytes. 'Right' in this context means the last\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _left_ side, not the right.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \" Hello\\tworld\\t\";\n\nassert_eq!(\" Hello\\tworld\", s.trim_right());\n```\n\nDirectionality:\n\n```\nlet s = \"English  \";\nassert!(Some('h') == s.trim_right().chars().rev().next());\n\nlet s = \"◊¢◊ë◊®◊ô◊™  \";\nassert!(Some('◊™') == s.trim_right().chars().rev().next());\n```","links":{},"attrs":["#[must_use =\n  \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[inline]","#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_deprecated(since = \"1.33.0\", reason = \"superseded by `trim_end`\",\n                   suggestion = \"trim_end\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_end`"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12348":{"id":"2:12348","crate_id":2,"name":"lines","span":null,"visibility":"public","docs":"An iterator over the lines of a string, as string slices.\n\nLines are ended with either a newline (`\\n`) or a carriage return with\na line feed (`\\r\\n`).\n\nThe final line ending is optional. A string that ends with a final line\nending will return the same lines as an otherwise identical string\nwithout a final line ending.\n\n# Examples\n\nBasic usage:\n\n```\nlet text = \"foo\\r\\nbar\\n\\nbaz\\n\";\nlet mut lines = text.lines();\n\nassert_eq!(Some(\"foo\"), lines.next());\nassert_eq!(Some(\"bar\"), lines.next());\nassert_eq!(Some(\"\"), lines.next());\nassert_eq!(Some(\"baz\"), lines.next());\n\nassert_eq!(None, lines.next());\n```\n\nThe final line ending isn't required:\n\n```\nlet text = \"foo\\nbar\\n\\r\\nbaz\";\nlet mut lines = text.lines();\n\nassert_eq!(Some(\"foo\"), lines.next());\nassert_eq!(Some(\"bar\"), lines.next());\nassert_eq!(Some(\"\"), lines.next());\nassert_eq!(Some(\"baz\"), lines.next());\n\nassert_eq!(None, lines.next());\n```","links":{},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"Lines","id":"2:45521","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12683":{"id":"2:12683","crate_id":2,"name":"IntoFuture","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:12684","2:12685","2:12686"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2655":{"id":"2:2655","crate_id":2,"name":"PartialEq","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2657","2:2658"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"Rhs"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[],"implementors":[]}},"2:9373":{"id":"2:9373","crate_id":2,"name":"LowerExp","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9374"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3110":{"id":"2:3110","crate_id":2,"name":"MulAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3112"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:7877":{"id":"2:7877","crate_id":2,"name":"TrustedLen","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Iterator","id":"2:7606","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"5:537":{"id":"5:537","crate_id":5,"name":"ToOwned","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["5:538","5:539","5:540"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12415":{"id":"2:12415","crate_id":2,"name":"trim_matches","span":null,"visibility":"public","docs":"Returns a string slice with all prefixes and suffixes that match a\npattern repeatedly removed.\n\nThe [pattern] can be a [`char`], a slice of [`char`]s, or a function\nor closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n```\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n```","links":{"self::pattern":"2:11957","prim@char":"1:15260"},"attrs":["#[must_use =\n  \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"DoubleEndedSearcher","id":"2:11987","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"1:4406":{"id":"1:4406","crate_id":1,"name":"Write","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:4407","1:4408","1:4410","1:4411","1:4412","1:4413","1:4414","1:4423"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2917":{"id":"2:2917","crate_id":2,"name":"TryFrom","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2919","2:2920"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"5:5422":{"id":"5:5422","crate_id":5,"name":"to_ascii_uppercase","span":null,"visibility":"public","docs":"Returns a copy of this string where each character is mapped to its\nASCII upper case equivalent.\n\nASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\nbut non-ASCII letters are unchanged.\n\nTo uppercase the value in-place, use [`make_ascii_uppercase`].\n\nTo uppercase ASCII characters in addition to non-ASCII characters, use\n[`to_uppercase`].\n\n# Examples\n\n```\nlet s = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert_eq!(\"GR√º√üE, J√ºRGEN ‚ù§\", s.to_ascii_uppercase());\n```\n\n[`make_ascii_uppercase`]: str::make_ascii_uppercase\n[`to_uppercase`]: #method.to_uppercase","links":{"str::make_ascii_uppercase":"1:15265"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use = \"to uppercase the value in-place, use `make_ascii_uppercase()`\"]","#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:7602","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"1:5460":{"id":"1:5460","crate_id":1,"name":"FileExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5461","1:5462","1:5463","1:5464"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12421":{"id":"2:12421","crate_id":2,"name":"strip_prefix","span":null,"visibility":"public","docs":"Returns a string slice with the prefix removed.\n\nIf the string starts with the pattern `prefix`, returns substring after the prefix, wrapped\nin `Some`.  Unlike `trim_start_matches`, this method removes the prefix exactly once.\n\nIf the string does not start with `prefix`, returns `None`.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\n```\nassert_eq!(\"foo:bar\".strip_prefix(\"foo:\"), Some(\"bar\"));\nassert_eq!(\"foo:bar\".strip_prefix(\"bar\"), None);\nassert_eq!(\"foofoo\".strip_prefix(\"foo\"), Some(\"foo\"));\n```","links":{"prim@char":"1:15260","self::pattern":"2:11957"},"attrs":["#[must_use =\n  \"this returns the remaining substring as a new slice, \\\n                  without modifying the original\"]","#[stable(feature = \"str_strip\", since = \"1.45.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["prefix",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:43419","args":{"angle_bracketed":{"args":[{"type":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3162":{"id":"2:3162","crate_id":2,"name":"BitXorAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3164"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"0:3":{"id":"0:3","crate_id":0,"name":"register_diagnostics","span":{"filename":"compiler/rustc_error_codes/src/lib.rs","begin":[5,0],"end":[12,1]},"visibility":"crate","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"macro","inner":"macro_rules! register_diagnostics {\n    ($($ecode : ident : $message : expr,) * ; $($code : ident,) *) => { ... };\n}"},"2:12436":{"id":"2:12436","crate_id":2,"name":"parse","span":null,"visibility":"public","docs":"Parses this string slice into another type.\n\nBecause `parse` is so general, it can cause problems with type\ninference. As such, `parse` is one of the few times you'll see\nthe syntax affectionately known as the 'turbofish': `::<>`. This\nhelps the inference algorithm understand specifically which type\nyou're trying to parse into.\n\n`parse` can parse into any type that implements the [`FromStr`] trait.\n\n# Errors\n\nWill return [`Err`] if it's not possible to parse this string slice into\nthe desired type.\n\n[`Err`]: FromStr::Err\n\n# Examples\n\nBasic usage\n\n```\nlet four: u32 = \"4\".parse().unwrap();\n\nassert_eq!(4, four);\n```\n\nUsing the 'turbofish' instead of annotating `four`:\n\n```\nlet four = \"4\".parse::<u32>();\n\nassert_eq!(Ok(4), four);\n```\n\nFailing to parse:\n\n```\nlet nope = \"j\".parse::<u32>();\n\nassert!(nope.is_err());\n```","links":{"`FromStr`":"2:11894","FromStr::Err":"2:11894"},"attrs":["#[inline]","#[stable(feature = \"rust1\", since = \"1.0.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"Result","id":"2:43545","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"F"}},{"type":{"kind":"qualified_path","inner":{"name":"Err","self_type":{"kind":"generic","inner":"F"},"trait":{"kind":"resolved_path","inner":{"name":"FromStr","id":"2:11894","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}}}}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"F","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"F"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"FromStr","id":"2:11894","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12386":{"id":"2:12386","crate_id":2,"name":"rsplitn","span":null,"visibility":"public","docs":"An iterator over substrings of this string slice, separated by a\npattern, starting from the end of the string, restricted to returning\nat most `n` items.\n\nIf `n` substrings are returned, the last substring (the `n`th substring)\nwill contain the remainder of the string.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will not be double ended, because it is not\nefficient to support.\n\nFor splitting from the front, the [`splitn`] method can be used.\n\n[`splitn`]: str::splitn\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\nassert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\nassert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"ghi\", \"abc1def\"]);\n```","links":{"self::pattern":"2:11957","prim@char":"1:15260","str::splitn":"1:15265"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["n",{"kind":"primitive","inner":"usize"}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"RSplitN","id":"2:45389","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12438":{"id":"2:12438","crate_id":2,"name":"is_ascii","span":null,"visibility":"public","docs":"Checks if all characters in this string are within the ASCII range.\n\n# Examples\n\n```\nlet ascii = \"hello!\\n\";\nlet non_ascii = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert!(ascii.is_ascii());\nassert!(!non_ascii.is_ascii());\n```","links":{},"attrs":["#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]","#[must_use]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"primitive","inner":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"1:5468":{"id":"1:5468","crate_id":1,"name":"PermissionsExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5469","1:5470","1:5471"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2910":{"id":"2:2910","crate_id":2,"name":"From","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2912"],"generics":{"params":[{"name":"T","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12440":{"id":"2:12440","crate_id":2,"name":"make_ascii_uppercase","span":null,"visibility":"public","docs":"Converts this string to its ASCII upper case equivalent in-place.\n\nASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\nbut non-ASCII letters are unchanged.\n\nTo return a new uppercased value without modifying the existing one, use\n[`to_ascii_uppercase()`].\n\n[`to_ascii_uppercase()`]: #method.to_ascii_uppercase\n\n# Examples\n\n```\nlet mut s = String::from(\"Gr√º√üe, J√ºrgen ‚ù§\");\n\ns.make_ascii_uppercase();\n\nassert_eq!(\"GR√º√üE, J√ºRGEN ‚ù§\", s);\n```","links":{},"attrs":["#[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"tuple","inner":[]},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12328":{"id":"2:12328","crate_id":2,"name":"as_bytes_mut","span":null,"visibility":"public","docs":"Converts a mutable string slice to a mutable byte slice.\n\n# Safety\n\nThe caller must ensure that the content of the slice is valid UTF-8\nbefore the borrow ends and the underlying `str` is used.\n\nUse of a `str` whose contents are not valid UTF-8 is undefined behavior.\n\n# Examples\n\nBasic usage:\n\n```\nlet mut s = String::from(\"Hello\");\nlet bytes = unsafe { s.as_bytes_mut() };\n\nassert_eq!(b\"Hello\", bytes);\n```\n\nMutability:\n\n```\nlet mut s = String::from(\"üóª‚ààüåè\");\n\nunsafe {\n    let bytes = s.as_bytes_mut();\n\n    bytes[0] = 0xF0;\n    bytes[1] = 0x9F;\n    bytes[2] = 0x8D;\n    bytes[3] = 0x94;\n}\n\nassert_eq!(\"üçî‚ààüåè\", s);\n```","links":{},"attrs":["#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]","#[must_use]","#[inline(always)]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":true,"type":{"kind":"slice","inner":{"kind":"primitive","inner":"u8"}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":["unsafe"],"abi":"\"Rust\"","has_body":true}},"2:3123":{"id":"2:3123","crate_id":2,"name":"Not","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3124","2:3125"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"1:5476":{"id":"1:5476","crate_id":1,"name":"OpenOptionsExt","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:5477","1:5478"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3106":{"id":"2:3106","crate_id":2,"name":"SubAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3108"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:7470":{"id":"2:7470","crate_id":2,"name":"DoubleEndedIterator","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:7471","2:7472","2:7473","2:7474","2:7478","2:7481"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Iterator","id":"2:7606","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:12347":{"id":"2:12347","crate_id":2,"name":"split_ascii_whitespace","span":null,"visibility":"public","docs":"Splits a string slice by ASCII whitespace.\n\nThe iterator returned will return string slices that are sub-slices of\nthe original string slice, separated by any amount of ASCII whitespace.\n\nTo split by Unicode `Whitespace` instead, use [`split_whitespace`].\n\n[`split_whitespace`]: str::split_whitespace\n\n# Examples\n\nBasic usage:\n\n```\nlet mut iter = \"A few words\".split_ascii_whitespace();\n\nassert_eq!(Some(\"A\"), iter.next());\nassert_eq!(Some(\"few\"), iter.next());\nassert_eq!(Some(\"words\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\nAll kinds of ASCII whitespace are considered:\n\n```\nlet mut iter = \" Mary   had\\ta little  \\n\\t lamb\".split_ascii_whitespace();\nassert_eq!(Some(\"Mary\"), iter.next());\nassert_eq!(Some(\"had\"), iter.next());\nassert_eq!(Some(\"a\"), iter.next());\nassert_eq!(Some(\"little\"), iter.next());\nassert_eq!(Some(\"lamb\"), iter.next());\n\nassert_eq!(None, iter.next());\n```","links":{"str::split_whitespace":"1:15265"},"attrs":["#[must_use =\n  \"this returns the split string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"SplitAsciiWhitespace","id":"2:45550","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:6975":{"id":"2:6975","crate_id":2,"name":"Step","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:6976","2:6977","2:6978","2:6979","2:6980","2:6981","2:6982"],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Clone","id":"2:2625","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}},{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"PartialOrd","id":"2:2702","args":{"angle_bracketed":{"args":[{"type":{"kind":"generic","inner":"Self"}}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:3086":{"id":"2:3086","crate_id":2,"name":"Div","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3088","2:3089"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3239":{"id":"2:3239","crate_id":2,"name":"Drop","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3240"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:9361":{"id":"2:9361","crate_id":2,"name":"Display","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9362"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3014":{"id":"2:3014","crate_id":2,"name":"Copy","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Clone","id":"2:2625","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:12444":{"id":"2:12444","crate_id":2,"name":"escape_default","span":null,"visibility":"public","docs":"Return an iterator that escapes each char in `self` with [`char::escape_default`].\n\n# Examples\n\nAs an iterator:\n\n```\nfor c in \"‚ù§\\n!\".escape_default() {\n    print!(\"{}\", c);\n}\nprintln!();\n```\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"‚ù§\\n!\".escape_default());\n```\n\n\nBoth are equivalent to:\n\n```\nprintln!(\"\\\\u{{2764}}\\\\n!\");\n```\n\nUsing `to_string`:\n\n```\nassert_eq!(\"‚ù§\\n!\".escape_default().to_string(), \"\\\\u{2764}\\\\n!\");\n```","links":{"`char::escape_default`":"1:15260"},"attrs":["#[must_use =\n  \"this returns the escaped string as an iterator, \\\n                  without modifying the original\"]","#[stable(feature = \"str_escape\", since = \"1.34.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"resolved_path","inner":{"name":"EscapeDefault","id":"2:45575","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12404":{"id":"2:12404","crate_id":2,"name":"rmatch_indices","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within `self`,\nyielded in reverse order along with the index of the match.\n\nFor matches of `pat` within `self` that overlap, only the indices\ncorresponding to the last match are returned.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse\nsearch, and it will be a [`DoubleEndedIterator`] if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`match_indices`] method can be used.\n\n[`match_indices`]: str::match_indices\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\nassert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n\nlet v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\nassert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n\nlet v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\nassert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n```","links":{"prim@char":"1:15260","str::match_indices":"1:15265","`DoubleEndedIterator`":"2:7470","self::pattern":"2:11957"},"attrs":["#[stable(feature = \"str_match_indices\", since = \"1.5.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"RMatchIndices","id":"2:45435","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:12413":{"id":"2:12413","crate_id":2,"name":"trim_left","span":null,"visibility":"public","docs":"Returns a string slice with leading whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`.\n\n# Text directionality\n\nA string is a sequence of bytes. 'Left' in this context means the first\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _right_ side, not the left.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \" Hello\\tworld\\t\";\n\nassert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n```\n\nDirectionality:\n\n```\nlet s = \"  English\";\nassert!(Some('E') == s.trim_left().chars().next());\n\nlet s = \"  ◊¢◊ë◊®◊ô◊™\";\nassert!(Some('◊¢') == s.trim_left().chars().next());\n```","links":{},"attrs":["#[must_use =\n  \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[inline]","#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_deprecated(since = \"1.33.0\", reason = \"superseded by `trim_start`\",\n                   suggestion = \"trim_start\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_start`"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"generic","inner":"Self"}}}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":[],"abi":"\"Rust\"","has_body":true}},"5:5399":{"id":"5:5399","crate_id":5,"name":null,"span":null,"visibility":{"restricted":{"parent":"5:5220","path":"::str"}},"docs":"Methods for string slices.","links":{},"attrs":["#[lang = \"str_alloc\"]","#[cfg(not(test))]"],"deprecation":null,"kind":"impl","inner":{"is_unsafe":false,"generics":{"params":[],"where_predicates":[]},"provided_trait_methods":[],"trait":null,"for":{"kind":"primitive","inner":"str"},"items":["5:5400","5:5401","5:5404","5:5407","5:5419","5:5420","5:5421","5:5422","5:5423"],"negative":false,"synthetic":false,"blanket_impl":null}},"1:6605":{"id":"1:6605","crate_id":1,"name":"IntoRawFd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["1:6606"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:8847":{"id":"2:8847","crate_id":2,"name":"Stream","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:8848","2:8849","2:8850"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12392":{"id":"2:12392","crate_id":2,"name":"rsplit_once","span":null,"visibility":"public","docs":"Splits the string on the last occurrence of the specified delimiter and\nreturns prefix before delimiter and suffix after delimiter.\n\n# Examples\n\n```\nassert_eq!(\"cfg\".rsplit_once('='), None);\nassert_eq!(\"cfg=foo\".rsplit_once('='), Some((\"cfg\", \"foo\")));\nassert_eq!(\"cfg=foo=bar\".rsplit_once('='), Some((\"cfg=foo\", \"bar\")));\n```","links":{},"attrs":["#[stable(feature = \"str_split_once\", since = \"1.52.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["delimiter",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"Option","id":"2:43419","args":{"angle_bracketed":{"args":[{"type":{"kind":"tuple","inner":[{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}}]}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:8325":{"id":"2:8325","crate_id":2,"name":"RefUnwindSafe","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":true,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3012":{"id":"2:3012","crate_id":2,"name":"StructuralPartialEq","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:9365":{"id":"2:9365","crate_id":2,"name":"Binary","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9366"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:3009":{"id":"2:3009","crate_id":2,"name":"Sized","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":true,"is_unsafe":false,"items":[],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}},"0:0":{"id":"0:0","crate_id":0,"name":"rustc_error_codes","span":{"filename":"compiler/rustc_error_codes/src/lib.rs","begin":[1,0],"end":[15,33]},"visibility":"public","docs":"This library is used to gather all error codes into one place,\nthe goal being to make their maintenance easier.","links":{},"attrs":["#![deny(rustdoc :: invalid_codeblock_attributes)]"],"deprecation":null,"kind":"module","inner":{"is_crate":true,"items":["0:4","0:3","0:8"]}},"2:12433":{"id":"2:12433","crate_id":2,"name":"trim_right_matches","span":null,"visibility":"public","docs":"Returns a string slice with all suffixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. 'Right' in this context means the last\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _left_ side, not the right.\n\n# Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n```\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n```","links":{"self::pattern":"2:11957","prim@char":"1:15260"},"attrs":["#[stable(feature = \"rust1\", since = \"1.0.0\")]","#[rustc_deprecated(since = \"1.33.0\", reason =\n                   \"superseded by `trim_end_matches`\", suggestion =\n                   \"trim_end_matches\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_end_matches`"},"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"primitive","inner":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}},{"bound_predicate":{"ty":{"kind":"qualified_path","inner":{"name":"Searcher","self_type":{"kind":"generic","inner":"P"},"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}}}},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"ReverseSearcher","id":"2:11982","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3127":{"id":"2:3127","crate_id":2,"name":"BitAnd","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3129","2:3130"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:12371":{"id":"2:12371","crate_id":2,"name":"split_inclusive","span":null,"visibility":"public","docs":"An iterator over substrings of this string slice, separated by\ncharacters matched by a pattern. Differs from the iterator produced by\n`split` in that `split_inclusive` leaves the matched part as the\nterminator of the substring.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\"\n    .split_inclusive('\\n').collect();\nassert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\"]);\n```\n\nIf the last element of the string is matched,\nthat element will be considered the terminator of the preceding substring.\nThat substring will be the last item returned by the iterator.\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\\n\"\n    .split_inclusive('\\n').collect();\nassert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\\n\"]);\n```","links":{"self::pattern":"2:11957","prim@char":"1:15260"},"attrs":["#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]","#[inline]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}]],"output":{"kind":"resolved_path","inner":{"name":"SplitInclusive","id":"2:11747","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"kind":"generic","inner":"P"}}],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:3142":{"id":"2:3142","crate_id":2,"name":"Shl","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3144","2:3145"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:11976":{"id":"2:11976","crate_id":2,"name":"Searcher","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":["2:11978","2:11979","2:11980","2:11981"],"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:7435":{"id":"2:7435","crate_id":2,"name":"Extend","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:7437","2:7439","2:7440"],"generics":{"params":[{"name":"A","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:2603":{"id":"2:2603","crate_id":2,"name":"Borrow","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:2605"],"generics":{"params":[{"name":"Borrowed","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"Borrowed"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Sized","id":"2:3009","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"maybe"}}]}}]},"bounds":[],"implementors":[]}},"5:5404":{"id":"5:5404","crate_id":5,"name":"replacen","span":null,"visibility":"public","docs":"Replaces first N matches of a pattern with another string.\n\n`replacen` creates a new [`String`], and copies the data from this string slice into it.\nWhile doing so, it attempts to find matches of a pattern. If it finds any, it\nreplaces them with the replacement string slice at most `count` times.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"foo foo 123 foo\";\nassert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\nassert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\nassert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n```\n\nWhen the pattern doesn't match:\n\n```\nlet s = \"this is old\";\nassert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n```","links":{"`String`":"5:7602"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n  \"this returns the replaced string as a new allocation, \\\n                  without modifying the original\"]","#[stable(feature = \"str_replacen\", since = \"1.16.0\")]"],"deprecation":null,"kind":"method","inner":{"decl":{"inputs":[["self",{"kind":"borrowed_ref","inner":{"lifetime":"'a","mutable":false,"type":{"kind":"generic","inner":"Self"}}}],["pat",{"kind":"generic","inner":"P"}],["to",{"kind":"borrowed_ref","inner":{"lifetime":null,"mutable":false,"type":{"kind":"primitive","inner":"str"}}}],["count",{"kind":"primitive","inner":"usize"}]],"output":{"kind":"resolved_path","inner":{"name":"String","id":"5:7602","args":{"angle_bracketed":{"args":[],"bindings":[]}},"param_names":[]}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null}}}],"where_predicates":[{"bound_predicate":{"ty":{"kind":"generic","inner":"P"},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Pattern","id":"2:11967","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}]}}]},"header":[],"abi":"\"Rust\"","has_body":true}},"2:11982":{"id":"2:11982","crate_id":2,"name":"ReverseSearcher","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":true,"items":["2:11984","2:11985","2:11986"],"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}}],"where_predicates":[]},"bounds":[{"trait_bound":{"trait":{"kind":"resolved_path","inner":{"name":"Searcher","id":"2:11976","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}},"param_names":[]}},"generic_params":[],"modifier":"none"}}],"implementors":[]}},"2:3171":{"id":"2:3171","crate_id":2,"name":"ShrAssign","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:3173"],"generics":{"params":[{"name":"Rhs","kind":{"type":{"bounds":[],"default":{"kind":"generic","inner":"Self"}}}}],"where_predicates":[]},"bounds":[],"implementors":[]}},"2:9367":{"id":"2:9367","crate_id":2,"name":"LowerHex","span":null,"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"kind":"trait","inner":{"is_auto":false,"is_unsafe":false,"items":["2:9368"],"generics":{"params":[],"where_predicates":[]},"bounds":[],"implementors":[]}}},"paths":{"5:567":{"crate_id":5,"path":["rustc_error_codes","Target"],"kind":"typedef"},"7:0":{"crate_id":7,"path":["unwind"],"kind":"module"},"5:976":{"crate_id":5,"path":["alloc","collections","btree","dedup_sorted_iter","DedupSortedIter"],"kind":"struct"},"5:5192":{"crate_id":5,"path":["alloc","slice","insert_head","InsertionHole"],"kind":"struct"},"6:6489":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","align","max_align_t"],"kind":"struct"},"14:5384":{"crate_id":14,"path":["gimli","read","cfi","EhFrameHdr"],"kind":"struct"},"1:12769":{"crate_id":1,"path":["std","sys","unix","mutex","Mutex"],"kind":"struct"},"2:49217":{"crate_id":2,"path":["core","core_arch","x86","__m128d"],"kind":"struct"},"2:45181":{"crate_id":2,"path":["core","slice","iter","RChunksMut"],"kind":"struct"},"2:47519":{"crate_id":2,"path":["core","core_arch","simd","f32x4"],"kind":"struct"},"15:9943":{"crate_id":15,"path":["object","read","any","DynamicRelocationIteratorInternal"],"kind":"enum"},"14:4386":{"crate_id":14,"path":["gimli","constants","DwLle"],"kind":"struct"},"1:2717":{"crate_id":1,"path":["rustc_error_codes","Output"],"kind":"typedef"},"15:13331":{"crate_id":15,"path":["object","pe","ImageAuxSymbolFunctionBeginEnd"],"kind":"struct"},"2:9570":{"crate_id":2,"path":["core","hash","Hasher"],"kind":"trait"},"15:10477":{"crate_id":15,"path":["object","read","elf","hash","GnuHashTable"],"kind":"struct"},"1:8949":{"crate_id":1,"path":["std","lazy","SyncLazy"],"kind":"struct"},"6:5941":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_xmmreg"],"kind":"struct"},"2:47619":{"crate_id":2,"path":["core","core_arch","simd","m8x16"],"kind":"struct"},"9:181":{"crate_id":9,"path":["hashbrown","raw","RawTable"],"kind":"struct"},"6:4303":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_can"],"kind":"struct"},"1:10399":{"crate_id":1,"path":["std","ffi","c_str","IntoStringError"],"kind":"struct"},"9:711":{"crate_id":9,"path":["hashbrown","map","Iter"],"kind":"struct"},"15:9933":{"crate_id":15,"path":["object","read","any","DynamicRelocationIterator"],"kind":"struct"},"5:6742":{"crate_id":5,"path":["alloc","vec","into_iter","{{impl}}","drop","DropGuard"],"kind":"struct"},"2:9373":{"crate_id":2,"path":["core","fmt","LowerExp"],"kind":"trait"},"15:11809":{"crate_id":15,"path":["object","elf","NoteHeader32"],"kind":"struct"},"14:2843":{"crate_id":14,"path":["gimli","common","DebugAddrBase"],"kind":"struct"},"6:533":{"crate_id":6,"path":["libc","unix","rusage"],"kind":"struct"},"14:2968":{"crate_id":14,"path":["gimli","common","DebugLineStrOffset"],"kind":"struct"},"1:13070":{"crate_id":1,"path":["std","sys","unix","os","Env"],"kind":"struct"},"2:8550":{"crate_id":2,"path":["rustc_error_codes","Target"],"kind":"typedef"},"9:1026":{"crate_id":9,"path":["hashbrown","map","OccupiedEntry"],"kind":"struct"},"1:10524":{"crate_id":1,"path":["std","fs","FileType"],"kind":"struct"},"6:6068":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","ip_mreqn"],"kind":"struct"},"2:2515":{"crate_id":2,"path":["core","ptr","drop_in_place"],"kind":"function"},"1:13548":{"crate_id":1,"path":["std","sys","unix","rwlock","RWLock"],"kind":"struct"},"16:829":{"crate_id":16,"path":["memchr","memmem","FinderBuilder"],"kind":"struct"},"2:11415":{"crate_id":2,"path":["core","slice","SlicePattern"],"kind":"trait"},"1:10335":{"crate_id":1,"path":["std","ffi","c_str","CStr"],"kind":"struct"},"2:42444":{"crate_id":2,"path":["core","char","EscapeDebug"],"kind":"struct"},"14:5855":{"crate_id":14,"path":["gimli","read","cfi","CallFrameInstruction"],"kind":"enum"},"2:3022":{"crate_id":2,"path":["core","marker","PhantomData"],"kind":"struct"},"14:5672":{"crate_id":14,"path":["gimli","read","cfi","FrameDescriptionEntry"],"kind":"struct"},"1:14679":{"crate_id":1,"path":["std","sys_common","net","UdpSocket"],"kind":"struct"},"15:13810":{"crate_id":15,"path":["object","pe","ImageRuntimeFunctionEntry"],"kind":"struct"},"1:1396":{"crate_id":1,"path":["std","collections","hash","map","Entry"],"kind":"enum"},"6:6599":{"crate_id":6,"path":["libc","unix","linux_like","linux","fanotify_event_metadata"],"kind":"struct"},"6:3856":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_ramp_effect"],"kind":"struct"},"1:10174":{"crate_id":1,"path":["std","thread","local","AccessError"],"kind":"struct"},"1:8654":{"crate_id":1,"path":["std","sync","rwlock","RwLock"],"kind":"struct"},"15:12494":{"crate_id":15,"path":["object","macho","RpathCommand"],"kind":"struct"},"11:250":{"crate_id":11,"path":["rustc_demangle","SizeLimitExhausted"],"kind":"struct"},"14:7279":{"crate_id":14,"path":["gimli","read","rnglists","RangeListsFormat"],"kind":"enum"},"1:10717":{"crate_id":1,"path":["std","io","Initializer"],"kind":"struct"},"15:10502":{"crate_id":15,"path":["object","read","elf","version","VerdauxIterator"],"kind":"struct"},"2:45159":{"crate_id":2,"path":["core","slice","iter","ArrayChunksMut"],"kind":"struct"},"15:11738":{"crate_id":15,"path":["object","elf","Versym"],"kind":"struct"},"6:4239":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_alg"],"kind":"struct"},"14:7856":{"crate_id":14,"path":["gimli","read","unit","EntriesTreeIter"],"kind":"struct"},"15:11499":{"crate_id":15,"path":["object","elf","SectionHeader32"],"kind":"struct"},"13:0":{"crate_id":13,"path":["addr2line"],"kind":"module"},"14:6101":{"crate_id":14,"path":["gimli","read","abbrev","Abbreviations"],"kind":"struct"},"2:2838":{"crate_id":2,"path":["core","convert","num","private","Sealed"],"kind":"trait"},"15:12142":{"crate_id":15,"path":["object","macho","Fvmlib"],"kind":"struct"},"2:21817":{"crate_id":2,"path":["core","num","nonzero","NonZeroU8"],"kind":"struct"},"14:6644":{"crate_id":14,"path":["gimli","read","loclists","RawLocListEntry"],"kind":"enum"},"6:4083":{"crate_id":6,"path":["libc","unix","linux_like","linux","genlmsghdr"],"kind":"struct"},"2:3045":{"crate_id":2,"path":["core","marker","Unpin"],"kind":"trait"},"1:8308":{"crate_id":1,"path":["std","sync","barrier","Barrier"],"kind":"struct"},"14:5231":{"crate_id":14,"path":["gimli","constants","DwOp"],"kind":"struct"},"2:45853":{"crate_id":2,"path":["core","str","pattern","EmptyNeedle"],"kind":"struct"},"2:45584":{"crate_id":2,"path":["core","str","iter","EscapeUnicode"],"kind":"struct"},"15:11254":{"crate_id":15,"path":["object","read","Export"],"kind":"struct"},"5:6077":{"crate_id":5,"path":["alloc","sync","{{impl}}","from_iter_exact","Guard"],"kind":"struct"},"2:49252":{"crate_id":2,"path":["core","core_arch","x86","__m256d"],"kind":"struct"},"1:4145":{"crate_id":1,"path":["std","io","stdio","Stdout"],"kind":"struct"},"14:4762":{"crate_id":14,"path":["gimli","constants","DwOrd"],"kind":"struct"},"2:43589":{"crate_id":2,"path":["core","result","Iter"],"kind":"struct"},"9:833":{"crate_id":9,"path":["hashbrown","map","ValuesMut"],"kind":"struct"},"2:4":{"crate_id":2,"path":["core","panic"],"kind":"macro"},"12:220":{"crate_id":12,"path":["std_detect","detect","cache","Initializer"],"kind":"struct"},"2:10901":{"crate_id":2,"path":["core","slice","iter","GroupBy"],"kind":"struct"},"2:42606":{"crate_id":2,"path":["core","iter","adapters","inspect","Inspect"],"kind":"struct"},"6:3787":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_event"],"kind":"struct"},"14:6014":{"crate_id":14,"path":["gimli","read","dwarf","RangeIter"],"kind":"struct"},"1:1295":{"crate_id":1,"path":["std","collections","hash","map","RawOccupiedEntryMut"],"kind":"struct"},"1:15226":{"crate_id":1,"path":["std","backtrace_rs","symbolize","gimli","Cache"],"kind":"struct"},"2:9361":{"crate_id":2,"path":["core","fmt","Display"],"kind":"trait"},"1:11057":{"crate_id":1,"path":["std","path","Prefix"],"kind":"enum"},"2:21849":{"crate_id":2,"path":["core","num","nonzero","NonZeroU16"],"kind":"struct"},"1:15277":{"crate_id":1,"path":["std","u64"],"kind":"primitive"},"1:3801":{"crate_id":1,"path":["std","io","error","Result"],"kind":"typedef"},"6:3830":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_replay"],"kind":"struct"},"5:1362":{"crate_id":5,"path":["alloc","collections","btree","map","Range"],"kind":"struct"},"6:600":{"crate_id":6,"path":["libc","unix","itimerval"],"kind":"struct"},"14:5707":{"crate_id":14,"path":["gimli","read","cfi","UninitializedUnwindContext"],"kind":"struct"},"15:1311":{"crate_id":15,"path":["object","read","coff","relocation","CoffRelocationIterator"],"kind":"struct"},"1:11719":{"crate_id":1,"path":["std","sync","mpsc","RecvTimeoutError"],"kind":"enum"},"14:5996":{"crate_id":14,"path":["gimli","read","dwarf","Unit"],"kind":"struct"},"14:5360":{"crate_id":14,"path":["gimli","read","cfi","DebugFrame"],"kind":"struct"},"15:10814":{"crate_id":15,"path":["object","read","macho","section","MachOSection"],"kind":"struct"},"5:3454":{"crate_id":5,"path":["alloc","collections","linked_list","{{impl}}","drop","DropGuard"],"kind":"struct"},"6:0":{"crate_id":6,"path":["libc"],"kind":"module"},"2:42451":{"crate_id":2,"path":["core","char","ToLowercase"],"kind":"struct"},"11:194":{"crate_id":11,"path":["rustc_demangle","DemangleStyle"],"kind":"enum"},"2:11967":{"crate_id":2,"path":["core","str","pattern","Pattern"],"kind":"trait"},"15:12741":{"crate_id":15,"path":["object","macho","Nlist32"],"kind":"struct"},"15:9896":{"crate_id":15,"path":["object","read","any","SymbolIteratorInternal"],"kind":"enum"},"2:3014":{"crate_id":2,"path":["core","marker","Copy"],"kind":"trait"},"1:14455":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8Buf"],"kind":"struct"},"14:3800":{"crate_id":14,"path":["gimli","constants","DwChildren"],"kind":"struct"},"15:13912":{"crate_id":15,"path":["object","pe","ImageDebugMisc"],"kind":"struct"},"6:4211":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_nl"],"kind":"struct"},"6:4161":{"crate_id":6,"path":["libc","unix","linux_like","linux","can_filter"],"kind":"struct"},"16:720":{"crate_id":16,"path":["memchr","memmem","twoway","TwoWay"],"kind":"struct"},"6:1636":{"crate_id":6,"path":["libc","unix","linux_like","in_pktinfo"],"kind":"struct"},"2:48201":{"crate_id":2,"path":["core","core_arch","simd","i64x4"],"kind":"struct"},"6:5324":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","sysinfo"],"kind":"struct"},"14:6413":{"crate_id":14,"path":["gimli","read","line","LineSequence"],"kind":"struct"},"15:13394":{"crate_id":15,"path":["object","pe","ImageBaseRelocation"],"kind":"struct"},"2:47243":{"crate_id":2,"path":["core","core_arch","simd","u8x16"],"kind":"struct"},"1:808":{"crate_id":1,"path":["std","thread","Packet"],"kind":"struct"},"2:9367":{"crate_id":2,"path":["core","fmt","LowerHex"],"kind":"trait"},"9:857":{"crate_id":9,"path":["hashbrown","map","RawOccupiedEntryMut"],"kind":"struct"},"2:45670":{"crate_id":2,"path":["core","str","pattern","CharSearcher"],"kind":"struct"},"15:10377":{"crate_id":15,"path":["object","read","elf","symbol","ElfSymbol"],"kind":"struct"},"5:3378":{"crate_id":5,"path":["alloc","collections","linked_list","CursorMut"],"kind":"struct"},"5:7128":{"crate_id":5,"path":["alloc","vec","{{impl}}","dedup_by","FillGapOnDrop"],"kind":"struct"},"2:3239":{"crate_id":2,"path":["core","ops","drop","Drop"],"kind":"trait"},"1:15272":{"crate_id":1,"path":["std","i64"],"kind":"primitive"},"2:9929":{"crate_id":2,"path":["core","slice","index","SliceIndex"],"kind":"trait"},"1:0":{"crate_id":1,"path":["std"],"kind":"module"},"15:10279":{"crate_id":15,"path":["object","read","elf","section","SectionTable"],"kind":"struct"},"2:44145":{"crate_id":2,"path":["core","fmt","num","UpperHex"],"kind":"struct"},"1:6063":{"crate_id":1,"path":["std","os","unix","net","stream","UnixStream"],"kind":"struct"},"2:9601":{"crate_id":2,"path":["core","hash","BuildHasher"],"kind":"trait"},"14:3714":{"crate_id":14,"path":["gimli","constants","DwUt"],"kind":"struct"},"14:6605":{"crate_id":14,"path":["gimli","read","loclists","LocationLists"],"kind":"struct"},"2:3114":{"crate_id":2,"path":["core","ops","arith","DivAssign"],"kind":"trait"},"5:1344":{"crate_id":5,"path":["alloc","collections","btree","map","IntoKeys"],"kind":"struct"},"2:45784":{"crate_id":2,"path":["rustc_error_codes","Searcher"],"kind":"typedef"},"14:7333":{"crate_id":14,"path":["gimli","read","rnglists","RngListIter"],"kind":"struct"},"15:11750":{"crate_id":15,"path":["object","elf","Verdef"],"kind":"struct"},"2:46897":{"crate_id":2,"path":["core","core_arch","simd","u16x2"],"kind":"struct"},"1:4431":{"crate_id":1,"path":["std","io","BufRead"],"kind":"trait"},"2:45100":{"crate_id":2,"path":["core","slice","iter","ChunksExact"],"kind":"struct"},"2:2603":{"crate_id":2,"path":["core","borrow","Borrow"],"kind":"trait"},"5:543":{"crate_id":5,"path":["rustc_error_codes","Owned"],"kind":"typedef"},"1:2615":{"crate_id":1,"path":["rustc_error_codes","Target"],"kind":"typedef"},"6:559":{"crate_id":6,"path":["libc","unix","hostent"],"kind":"struct"},"1:5709":{"crate_id":1,"path":["std","os","unix","net","ancillary","AncillaryData"],"kind":"enum"},"2:42695":{"crate_id":2,"path":["core","iter","adapters","step_by","StepBy"],"kind":"struct"},"1:14092":{"crate_id":1,"path":["std","sys","unix","os_str","Buf"],"kind":"struct"},"15:10489":{"crate_id":15,"path":["object","read","elf","version","VerdefIterator"],"kind":"struct"},"2:21429":{"crate_id":2,"path":["core","num","diy_float","Fp"],"kind":"struct"},"1:1956":{"crate_id":1,"path":["std","collections","hash","set","Difference"],"kind":"struct"},"6:6655":{"crate_id":6,"path":["libc","unix","align","in6_addr"],"kind":"struct"},"1:9232":{"crate_id":1,"path":["std","sys_common","mutex","StaticMutex"],"kind":"struct"},"15:13627":{"crate_id":15,"path":["object","pe","ImageEpilogueDynamicRelocationHeader"],"kind":"struct"},"14:5421":{"crate_id":14,"path":["gimli","read","cfi","EhHdrTable"],"kind":"struct"},"14:6166":{"crate_id":14,"path":["gimli","read","aranges","ArangeHeaderIter"],"kind":"struct"},"5:379":{"crate_id":5,"path":["rustc_error_codes","Target"],"kind":"typedef"},"9:1405":{"crate_id":9,"path":["hashbrown","rustc_entry","RustcEntry"],"kind":"enum"},"6:5909":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statvfs64"],"kind":"struct"},"2:45541":{"crate_id":2,"path":["core","str","iter","SplitWhitespace"],"kind":"struct"},"14:6999":{"crate_id":14,"path":["gimli","read","op","Piece"],"kind":"struct"},"2:43528":{"crate_id":2,"path":["core","panicking","AssertKind"],"kind":"enum"},"1:8049":{"crate_id":1,"path":["std","sync","mpsc","sync","Packet"],"kind":"struct"},"2:7389":{"crate_id":2,"path":["core","iter","traits","accum","Product"],"kind":"trait"},"2:46199":{"crate_id":2,"path":["core","task","wake","RawWaker"],"kind":"struct"},"2:1887":{"crate_id":2,"path":["rustc_error_codes","Target"],"kind":"typedef"},"2:21238":{"crate_id":2,"path":["core","num","bignum","tests","Big8x3"],"kind":"struct"},"6:5892":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statfs64"],"kind":"struct"},"5:0":{"crate_id":5,"path":["alloc"],"kind":"module"},"1:7353":{"crate_id":1,"path":["std","process","ChildStderr"],"kind":"struct"},"6:3891":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_effect"],"kind":"struct"},"14:6152":{"crate_id":14,"path":["gimli","read","aranges","DebugAranges"],"kind":"struct"},"1:15275":{"crate_id":1,"path":["std","u16"],"kind":"primitive"},"15:12632":{"crate_id":15,"path":["object","macho","LinkerOptionCommand"],"kind":"struct"},"2:7385":{"crate_id":2,"path":["core","iter","traits","accum","Sum"],"kind":"trait"},"2:45417":{"crate_id":2,"path":["core","str","iter","MatchIndices"],"kind":"struct"},"15:9600":{"crate_id":15,"path":["object","read","any","FileInternal"],"kind":"enum"},"5:5381":{"crate_id":5,"path":["rustc_error_codes","Output"],"kind":"typedef"},"15:11779":{"crate_id":15,"path":["object","elf","Verneed"],"kind":"struct"},"6:4199":{"crate_id":6,"path":["libc","unix","linux_like","linux","nlmsgerr"],"kind":"struct"},"9:1769":{"crate_id":9,"path":["hashbrown","set","DrainFilter"],"kind":"struct"},"5:7562":{"crate_id":5,"path":["alloc","collections","TryReserveError"],"kind":"struct"},"2:44388":{"crate_id":2,"path":["core","fmt","rt","v1","Alignment"],"kind":"enum"},"15:13163":{"crate_id":15,"path":["object","pe","ImageNtHeaders32"],"kind":"struct"},"15:4157":{"crate_id":15,"path":["object","read","macho","relocation","MachORelocationIterator"],"kind":"struct"},"2:3449":{"crate_id":2,"path":["core","ops","try_trait","FromResidual"],"kind":"trait"},"6:6622":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_rwlock_t"],"kind":"struct"},"15:11572":{"crate_id":15,"path":["object","elf","Sym32"],"kind":"struct"},"1:9962":{"crate_id":1,"path":["std","backtrace_rs","symbolize","SymbolName"],"kind":"struct"},"14:7024":{"crate_id":14,"path":["gimli","read","op","EvaluationState"],"kind":"enum"},"1:4713":{"crate_id":1,"path":["std","net","addr","ToSocketAddrs"],"kind":"trait"},"9:774":{"crate_id":9,"path":["hashbrown","map","Drain"],"kind":"struct"},"2:42904":{"crate_id":2,"path":["core","iter","sources","once","Once"],"kind":"struct"},"6:3993":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Phdr"],"kind":"struct"},"14:7514":{"crate_id":14,"path":["gimli","read","unit","UnitHeader"],"kind":"struct"},"2:3162":{"crate_id":2,"path":["core","ops","bit","BitXorAssign"],"kind":"trait"},"2:4695":{"crate_id":2,"path":["core","ffi","c_void"],"kind":"enum"},"6:1512":{"crate_id":6,"path":["libc","unix","linux_like","ip_mreq"],"kind":"struct"},"6:4148":{"crate_id":6,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_tp"],"kind":"struct"},"15:9769":{"crate_id":15,"path":["object","read","any","ComdatIteratorInternal"],"kind":"enum"},"15:13788":{"crate_id":15,"path":["object","pe","ImageAlpha64RuntimeFunctionEntry"],"kind":"struct"},"1:1192":{"crate_id":1,"path":["std","collections","hash","map","Iter"],"kind":"struct"},"1:5722":{"crate_id":1,"path":["std","os","unix","net","ancillary","Messages"],"kind":"struct"},"6:509":{"crate_id":6,"path":["libc","unix","utimbuf"],"kind":"struct"},"6:6055":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","termios2"],"kind":"struct"},"15:12507":{"crate_id":15,"path":["object","macho","LinkeditDataCommand"],"kind":"struct"},"15:11159":{"crate_id":15,"path":["object","read","SymbolMapName"],"kind":"struct"},"6:155":{"crate_id":6,"path":["libc","unix","fpos_t"],"kind":"enum"},"15:13986":{"crate_id":15,"path":["object","pe","ImportObjectHeader"],"kind":"struct"},"2:21493":{"crate_id":2,"path":["core","num","fmt","Part"],"kind":"enum"},"5:2667":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Mut"],"kind":"struct"},"17:900":{"crate_id":17,"path":["miniz_oxide","inflate","core","LocalVars"],"kind":"struct"},"1:7423":{"crate_id":1,"path":["std","process","Stdio"],"kind":"struct"},"1:14470":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8"],"kind":"struct"},"5:7062":{"crate_id":5,"path":["alloc","vec","Vec"],"kind":"struct"},"5:6929":{"crate_id":5,"path":["alloc","vec","in_place_drop","InPlaceDrop"],"kind":"struct"},"1:1249":{"crate_id":1,"path":["std","collections","hash","map","Drain"],"kind":"struct"},"14:7146":{"crate_id":14,"path":["gimli","read","op","OperationIter"],"kind":"struct"},"2:10418":{"crate_id":2,"path":["core","slice","iter","SplitNMut"],"kind":"struct"},"5:2663":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Immut"],"kind":"struct"},"14:3287":{"crate_id":14,"path":["gimli","common","DebugTypesOffset"],"kind":"struct"},"1:6181":{"crate_id":1,"path":["std","os","unix","process","CommandExt"],"kind":"trait"},"14:7928":{"crate_id":14,"path":["gimli","read","value","Value"],"kind":"enum"},"1:4743":{"crate_id":1,"path":["rustc_error_codes","Iter"],"kind":"typedef"},"1:7649":{"crate_id":1,"path":["std","sync","mpsc","mpsc_queue","Queue"],"kind":"struct"},"9:1796":{"crate_id":9,"path":["hashbrown","set","Union"],"kind":"struct"},"15:9065":{"crate_id":15,"path":["object","common","SymbolScope"],"kind":"enum"},"15:11915":{"crate_id":15,"path":["object","macho","DyldCacheHeader"],"kind":"struct"},"14:7185":{"crate_id":14,"path":["gimli","read","pubnames","DebugPubNames"],"kind":"struct"},"1:3182":{"crate_id":1,"path":["std","fs","read_dir"],"kind":"function"},"2:45371":{"crate_id":2,"path":["core","str","iter","SplitN"],"kind":"struct"},"15:8929":{"crate_id":15,"path":["object","common","BinaryFormat"],"kind":"enum"},"6:4167":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_filter"],"kind":"struct"},"2:42359":{"crate_id":2,"path":["core","char","convert","CharTryFromError"],"kind":"struct"},"6:1695":{"crate_id":6,"path":["libc","unix","linux_like","mmsghdr"],"kind":"struct"},"2:49206":{"crate_id":2,"path":["core","core_arch","x86","__m128"],"kind":"struct"},"5:5965":{"crate_id":5,"path":["alloc","sync","Arc"],"kind":"struct"},"16:667":{"crate_id":16,"path":["memchr","memmem","rabinkarp","NeedleHash"],"kind":"struct"},"16:650":{"crate_id":16,"path":["memchr","memmem","prefilter","Prefilter"],"kind":"enum"},"15:12010":{"crate_id":15,"path":["object","macho","MachHeader64"],"kind":"struct"},"1:729":{"crate_id":1,"path":["std","thread","local","os","Key"],"kind":"struct"},"1:8468":{"crate_id":1,"path":["rustc_error_codes","Target"],"kind":"typedef"},"6:3658":{"crate_id":6,"path":["libc","unix","linux_like","linux","glob_t"],"kind":"struct"},"15:10403":{"crate_id":15,"path":["object","read","elf","relocation","RelocationSections"],"kind":"struct"},"2:46033":{"crate_id":2,"path":["core","time","FromSecsError"],"kind":"struct"},"6:568":{"crate_id":6,"path":["libc","unix","iovec"],"kind":"struct"},"17:686":{"crate_id":17,"path":["miniz_oxide","deflate","core","SymFreq"],"kind":"struct"},"1:10810":{"crate_id":1,"path":["std","net","ip","IpAddr"],"kind":"enum"},"15:9839":{"crate_id":15,"path":["object","read","any","SymbolTable"],"kind":"struct"},"1:14302":{"crate_id":1,"path":["std","sys","unix","process","process_inner","ExitStatus"],"kind":"struct"},"2:21155":{"crate_id":2,"path":["core","num","bignum","Big32x40"],"kind":"struct"},"1:7025":{"crate_id":1,"path":["std","path","PathBuf"],"kind":"struct"},"15:10673":{"crate_id":15,"path":["object","read","macho","load_command","LoadCommandVariant"],"kind":"enum"},"6:6017":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","mcontext_t"],"kind":"struct"},"2:44650":{"crate_id":2,"path":["core","hash","sip","Hasher"],"kind":"struct"},"5:7596":{"crate_id":5,"path":["alloc","slice","merge_sort","Run"],"kind":"struct"},"1:7236":{"crate_id":1,"path":["rustc_error_codes","Item"],"kind":"typedef"},"9:413":{"crate_id":9,"path":["hashbrown","raw","RawDrain"],"kind":"struct"},"6:6593":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_condattr_t"],"kind":"struct"},"2:3016":{"crate_id":2,"path":["core","marker","Sync"],"kind":"trait"},"2:46046":{"crate_id":2,"path":["core","time","FromSecsErrorKind"],"kind":"enum"},"15:12699":{"crate_id":15,"path":["object","macho","SourceVersionCommand"],"kind":"struct"},"2:21437":{"crate_id":2,"path":["core","num","flt2dec","decoder","Decoded"],"kind":"struct"},"2:10276":{"crate_id":2,"path":["core","slice","iter","SplitInclusiveMut"],"kind":"struct"},"2:42675":{"crate_id":2,"path":["core","iter","adapters","skip","Skip"],"kind":"struct"},"6:6075":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user_fpregs_struct"],"kind":"struct"},"2:45876":{"crate_id":2,"path":["core","str","lossy","Utf8LossyChunk"],"kind":"struct"},"15:11665":{"crate_id":15,"path":["object","elf","Rela64"],"kind":"struct"},"2:12689":{"crate_id":2,"path":["rustc_error_codes","Output"],"kind":"typedef"},"1:7475":{"crate_id":1,"path":["std","process","Termination"],"kind":"trait"},"2:2000":{"crate_id":2,"path":["core","mem","Discriminant"],"kind":"struct"},"2:42494":{"crate_id":2,"path":["core","ffi","VaList"],"kind":"struct"},"2:7432":{"crate_id":2,"path":["rustc_error_codes","Item"],"kind":"typedef"},"15:12343":{"crate_id":15,"path":["object","macho","DysymtabCommand"],"kind":"struct"},"14:3392":{"crate_id":14,"path":["gimli","common","UnitSectionOffset"],"kind":"enum"},"1:5388":{"crate_id":1,"path":["std","os","unix","ffi","os_str","OsStringExt"],"kind":"trait"},"5:4862":{"crate_id":5,"path":["alloc","rc","Weak"],"kind":"struct"},"2:46874":{"crate_id":2,"path":["core","core_arch","simd","u8x4"],"kind":"struct"},"14:7226":{"crate_id":14,"path":["gimli","read","pubtypes","PubTypesEntryIter"],"kind":"struct"},"15:10516":{"crate_id":15,"path":["object","read","elf","version","VerneedIterator"],"kind":"struct"},"1:874":{"crate_id":1,"path":["rustc_error_codes","Owned"],"kind":"typedef"},"5:5985":{"crate_id":5,"path":["alloc","sync","Weak"],"kind":"struct"},"5:3366":{"crate_id":5,"path":["alloc","collections","linked_list","Cursor"],"kind":"struct"},"2:13091":{"crate_id":2,"path":["core","alloc","Allocator"],"kind":"trait"},"2:5686":{"crate_id":2,"path":["core","iter","adapters","flatten","TrustedConstSize"],"kind":"trait"},"1:10694":{"crate_id":1,"path":["std","io","util","Empty"],"kind":"struct"},"1:15266":{"crate_id":1,"path":["std","tuple"],"kind":"primitive"},"15:13884":{"crate_id":15,"path":["object","pe","ImageDebugDirectory"],"kind":"struct"},"14:3506":{"crate_id":14,"path":["gimli","common","DwarfFileType"],"kind":"enum"},"1:10382":{"crate_id":1,"path":["std","ffi","c_str","FromBytesWithNulErrorKind"],"kind":"enum"},"6:4062":{"crate_id":6,"path":["libc","unix","linux_like","linux","posix_spawn_file_actions_t"],"kind":"struct"},"15:12442":{"crate_id":15,"path":["object","macho","TwolevelHintsCommand"],"kind":"struct"},"2:44876":{"crate_id":2,"path":["core","slice","ascii","EscapeAscii"],"kind":"struct"},"15:11628":{"crate_id":15,"path":["object","elf","Rel32"],"kind":"struct"},"2:22041":{"crate_id":2,"path":["core","num","nonzero","NonZeroI16"],"kind":"struct"},"15:13637":{"crate_id":15,"path":["object","pe","ImageLoadConfigDirectory32"],"kind":"struct"},"14:7073":{"crate_id":14,"path":["gimli","read","op","EvaluationResult"],"kind":"enum"},"6:614":{"crate_id":6,"path":["libc","unix","servent"],"kind":"struct"},"2:42726":{"crate_id":2,"path":["core","iter","adapters","zip","Zip"],"kind":"struct"},"6:3780":{"crate_id":6,"path":["libc","unix","linux_like","linux","sembuf"],"kind":"struct"},"16:644":{"crate_id":16,"path":["memchr","memmem","prefilter","PrefilterFn"],"kind":"struct"},"6:3671":{"crate_id":6,"path":["libc","unix","linux_like","linux","passwd"],"kind":"struct"},"15:13429":{"crate_id":15,"path":["object","pe","ImageExportDirectory"],"kind":"struct"},"9:548":{"crate_id":9,"path":["hashbrown","map","HashMap"],"kind":"struct"},"15:11970":{"crate_id":15,"path":["object","macho","FatArch32"],"kind":"struct"},"15:2543":{"crate_id":15,"path":["object","read","elf","relocation","ElfSectionRelocationIterator"],"kind":"struct"},"2:3110":{"crate_id":2,"path":["core","ops","arith","MulAssign"],"kind":"trait"},"1:7338":{"crate_id":1,"path":["std","process","ChildStdout"],"kind":"struct"},"6:5149":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","regex_t"],"kind":"struct"},"1:10012":{"crate_id":1,"path":["std","backtrace_rs","print","BacktraceFrameFmt"],"kind":"struct"},"0:0":{"crate_id":0,"path":["rustc_error_codes"],"kind":"module"},"2:47344":{"crate_id":2,"path":["core","core_arch","simd","u64x2"],"kind":"struct"},"2:3013":{"crate_id":2,"path":["core","marker","StructuralEq"],"kind":"trait"},"1:9316":{"crate_id":1,"path":["std","sys_common","remutex","ReentrantMutex"],"kind":"struct"},"2:47051":{"crate_id":2,"path":["core","core_arch","simd","u64x1"],"kind":"struct"},"15:10028":{"crate_id":15,"path":["object","read","archive","ArchiveFile"],"kind":"struct"},"2:9920":{"crate_id":2,"path":["core","slice","index","private_slice_index","Sealed"],"kind":"trait"},"15:13865":{"crate_id":15,"path":["object","pe","ImageEnclaveImport"],"kind":"struct"},"2:45863":{"crate_id":2,"path":["core","str","pattern","TwoWaySearcher"],"kind":"struct"},"1:10754":{"crate_id":1,"path":["std","io","Take"],"kind":"struct"},"1:10185":{"crate_id":1,"path":["std","thread","local","fast","DtorState"],"kind":"enum"},"2:21913":{"crate_id":2,"path":["core","num","nonzero","NonZeroU64"],"kind":"struct"},"1:1806":{"crate_id":1,"path":["std","collections","hash","set","HashSet"],"kind":"struct"},"14:6032":{"crate_id":14,"path":["gimli","read","endian_slice","EndianSlice"],"kind":"struct"},"1:10744":{"crate_id":1,"path":["std","io","Chain"],"kind":"struct"},"15:13772":{"crate_id":15,"path":["object","pe","ImageArmRuntimeFunctionEntry"],"kind":"struct"},"15:11231":{"crate_id":15,"path":["object","read","Import"],"kind":"struct"},"1:15261":{"crate_id":1,"path":["std","unit"],"kind":"primitive"},"1:1274":{"crate_id":1,"path":["std","collections","hash","map","IntoValues"],"kind":"struct"},"17:1075":{"crate_id":17,"path":["miniz_oxide","StreamResult"],"kind":"struct"},"1:3459":{"crate_id":1,"path":["std","io","buffered","bufwriter","BufWriter"],"kind":"struct"},"2:45146":{"crate_id":2,"path":["core","slice","iter","ArrayChunks"],"kind":"struct"},"14:7236":{"crate_id":14,"path":["gimli","read","rnglists","DebugRanges"],"kind":"struct"},"15:11358":{"crate_id":15,"path":["object","read","CompressedFileRange"],"kind":"struct"},"15:10200":{"crate_id":15,"path":["object","read","coff","comdat","CoffComdatIterator"],"kind":"struct"},"14:5295":{"crate_id":14,"path":["gimli","endianity","RunTimeEndian"],"kind":"enum"},"15:542":{"crate_id":15,"path":["object","read","any","Section"],"kind":"struct"},"2:9371":{"crate_id":2,"path":["core","fmt","Pointer"],"kind":"trait"},"2:2072":{"crate_id":2,"path":["core","ptr","metadata","Pointee"],"kind":"trait"},"1:10807":{"crate_id":1,"path":["std","net","addr","SocketAddrV6"],"kind":"struct"},"1:8057":{"crate_id":1,"path":["std","sync","mpsc","sync","State"],"kind":"struct"},"15:13564":{"crate_id":15,"path":["object","pe","ImageLoadConfigCodeIntegrity"],"kind":"struct"},"5:1506":{"crate_id":5,"path":["alloc","collections","btree","map","{{impl}}","drop","DropGuard"],"kind":"struct"},"2:43605":{"crate_id":2,"path":["core","result","IntoIter"],"kind":"struct"},"15:10160":{"crate_id":15,"path":["object","read","coff","symbol","CoffSymbolTable"],"kind":"struct"},"6:6467":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","not_x32","statvfs"],"kind":"struct"},"9:0":{"crate_id":9,"path":["hashbrown"],"kind":"module"},"15:9729":{"crate_id":15,"path":["object","read","any","SectionIteratorInternal"],"kind":"enum"},"15:12480":{"crate_id":15,"path":["object","macho","UuidCommand"],"kind":"struct"},"5:4450":{"crate_id":5,"path":["alloc","raw_vec","RawVec"],"kind":"struct"},"2:12188":{"crate_id":2,"path":["core","str","lossy","Utf8LossyChunksIter"],"kind":"struct"},"1:6979":{"crate_id":1,"path":["std","path","{{impl}}","fmt","DebugHelper"],"kind":"struct"},"15:9971":{"crate_id":15,"path":["object","read","any","SectionRelocationIteratorInternal"],"kind":"enum"},"1:14439":{"crate_id":1,"path":["std","sys_common","wtf8","CodePoint"],"kind":"struct"},"14:7174":{"crate_id":14,"path":["gimli","read","pubnames","PubNamesEntry"],"kind":"struct"},"2:43828":{"crate_id":2,"path":["core","sync","atomic","AtomicU32"],"kind":"struct"},"1:7198":{"crate_id":1,"path":["std","path","Display"],"kind":"struct"},"15:12552":{"crate_id":15,"path":["object","macho","EncryptionInfoCommand64"],"kind":"struct"},"2:44625":{"crate_id":2,"path":["core","hash","sip","SipHasher13"],"kind":"struct"},"15:9368":{"crate_id":15,"path":["object","endian","U64Bytes"],"kind":"struct"},"15:12095":{"crate_id":15,"path":["object","macho","Section32"],"kind":"struct"},"5:3232":{"crate_id":5,"path":["alloc","collections","linked_list","LinkedList"],"kind":"struct"},"9:884":{"crate_id":9,"path":["hashbrown","map","RawEntryBuilder"],"kind":"struct"},"2:44641":{"crate_id":2,"path":["core","hash","sip","SipHasher"],"kind":"struct"},"14:7342":{"crate_id":14,"path":["gimli","read","rnglists","RawRange"],"kind":"struct"},"15:10635":{"crate_id":15,"path":["object","read","macho","load_command","LoadCommandIterator"],"kind":"struct"},"15:12917":{"crate_id":15,"path":["object","pe","ImageDosHeader"],"kind":"struct"},"1:3547":{"crate_id":1,"path":["std","io","buffered","linewriter","LineWriter"],"kind":"struct"},"9:338":{"crate_id":9,"path":["hashbrown","raw","RawIterRange"],"kind":"struct"},"14:4350":{"crate_id":14,"path":["gimli","constants","DwAte"],"kind":"struct"},"15:1236":{"crate_id":15,"path":["object","read","coff","symbol","CoffSymbolIterator"],"kind":"struct"},"6:5846":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stat"],"kind":"struct"},"2:48123":{"crate_id":2,"path":["core","core_arch","simd","i16x16"],"kind":"struct"},"2:28635":{"crate_id":2,"path":["core","num","FpCategory"],"kind":"enum"},"2:3456":{"crate_id":2,"path":["core","ops","unsize","CoerceUnsized"],"kind":"trait"},"14:7303":{"crate_id":14,"path":["gimli","read","rnglists","RawRngListEntry"],"kind":"enum"},"5:1371":{"crate_id":5,"path":["alloc","collections","btree","map","RangeMut"],"kind":"struct"},"18:0":{"crate_id":18,"path":["adler"],"kind":"module"},"2:34963":{"crate_id":2,"path":["core","marker","PhantomPinned"],"kind":"struct"},"1:8578":{"crate_id":1,"path":["std","sync","poison","PoisonError"],"kind":"struct"},"2:45172":{"crate_id":2,"path":["core","slice","iter","RChunks"],"kind":"struct"},"9:876":{"crate_id":9,"path":["hashbrown","map","RawVacantEntryMut"],"kind":"struct"},"15:12598":{"crate_id":15,"path":["object","macho","BuildToolVersion"],"kind":"struct"},"14:5488":{"crate_id":14,"path":["gimli","read","cfi","SectionBaseAddresses"],"kind":"struct"},"15:10407":{"crate_id":15,"path":["object","read","elf","comdat","ElfComdatIterator"],"kind":"struct"},"11:189":{"crate_id":11,"path":["rustc_demangle","Demangle"],"kind":"struct"},"5:7697":{"crate_id":5,"path":["alloc","vec","splice","Splice"],"kind":"struct"},"1:9951":{"crate_id":1,"path":["std","backtrace_rs","symbolize","Symbol"],"kind":"struct"},"2:47393":{"crate_id":2,"path":["core","core_arch","simd","i8x16"],"kind":"struct"},"2:21343":{"crate_id":2,"path":["core","num","dec2flt","common","BiasedFp"],"kind":"struct"},"15:12659":{"crate_id":15,"path":["object","macho","IdentCommand"],"kind":"struct"},"2:4264":{"crate_id":2,"path":["core","cell","BorrowError"],"kind":"struct"},"2:45243":{"crate_id":2,"path":["core","str","iter","CharIndices"],"kind":"struct"},"15:13497":{"crate_id":15,"path":["object","pe","ImageBoundForwarderRef"],"kind":"struct"},"15:11519":{"crate_id":15,"path":["object","elf","SectionHeader64"],"kind":"struct"},"1:11030":{"crate_id":1,"path":["std","os","fd","owned","BorrowedFd"],"kind":"struct"},"2:43936":{"crate_id":2,"path":["core","sync","atomic","AtomicIsize"],"kind":"struct"},"17:1056":{"crate_id":17,"path":["miniz_oxide","DataFormat"],"kind":"enum"},"15:11015":{"crate_id":15,"path":["object","read","pe","section","PeRelocationIterator"],"kind":"struct"},"15:13819":{"crate_id":15,"path":["object","pe","ImageEnclaveConfig32"],"kind":"struct"},"17:41":{"crate_id":17,"path":["miniz_oxide","deflate","buffer","LocalBuf"],"kind":"struct"},"15:13799":{"crate_id":15,"path":["object","pe","ImageAlphaRuntimeFunctionEntry"],"kind":"struct"},"2:48594":{"crate_id":2,"path":["core","core_arch","simd","u8x64"],"kind":"struct"},"14:6366":{"crate_id":14,"path":["gimli","read","line","LineRow"],"kind":"struct"},"14:5456":{"crate_id":14,"path":["gimli","read","cfi","CieOffsetEncoding"],"kind":"enum"},"14:3018":{"crate_id":14,"path":["gimli","common","DebugLocListsBase"],"kind":"struct"},"14:3549":{"crate_id":14,"path":["gimli","arch","X86"],"kind":"struct"},"2:44124":{"crate_id":2,"path":["core","fmt","num","Binary"],"kind":"struct"},"1:7958":{"crate_id":1,"path":["std","sync","mpsc","stream","Packet"],"kind":"struct"},"6:622":{"crate_id":6,"path":["libc","unix","protoent"],"kind":"struct"},"15:13540":{"crate_id":15,"path":["object","pe","ImageResourceDirectoryString"],"kind":"struct"},"15:2512":{"crate_id":15,"path":["object","read","elf","relocation","ElfDynamicRelocationIterator"],"kind":"struct"},"1:7117":{"crate_id":1,"path":["rustc_error_codes","Owned"],"kind":"typedef"},"6:3762":{"crate_id":6,"path":["libc","unix","linux_like","linux","if_nameindex"],"kind":"struct"},"6:4031":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Shdr"],"kind":"struct"},"2:7976":{"crate_id":2,"path":["core","lazy","Lazy"],"kind":"struct"},"1:5526":{"crate_id":1,"path":["std","os","unix","fs","DirEntryExt"],"kind":"trait"},"2:46978":{"crate_id":2,"path":["core","core_arch","simd","u8x8"],"kind":"struct"},"14:5941":{"crate_id":14,"path":["gimli","read","cfi","Pointer"],"kind":"enum"},"14:7894":{"crate_id":14,"path":["gimli","read","value","ValueType"],"kind":"enum"},"15:11616":{"crate_id":15,"path":["object","elf","Syminfo64"],"kind":"struct"},"14:3365":{"crate_id":14,"path":["gimli","common","EhFrameOffset"],"kind":"struct"},"15:510":{"crate_id":15,"path":["object","read","any","Segment"],"kind":"struct"},"2:45210":{"crate_id":2,"path":["core","str","error","Utf8Error"],"kind":"struct"},"1:14755":{"crate_id":1,"path":["std","backtrace_rs","backtrace","Frame"],"kind":"struct"},"14:6768":{"crate_id":14,"path":["gimli","read","lookup","PubStuffParser"],"kind":"struct"},"2:46849":{"crate_id":2,"path":["core","core_arch","simd","i8x2"],"kind":"struct"},"14:7042":{"crate_id":14,"path":["gimli","read","op","EvaluationWaiting"],"kind":"enum"},"15:12725":{"crate_id":15,"path":["object","macho","NoteCommand"],"kind":"struct"},"15:9799":{"crate_id":15,"path":["object","read","any","ComdatSectionIterator"],"kind":"struct"},"15:13963":{"crate_id":15,"path":["object","pe","NonPagedDebugInfo"],"kind":"struct"},"2:48848":{"crate_id":2,"path":["core","core_arch","simd","u16x32"],"kind":"struct"},"9:1052":{"crate_id":9,"path":["hashbrown","map","VacantEntry"],"kind":"struct"},"1:940":{"crate_id":1,"path":["std","backtrace","BytesOrWide"],"kind":"enum"},"14:5505":{"crate_id":14,"path":["gimli","read","cfi","CfiEntriesIter"],"kind":"struct"},"6:4090":{"crate_id":6,"path":["libc","unix","linux_like","linux","in6_pktinfo"],"kind":"struct"},"15:12582":{"crate_id":15,"path":["object","macho","BuildVersionCommand"],"kind":"struct"},"16:866":{"crate_id":16,"path":["memchr","memmem","SearcherKind"],"kind":"enum"},"5:5163":{"crate_id":5,"path":["rustc_error_codes","Output"],"kind":"typedef"},"2:42615":{"crate_id":2,"path":["core","iter","adapters","intersperse","Intersperse"],"kind":"struct"},"2:42527":{"crate_id":2,"path":["core","iter","adapters","cloned","Cloned"],"kind":"struct"},"2:6896":{"crate_id":2,"path":["core","iter","adapters","ResultShunt"],"kind":"struct"},"6:5137":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","ntptimeval"],"kind":"struct"},"14:2945":{"crate_id":14,"path":["gimli","common","DebugLineOffset"],"kind":"struct"},"6:5059":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","nl_pktinfo"],"kind":"struct"},"2:47156":{"crate_id":2,"path":["core","core_arch","simd","i64x1"],"kind":"struct"},"9:1756":{"crate_id":9,"path":["hashbrown","set","Iter"],"kind":"struct"},"2:45110":{"crate_id":2,"path":["core","slice","iter","ChunksExactMut"],"kind":"struct"},"14:5522":{"crate_id":14,"path":["gimli","read","cfi","CieOrFde"],"kind":"enum"},"6:1580":{"crate_id":6,"path":["libc","unix","linux_like","tm"],"kind":"struct"},"2:3086":{"crate_id":2,"path":["core","ops","arith","Div"],"kind":"trait"},"2:43486":{"crate_id":2,"path":["core","panic","location","Location"],"kind":"struct"},"1:3807":{"crate_id":1,"path":["std","io","error","Repr"],"kind":"enum"},"2:45991":{"crate_id":2,"path":["core","str","IsWhitespace"],"kind":"struct"},"1:15282":{"crate_id":1,"path":["std","fn"],"kind":"primitive"},"1:10834":{"crate_id":1,"path":["std","net","ip","Ipv4Addr"],"kind":"struct"},"6:3747":{"crate_id":6,"path":["libc","unix","linux_like","linux","packet_mreq"],"kind":"struct"},"6:1507":{"crate_id":6,"path":["libc","unix","linux_like","in_addr"],"kind":"struct"},"6:4137":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_extended_err"],"kind":"struct"},"14:5472":{"crate_id":14,"path":["gimli","read","cfi","BaseAddresses"],"kind":"struct"},"2:24892":{"crate_id":2,"path":["core","num","wrapping","Wrapping"],"kind":"struct"},"10:0":{"crate_id":10,"path":["rustc_std_workspace_alloc"],"kind":"module"},"14:7870":{"crate_id":14,"path":["gimli","read","unit","DebugTypes"],"kind":"struct"},"1:858":{"crate_id":1,"path":["std","ascii","AsciiExt"],"kind":"trait"},"2:44131":{"crate_id":2,"path":["core","fmt","num","Octal"],"kind":"struct"},"1:14088":{"crate_id":1,"path":["std","sys","unix","os","JoinPathsError"],"kind":"struct"},"15:9245":{"crate_id":15,"path":["object","endian","Endianness"],"kind":"enum"},"15:10584":{"crate_id":15,"path":["object","read","macho","file","MachOFile"],"kind":"struct"},"1:10563":{"crate_id":1,"path":["std","io","cursor","Cursor"],"kind":"struct"},"9:453":{"crate_id":9,"path":["hashbrown","raw","RawIterHashInner"],"kind":"struct"},"5:1292":{"crate_id":5,"path":["alloc","collections","btree","map","IterMut"],"kind":"struct"},"1:9459":{"crate_id":1,"path":["std","sys_common","thread_local_key","Key"],"kind":"struct"},"15:11678":{"crate_id":15,"path":["object","elf","ProgramHeader32"],"kind":"struct"},"14:4671":{"crate_id":14,"path":["gimli","constants","DwId"],"kind":"struct"},"2:49197":{"crate_id":2,"path":["core","core_arch","x86","__m128i"],"kind":"struct"},"2:3137":{"crate_id":2,"path":["core","ops","bit","BitXor"],"kind":"trait"},"6:3954":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Ehdr"],"kind":"struct"},"6:4190":{"crate_id":6,"path":["libc","unix","linux_like","linux","nlmsghdr"],"kind":"struct"},"1:6529":{"crate_id":1,"path":["std","os","linux","process","ChildExt"],"kind":"trait"},"6:1686":{"crate_id":6,"path":["libc","unix","linux_like","arphdr"],"kind":"struct"},"2:43623":{"crate_id":2,"path":["core","sync","atomic","Ordering"],"kind":"enum"},"5:674":{"crate_id":5,"path":["alloc","collections","binary_heap","PeekMut"],"kind":"struct"},"1:2929":{"crate_id":1,"path":["rustc_error_codes","Owned"],"kind":"typedef"},"17:234":{"crate_id":17,"path":["miniz_oxide","deflate","core","HuffmanOxide"],"kind":"struct"},"6:4071":{"crate_id":6,"path":["libc","unix","linux_like","linux","posix_spawnattr_t"],"kind":"struct"},"2:2946":{"crate_id":2,"path":["rustc_error_codes","Error"],"kind":"typedef"},"2:2913":{"crate_id":2,"path":["core","convert","TryInto"],"kind":"trait"},"2:47567":{"crate_id":2,"path":["core","core_arch","simd","f64x4"],"kind":"struct"},"1:7132":{"crate_id":1,"path":["std","path","Path"],"kind":"struct"},"2:9357":{"crate_id":2,"path":["core","fmt","macros","Debug"],"kind":"proc_derive"},"15:9088":{"crate_id":15,"path":["object","common","RelocationKind"],"kind":"enum"},"2:47883":{"crate_id":2,"path":["core","core_arch","simd","u16x16"],"kind":"struct"},"6:4005":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Phdr"],"kind":"struct"},"5:3008":{"crate_id":5,"path":["alloc","collections","btree","set","DrainFilter"],"kind":"struct"},"15:11378":{"crate_id":15,"path":["object","read","CompressedData"],"kind":"struct"},"2:4269":{"crate_id":2,"path":["core","cell","BorrowMutError"],"kind":"struct"},"13:230":{"crate_id":13,"path":["addr2line","LocationRangeIter"],"kind":"struct"},"14:5407":{"crate_id":14,"path":["gimli","read","cfi","ParsedEhFrameHdr"],"kind":"struct"},"2:3132":{"crate_id":2,"path":["core","ops","bit","BitOr"],"kind":"trait"},"2:44680":{"crate_id":2,"path":["core","hash","sip","Sip24Rounds"],"kind":"struct"},"1:1270":{"crate_id":1,"path":["std","collections","hash","map","IntoKeys"],"kind":"struct"},"1:8426":{"crate_id":1,"path":["std","sync","mutex","MutexGuard"],"kind":"struct"},"14:6072":{"crate_id":14,"path":["gimli","read","reader","ReaderOffsetId"],"kind":"struct"},"1:4415":{"crate_id":1,"path":["std","io","Write","write_fmt","Adapter"],"kind":"struct"},"15:13098":{"crate_id":15,"path":["object","pe","ImageRomOptionalHeader"],"kind":"struct"},"1:10555":{"crate_id":1,"path":["std","io","buffered","IntoInnerError"],"kind":"struct"},"1:5530":{"crate_id":1,"path":["std","os","unix","fs","DirEntryExt2"],"kind":"trait"},"15:11030":{"crate_id":15,"path":["object","read","Error"],"kind":"struct"},"16:744":{"crate_id":16,"path":["memchr","memmem","twoway","SuffixKind"],"kind":"enum"},"15:13547":{"crate_id":15,"path":["object","pe","ImageResourceDirStringU"],"kind":"struct"},"15:10571":{"crate_id":15,"path":["object","read","macho","dyld_cache","DyldCacheImage"],"kind":"struct"},"2:2199":{"crate_id":2,"path":["core","ptr","non_null","NonNull"],"kind":"struct"},"14:6731":{"crate_id":14,"path":["gimli","read","lookup","LookupEntryIter"],"kind":"struct"},"16:610":{"crate_id":16,"path":["memchr","cow","CowBytes"],"kind":"struct"},"1:3029":{"crate_id":1,"path":["std","fs","File"],"kind":"struct"},"14:6464":{"crate_id":14,"path":["gimli","read","line","IncompleteLineProgram"],"kind":"struct"},"14:4304":{"crate_id":14,"path":["gimli","constants","DwForm"],"kind":"struct"},"2:14":{"crate_id":2,"path":["core","write"],"kind":"macro"},"5:1893":{"crate_id":5,"path":["alloc","collections","btree","navigate","LeafRange"],"kind":"struct"},"15:13746":{"crate_id":15,"path":["object","pe","ImageHotPatchBase"],"kind":"struct"},"1:15273":{"crate_id":1,"path":["std","i128"],"kind":"primitive"},"2:22105":{"crate_id":2,"path":["core","num","nonzero","NonZeroI64"],"kind":"struct"},"14:6577":{"crate_id":14,"path":["gimli","read","loclists","DebugLoc"],"kind":"struct"},"16:712":{"crate_id":16,"path":["memchr","memmem","twoway","Reverse"],"kind":"struct"},"14:3145":{"crate_id":14,"path":["gimli","common","RangeListsOffset"],"kind":"struct"},"15:12645":{"crate_id":15,"path":["object","macho","SymsegCommand"],"kind":"struct"},"9:2074":{"crate_id":9,"path":["hashbrown","raw","TableLayout"],"kind":"struct"},"2:2904":{"crate_id":2,"path":["core","convert","AsMut"],"kind":"trait"},"1:6299":{"crate_id":1,"path":["std","os","unix","thread","JoinHandleExt"],"kind":"trait"},"6:1643":{"crate_id":6,"path":["libc","unix","linux_like","ifaddrs"],"kind":"struct"},"1:14489":{"crate_id":1,"path":["std","sys_common","wtf8","EncodeWide"],"kind":"struct"},"5:6418":{"crate_id":5,"path":["alloc","vec","drain_filter","{{impl}}","drop","BackshiftOnDrop"],"kind":"struct"},"1:5468":{"crate_id":1,"path":["std","os","unix","fs","PermissionsExt"],"kind":"trait"},"2:7997":{"crate_id":2,"path":["rustc_error_codes","Target"],"kind":"typedef"},"2:45647":{"crate_id":2,"path":["core","str","pattern","SearchStep"],"kind":"enum"},"2:12820":{"crate_id":2,"path":["core","future","from_generator","GenFuture"],"kind":"struct"},"6:4181":{"crate_id":6,"path":["libc","unix","linux_like","linux","seccomp_data"],"kind":"struct"},"5:3921":{"crate_id":5,"path":["alloc","collections","vec_deque","iter","Iter"],"kind":"struct"},"2:9375":{"crate_id":2,"path":["core","fmt","UpperExp"],"kind":"trait"},"5:5713":{"crate_id":5,"path":["rustc_error_codes","Target"],"kind":"typedef"},"1:8735":{"crate_id":1,"path":["rustc_error_codes","Target"],"kind":"typedef"},"5:5785":{"crate_id":5,"path":["alloc","string","Drain"],"kind":"struct"},"2:11020":{"crate_id":2,"path":["core","slice","sort","CopyOnDrop"],"kind":"struct"},"2:2625":{"crate_id":2,"path":["core","clone","Clone"],"kind":"trait"},"2:6975":{"crate_id":2,"path":["core","iter","range","Step"],"kind":"trait"},"1:15268":{"crate_id":1,"path":["std","f64"],"kind":"primitive"},"1:11656":{"crate_id":1,"path":["std","sync","mpsc","TryIter"],"kind":"struct"},"6:3850":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_constant_effect"],"kind":"struct"},"15:2314":{"crate_id":15,"path":["object","read","elf","symbol","ElfSymbolIterator"],"kind":"struct"},"2:43614":{"crate_id":2,"path":["core","stream","from_iter","FromIter"],"kind":"struct"},"1:4188":{"crate_id":1,"path":["std","io","stdio","Stderr"],"kind":"struct"},"1:13717":{"crate_id":1,"path":["std","sys","unix","stdio","Stdin"],"kind":"struct"},"2:45471":{"crate_id":2,"path":["core","str","iter","Matches"],"kind":"struct"},"1:7304":{"crate_id":1,"path":["std","process","Child"],"kind":"struct"},"5:2927":{"crate_id":5,"path":["alloc","collections","btree","set","Union"],"kind":"struct"},"15:13532":{"crate_id":15,"path":["object","pe","ImageResourceDirectoryEntry"],"kind":"struct"},"2:44379":{"crate_id":2,"path":["core","fmt","rt","v1","FormatSpec"],"kind":"struct"},"1:12281":{"crate_id":1,"path":["std","sys","unix","fs","File"],"kind":"struct"},"5:7477":{"crate_id":5,"path":["alloc","collections","btree","set","DifferenceInner"],"kind":"enum"},"2:3142":{"crate_id":2,"path":["core","ops","bit","Shl"],"kind":"trait"},"2:10109":{"crate_id":2,"path":["core","slice","iter","Iter"],"kind":"struct"},"1:4099":{"crate_id":1,"path":["std","io","stdio","Stdin"],"kind":"struct"},"9:738":{"crate_id":9,"path":["hashbrown","map","IntoIter"],"kind":"struct"},"15:10149":{"crate_id":15,"path":["object","read","coff","symbol","SymbolIterator"],"kind":"struct"},"15:13582":{"crate_id":15,"path":["object","pe","ImageDynamicRelocation32"],"kind":"struct"},"2:8847":{"crate_id":2,"path":["core","stream","stream","Stream"],"kind":"trait"},"15:9162":{"crate_id":15,"path":["object","common","FileFlags"],"kind":"enum"},"1:6532":{"crate_id":1,"path":["std","os","linux","process","CommandExt"],"kind":"trait"},"9:1442":{"crate_id":9,"path":["hashbrown","rustc_entry","RustcVacantEntry"],"kind":"struct"},"2:45764":{"crate_id":2,"path":["core","str","pattern","CharSliceSearcher"],"kind":"struct"},"15:11328":{"crate_id":15,"path":["object","read","Relocation"],"kind":"struct"},"15:11847":{"crate_id":15,"path":["object","elf","GnuHashHeader"],"kind":"struct"},"1:2708":{"crate_id":1,"path":["rustc_error_codes","Owned"],"kind":"typedef"},"5:1258":{"crate_id":5,"path":["alloc","collections","btree","map","BTreeMap"],"kind":"struct"},"15:11045":{"crate_id":15,"path":["object","read","FileKind"],"kind":"enum"},"15:10988":{"crate_id":15,"path":["object","read","pe","section","PeSectionIterator"],"kind":"struct"},"6:3973":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Sym"],"kind":"struct"},"5:5175":{"crate_id":5,"path":["rustc_error_codes","Output"],"kind":"typedef"},"2:4716":{"crate_id":2,"path":["core","ffi","sealed_trait","VaArgSafe"],"kind":"trait"},"1:10547":{"crate_id":1,"path":["std","io","buffered","linewritershim","LineWriterShim"],"kind":"struct"},"2:43419":{"crate_id":2,"path":["core","option","Option"],"kind":"enum"},"6:6041":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","shmid_ds"],"kind":"struct"},"14:6636":{"crate_id":14,"path":["gimli","read","loclists","RawLocListIter"],"kind":"struct"},"1:2812":{"crate_id":1,"path":["rustc_error_codes","Target"],"kind":"typedef"},"2:44364":{"crate_id":2,"path":["core","fmt","Alignment"],"kind":"enum"},"14:3118":{"crate_id":14,"path":["gimli","common","RawRangeListsOffset"],"kind":"struct"},"15:10611":{"crate_id":15,"path":["object","read","macho","file","MachOComdat"],"kind":"struct"},"1:10589":{"crate_id":1,"path":["std","io","error","ErrorKind"],"kind":"enum"},"1:1278":{"crate_id":1,"path":["std","collections","hash","map","RawEntryBuilderMut"],"kind":"struct"},"14:4448":{"crate_id":14,"path":["gimli","constants","DwEnd"],"kind":"struct"},"2:49237":{"crate_id":2,"path":["core","core_arch","x86","__m256"],"kind":"struct"},"15:12373":{"crate_id":15,"path":["object","macho","DylibTableOfContents"],"kind":"struct"},"2:42922":{"crate_id":2,"path":["core","iter","sources","repeat","Repeat"],"kind":"struct"},"6:1738":{"crate_id":6,"path":["libc","unix","linux_like","sigevent"],"kind":"struct"},"1:1945":{"crate_id":1,"path":["std","collections","hash","set","DrainFilter"],"kind":"struct"},"11:47":{"crate_id":11,"path":["rustc_demangle","v0","Demangle"],"kind":"struct"},"5:7575":{"crate_id":5,"path":["alloc","collections","TryReserveErrorKind"],"kind":"enum"},"1:14105":{"crate_id":1,"path":["std","sys","unix","process","process_common","ExitCode"],"kind":"struct"},"2:44662":{"crate_id":2,"path":["core","hash","sip","State"],"kind":"struct"},"2:46249":{"crate_id":2,"path":["core","alloc","AllocError"],"kind":"struct"},"1:10722":{"crate_id":1,"path":["std","io","SeekFrom"],"kind":"enum"},"1:6427":{"crate_id":1,"path":["std","os","linux","fs","MetadataExt"],"kind":"trait"},"2:8886":{"crate_id":2,"path":["core","sync","atomic","AtomicBool"],"kind":"struct"},"1:10971":{"crate_id":1,"path":["std","os","unix","net","ancillary","SocketAncillary"],"kind":"struct"},"14:7360":{"crate_id":14,"path":["gimli","read","rnglists","Range"],"kind":"struct"},"2:42644":{"crate_id":2,"path":["core","iter","adapters","peekable","Peekable"],"kind":"struct"},"5:5567":{"crate_id":5,"path":["alloc","string","{{impl}}","retain","SetLenOnDrop"],"kind":"struct"},"1:1301":{"crate_id":1,"path":["std","collections","hash","map","RawVacantEntryMut"],"kind":"struct"},"6:657":{"crate_id":6,"path":["libc","unix","linux_like","timezone"],"kind":"enum"},"15:13898":{"crate_id":15,"path":["object","pe","ImageCoffSymbolsHeader"],"kind":"struct"},"1:692":{"crate_id":1,"path":["std","thread","local","fast","Key"],"kind":"struct"},"1:634":{"crate_id":1,"path":["std","thread","local","LocalKey"],"kind":"struct"},"6:3873":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_periodic_effect"],"kind":"struct"},"2:43537":{"crate_id":2,"path":["core","pin","Pin"],"kind":"struct"},"2:45022":{"crate_id":2,"path":["core","slice","iter","GenericSplitN"],"kind":"struct"},"1:1962":{"crate_id":1,"path":["std","collections","hash","set","SymmetricDifference"],"kind":"struct"},"2:44418":{"crate_id":2,"path":["core","fmt","Error"],"kind":"struct"},"1:10308":{"crate_id":1,"path":["std","error","Chain"],"kind":"struct"},"15:12028":{"crate_id":15,"path":["object","macho","LoadCommand"],"kind":"struct"},"2:21523":{"crate_id":2,"path":["core","num","fmt","Formatted"],"kind":"struct"},"15:13477":{"crate_id":15,"path":["object","pe","ImageImportDescriptor"],"kind":"struct"},"1:10037":{"crate_id":1,"path":["std","backtrace_rs","Bomb"],"kind":"struct"},"6:3885":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_rumble_effect"],"kind":"struct"},"15:12783":{"crate_id":15,"path":["object","macho","RelocationInfo"],"kind":"struct"},"5:6672":{"crate_id":5,"path":["alloc","vec","into_iter","IntoIter"],"kind":"struct"},"5:3323":{"crate_id":5,"path":["alloc","collections","linked_list","{{impl}}","drop","DropGuard"],"kind":"struct"},"1:4147":{"crate_id":1,"path":["std","io","stdio","StdoutLock"],"kind":"struct"},"9:1008":{"crate_id":9,"path":["hashbrown","map","Entry"],"kind":"enum"},"2:41876":{"crate_id":2,"path":["core","ops","control_flow","ControlFlow"],"kind":"enum"},"1:2338":{"crate_id":1,"path":["std","error","Error"],"kind":"trait"},"2:42405":{"crate_id":2,"path":["core","char","EscapeUnicodeState"],"kind":"enum"},"1:4289":{"crate_id":1,"path":["std","io","util","Repeat"],"kind":"struct"},"5:687":{"crate_id":5,"path":["rustc_error_codes","Target"],"kind":"typedef"},"1:10368":{"crate_id":1,"path":["std","ffi","c_str","FromVecWithNulError"],"kind":"struct"},"5:2393":{"crate_id":5,"path":["alloc","collections","btree","node","Handle"],"kind":"struct"},"15:4008":{"crate_id":15,"path":["object","read","macho","symbol","MachOSymbolIterator"],"kind":"struct"},"14:4230":{"crate_id":14,"path":["gimli","constants","DwAt"],"kind":"struct"},"1:11799":{"crate_id":1,"path":["std","time","SystemTime"],"kind":"struct"},"1:13579":{"crate_id":1,"path":["std","sys","unix","stack_overflow","Handler"],"kind":"struct"},"14:4506":{"crate_id":14,"path":["gimli","constants","DwVis"],"kind":"struct"},"14:6110":{"crate_id":14,"path":["gimli","read","abbrev","Abbreviation"],"kind":"struct"},"1:1284":{"crate_id":1,"path":["std","collections","hash","map","RawEntryMut"],"kind":"enum"},"1:15281":{"crate_id":1,"path":["std","reference"],"kind":"primitive"},"1:4060":{"crate_id":1,"path":["std","io","stdio","StdinRaw"],"kind":"struct"},"2:7470":{"crate_id":2,"path":["core","iter","traits","double_ended","DoubleEndedIterator"],"kind":"trait"},"2:4386":{"crate_id":2,"path":["core","cell","BorrowRefMut"],"kind":"struct"},"1:11759":{"crate_id":1,"path":["std","sync","condvar","WaitTimeoutResult"],"kind":"struct"},"6:515":{"crate_id":6,"path":["libc","unix","timeval"],"kind":"struct"},"2:42635":{"crate_id":2,"path":["core","iter","adapters","map_while","MapWhile"],"kind":"struct"},"2:11976":{"crate_id":2,"path":["core","str","pattern","Searcher"],"kind":"trait"},"9:785":{"crate_id":9,"path":["hashbrown","map","DrainFilter"],"kind":"struct"},"6:606":{"crate_id":6,"path":["libc","unix","tms"],"kind":"struct"},"1:6948":{"crate_id":1,"path":["std","path","{{impl}}","fmt","DebugHelper"],"kind":"struct"},"15:9689":{"crate_id":15,"path":["object","read","any","SegmentInternal"],"kind":"enum"},"2:47114":{"crate_id":2,"path":["core","core_arch","simd","i16x4"],"kind":"struct"},"1:5394":{"crate_id":1,"path":["std","os","unix","ffi","os_str","OsStrExt"],"kind":"trait"},"2:11957":{"crate_id":2,"path":["core","str","pattern"],"kind":"module"},"16:801":{"crate_id":16,"path":["memchr","memmem","FindRevIter"],"kind":"struct"},"2:42583":{"crate_id":2,"path":["core","iter","adapters","flatten","FlattenCompat"],"kind":"struct"},"15:13520":{"crate_id":15,"path":["object","pe","ImageResourceDirectory"],"kind":"struct"},"2:43477":{"crate_id":2,"path":["core","option","IntoIter"],"kind":"struct"},"5:7385":{"crate_id":5,"path":["alloc","alloc","Global"],"kind":"struct"},"15:681":{"crate_id":15,"path":["object","read","any","Symbol"],"kind":"struct"},"6:4115":{"crate_id":6,"path":["libc","unix","linux_like","linux","fanotify_response"],"kind":"struct"},"1:4406":{"crate_id":1,"path":["std","io","Write"],"kind":"trait"},"2:43469":{"crate_id":2,"path":["core","option","IterMut"],"kind":"struct"},"14:4641":{"crate_id":14,"path":["gimli","constants","DwAddr"],"kind":"struct"},"15:12307":{"crate_id":15,"path":["object","macho","RoutinesCommand64"],"kind":"struct"},"1:11597":{"crate_id":1,"path":["std","sync","mpsc","shared","StartResult"],"kind":"enum"},"2:7606":{"crate_id":2,"path":["core","iter","traits","iterator","Iterator"],"kind":"trait"},"1:14384":{"crate_id":1,"path":["std","sys_common","process","CommandEnv"],"kind":"struct"},"1:4190":{"crate_id":1,"path":["std","io","stdio","StderrLock"],"kind":"struct"},"2:3282":{"crate_id":2,"path":["core","ops","generator","Generator"],"kind":"trait"},"2:47494":{"crate_id":2,"path":["core","core_arch","simd","i64x2"],"kind":"struct"},"1:13720":{"crate_id":1,"path":["std","sys","unix","stdio","Stdout"],"kind":"struct"},"2:11712":{"crate_id":2,"path":["core","str","iter","MatchesInternal"],"kind":"struct"},"1:15278":{"crate_id":1,"path":["std","u128"],"kind":"primitive"},"14:7216":{"crate_id":14,"path":["gimli","read","pubtypes","DebugPubTypes"],"kind":"struct"},"2:45489":{"crate_id":2,"path":["core","str","iter","RMatches"],"kind":"struct"},"1:15258":{"crate_id":1,"path":["std","bool"],"kind":"primitive"},"14:4790":{"crate_id":14,"path":["gimli","constants","DwDsc"],"kind":"struct"},"1:13420":{"crate_id":1,"path":["std","sys","unix","process","process_common","Stdio"],"kind":"enum"},"2:21414":{"crate_id":2,"path":["core","num","dec2flt","FloatErrorKind"],"kind":"enum"},"14:5975":{"crate_id":14,"path":["gimli","read","dwarf","Dwarf"],"kind":"struct"},"2:3071":{"crate_id":2,"path":["core","ops","arith","Add"],"kind":"trait"},"2:4742":{"crate_id":2,"path":["core","iter"],"kind":"module"},"2:48387":{"crate_id":2,"path":["core","core_arch","simd","i8x64"],"kind":"struct"},"1:7368":{"crate_id":1,"path":["std","process","Command"],"kind":"struct"},"15:9961":{"crate_id":15,"path":["object","read","any","SectionRelocationIterator"],"kind":"struct"},"14:6949":{"crate_id":14,"path":["gimli","read","op","OperationEvaluationResult"],"kind":"enum"},"14:3522":{"crate_id":14,"path":["gimli","arch","Arm"],"kind":"struct"},"15:8902":{"crate_id":15,"path":["object","common","AddressSize"],"kind":"enum"},"1:824":{"crate_id":1,"path":["std","thread","JoinHandle"],"kind":"struct"},"5:2661":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Owned"],"kind":"enum"},"2:9365":{"crate_id":2,"path":["core","fmt","Binary"],"kind":"trait"},"2:12683":{"crate_id":2,"path":["core","future","into_future","IntoFuture"],"kind":"trait"},"1:3037":{"crate_id":1,"path":["std","fs","read_to_string"],"kind":"function"},"6:553":{"crate_id":6,"path":["libc","unix","ipv6_mreq"],"kind":"struct"},"14:6807":{"crate_id":14,"path":["gimli","read","op","Operation"],"kind":"enum"},"5:4107":{"crate_id":5,"path":["alloc","collections","vec_deque","{{impl}}","truncate","Dropper"],"kind":"struct"},"15:12408":{"crate_id":15,"path":["object","macho","DylibModule64"],"kind":"struct"},"2:2606":{"crate_id":2,"path":["core","borrow","BorrowMut"],"kind":"trait"},"2:46007":{"crate_id":2,"path":["core","str","UnsafeBytesToStr"],"kind":"struct"},"1:10960":{"crate_id":1,"path":["std","os","unix","net","ancillary","SocketCred"],"kind":"struct"},"9:1783":{"crate_id":9,"path":["hashbrown","set","Difference"],"kind":"struct"},"2:46145":{"crate_id":2,"path":["core","future","ready","Ready"],"kind":"struct"},"6:4175":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_fprog"],"kind":"struct"},"5:2912":{"crate_id":5,"path":["alloc","collections","btree","set","SymmetricDifference"],"kind":"struct"},"1:11555":{"crate_id":1,"path":["std","process","ExitStatus"],"kind":"struct"},"6:4154":{"crate_id":6,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_j1939"],"kind":"struct"},"5:7493":{"crate_id":5,"path":["alloc","collections","btree","set","IntersectionInner"],"kind":"enum"},"17:157":{"crate_id":17,"path":["miniz_oxide","deflate","core","CompressorOxide"],"kind":"struct"},"18:46":{"crate_id":18,"path":["adler","algo","U32X4"],"kind":"struct"},"2:8363":{"crate_id":2,"path":["rustc_error_codes","Target"],"kind":"typedef"},"6:6093":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","ucontext_t"],"kind":"struct"},"9:1421":{"crate_id":9,"path":["hashbrown","rustc_entry","RustcOccupiedEntry"],"kind":"struct"},"2:45267":{"crate_id":2,"path":["core","str","iter","Split"],"kind":"struct"},"2:10390":{"crate_id":2,"path":["core","slice","iter","SplitN"],"kind":"struct"},"2:3242":{"crate_id":2,"path":["core","ops","function","Fn"],"kind":"trait"},"5:2898":{"crate_id":5,"path":["alloc","collections","btree","set","Iter"],"kind":"struct"},"1:8530":{"crate_id":1,"path":["std","sync","once","WaiterQueue"],"kind":"struct"},"15:10061":{"crate_id":15,"path":["object","read","coff","file","CoffCommon"],"kind":"struct"},"2:3215":{"crate_id":2,"path":["core","ops","deref","Deref"],"kind":"trait"},"2:3106":{"crate_id":2,"path":["core","ops","arith","SubAssign"],"kind":"trait"},"15:13453":{"crate_id":15,"path":["object","pe","ImageTlsDirectory64"],"kind":"struct"},"1:15260":{"crate_id":1,"path":["std","char"],"kind":"primitive"},"2:7426":{"crate_id":2,"path":["core","iter","traits","collect","IntoIterator"],"kind":"trait"},"6:5082":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","rtentry"],"kind":"struct"},"6:5161":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","Elf64_Chdr"],"kind":"struct"},"5:1282":{"crate_id":5,"path":["alloc","collections","btree","map","Iter"],"kind":"struct"},"15:10071":{"crate_id":15,"path":["object","read","coff","file","CoffFile"],"kind":"struct"},"2:45521":{"crate_id":2,"path":["core","str","iter","Lines"],"kind":"struct"},"16:169":{"crate_id":16,"path":["memchr","memchr","iter","Memchr3"],"kind":"struct"},"1:11907":{"crate_id":1,"path":["std","sys","unix","args","Args"],"kind":"struct"},"1:10909":{"crate_id":1,"path":["std","net","tcp","IntoIncoming"],"kind":"struct"},"6:4017":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Shdr"],"kind":"struct"},"2:45807":{"crate_id":2,"path":["rustc_error_codes","Searcher"],"kind":"typedef"},"15:0":{"crate_id":15,"path":["object"],"kind":"module"},"1:5231":{"crate_id":1,"path":["std","net","udp","UdpSocket"],"kind":"struct"},"15:12795":{"crate_id":15,"path":["object","macho","ScatteredRelocationInfo"],"kind":"struct"},"1:15269":{"crate_id":1,"path":["std","i8"],"kind":"primitive"},"1:10503":{"crate_id":1,"path":["std","fs","OpenOptions"],"kind":"struct"},"2:4414":{"crate_id":2,"path":["core","cell","UnsafeCell"],"kind":"struct"},"14:5314":{"crate_id":14,"path":["gimli","endianity","LittleEndian"],"kind":"struct"},"15:11962":{"crate_id":15,"path":["object","macho","FatHeader"],"kind":"struct"},"5:743":{"crate_id":5,"path":["alloc","collections","binary_heap","Hole"],"kind":"struct"},"1:11593":{"crate_id":1,"path":["std","sync","mpsc","blocking","SignalToken"],"kind":"struct"},"1:8143":{"crate_id":1,"path":["std","sync","mpsc","Receiver"],"kind":"struct"},"14:6176":{"crate_id":14,"path":["gimli","read","aranges","ArangeHeader"],"kind":"struct"},"2:11696":{"crate_id":2,"path":["core","str","iter","MatchIndicesInternal"],"kind":"struct"},"2:4709":{"crate_id":2,"path":["rustc_error_codes","Target"],"kind":"typedef"},"17:996":{"crate_id":17,"path":["miniz_oxide","MZStatus"],"kind":"enum"},"1:12906":{"crate_id":1,"path":["std","sys","unix","net","Socket"],"kind":"struct"},"1:4380":{"crate_id":1,"path":["rustc_error_codes","Target"],"kind":"typedef"},"2:1995":{"crate_id":2,"path":["core","mem","drop"],"kind":"function"},"16:811":{"crate_id":16,"path":["memchr","memmem","Finder"],"kind":"struct"},"15:13942":{"crate_id":15,"path":["object","pe","ImageSeparateDebugHeader"],"kind":"struct"},"15:9210":{"crate_id":15,"path":["object","common","SymbolFlags"],"kind":"enum"},"2:46003":{"crate_id":2,"path":["core","str","BytesIsNotEmpty"],"kind":"struct"},"2:21401":{"crate_id":2,"path":["core","num","dec2flt","ParseFloatError"],"kind":"struct"},"2:11747":{"crate_id":2,"path":["core","str","iter","SplitInclusive"],"kind":"struct"},"2:10238":{"crate_id":2,"path":["core","slice","iter","SplitMut"],"kind":"struct"},"15:9476":{"crate_id":15,"path":["object","endian","I64Bytes"],"kind":"struct"},"1:1428":{"crate_id":1,"path":["std","collections","hash","map","OccupiedError"],"kind":"struct"},"1:4066":{"crate_id":1,"path":["std","io","stdio","StderrRaw"],"kind":"struct"},"17:1020":{"crate_id":17,"path":["miniz_oxide","MZError"],"kind":"enum"},"2:9363":{"crate_id":2,"path":["core","fmt","Octal"],"kind":"trait"},"1:10869":{"crate_id":1,"path":["std","net","ip","{{impl}}","fmt","Span"],"kind":"struct"},"15:12568":{"crate_id":15,"path":["object","macho","VersionMinCommand"],"kind":"struct"},"2:45791":{"crate_id":2,"path":["core","str","pattern","CharPredicateSearcher"],"kind":"struct"},"2:9606":{"crate_id":2,"path":["core","hash","BuildHasherDefault"],"kind":"struct"},"14:6021":{"crate_id":14,"path":["gimli","read","dwarf","RangeIterInner"],"kind":"enum"},"1:11615":{"crate_id":1,"path":["std","sync","mpsc","cache_aligned","CacheAligned"],"kind":"struct"},"15:11482":{"crate_id":15,"path":["object","elf","Ident"],"kind":"struct"},"14:5927":{"crate_id":14,"path":["gimli","read","cfi","CallFrameInstructionIter"],"kind":"struct"},"6:3708":{"crate_id":6,"path":["libc","unix","linux_like","linux","signalfd_siginfo"],"kind":"struct"},"14:547":{"crate_id":14,"path":["gimli","read","cfi","RegisterRuleMap"],"kind":"struct"},"6:1714":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_storage"],"kind":"struct"},"9:1609":{"crate_id":9,"path":["hashbrown","set","HashSet"],"kind":"struct"},"2:9305":{"crate_id":2,"path":["core","fmt","Write"],"kind":"trait"},"9:838":{"crate_id":9,"path":["hashbrown","map","RawEntryBuilderMut"],"kind":"struct"},"15:9886":{"crate_id":15,"path":["object","read","any","SymbolIterator"],"kind":"struct"},"6:3756":{"crate_id":6,"path":["libc","unix","linux_like","linux","cpu_set_t"],"kind":"struct"},"14:4614":{"crate_id":14,"path":["gimli","constants","DwLang"],"kind":"struct"},"14:7477":{"crate_id":14,"path":["gimli","read","unit","UnitType"],"kind":"enum"},"2:33743":{"crate_id":2,"path":["core","cmp","Reverse"],"kind":"struct"},"14:6238":{"crate_id":14,"path":["gimli","read","line","DebugLine"],"kind":"struct"},"15:13272":{"crate_id":15,"path":["object","pe","ImageSymbolBytes"],"kind":"struct"},"2:45531":{"crate_id":2,"path":["core","str","iter","LinesAny"],"kind":"struct"},"1:14766":{"crate_id":1,"path":["std","backtrace_rs","backtrace","libunwind","Frame"],"kind":"enum"},"1:7802":{"crate_id":1,"path":["std","sync","mpsc","shared","Packet"],"kind":"struct"},"2:49178":{"crate_id":2,"path":["core","core_arch","simd","f64x8"],"kind":"struct"},"2:6797":{"crate_id":2,"path":["core","iter","adapters","zip","TrustedRandomAccessNoCoerce"],"kind":"trait"},"2:45237":{"crate_id":2,"path":["core","str","iter","Chars"],"kind":"struct"},"1:1419":{"crate_id":1,"path":["std","collections","hash","map","VacantEntry"],"kind":"struct"},"1:7601":{"crate_id":1,"path":["std","sync","mpsc","blocking","Inner"],"kind":"struct"},"16:660":{"crate_id":16,"path":["memchr","memmem","prefilter","PrefilterState"],"kind":"struct"},"6:1678":{"crate_id":6,"path":["libc","unix","linux_like","arpreq_old"],"kind":"struct"},"6:6610":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_cond_t"],"kind":"struct"},"1:13051":{"crate_id":1,"path":["std","sys","unix","os","SplitPaths"],"kind":"struct"},"2:3300":{"crate_id":2,"path":["core","ops","index","Index"],"kind":"trait"},"5:3696":{"crate_id":5,"path":["alloc","collections","vec_deque","drain","Drain"],"kind":"struct"},"6:3682":{"crate_id":6,"path":["libc","unix","linux_like","linux","spwd"],"kind":"struct"},"14:3939":{"crate_id":14,"path":["gimli","constants","DwTag"],"kind":"struct"},"2:7938":{"crate_id":2,"path":["core","lazy","OnceCell"],"kind":"struct"},"1:15271":{"crate_id":1,"path":["std","i32"],"kind":"primitive"},"2:10104":{"crate_id":2,"path":["rustc_error_codes","Item"],"kind":"typedef"},"6:4291":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_txtime"],"kind":"struct"},"1:14075":{"crate_id":1,"path":["std","sys","unix","kernel_copy","SpliceMode"],"kind":"enum"},"5:4054":{"crate_id":5,"path":["alloc","collections","vec_deque","{{impl}}","drop","Dropper"],"kind":"struct"},"15:13054":{"crate_id":15,"path":["object","pe","ImageDataDirectory"],"kind":"struct"},"2:42151":{"crate_id":2,"path":["core","array","TryFromSliceError"],"kind":"struct"},"1:13489":{"crate_id":1,"path":["std","sys","unix","process","process_common","CommandArgs"],"kind":"struct"},"16:774":{"crate_id":16,"path":["memchr","memmem","x86","avx","nostd","Forward"],"kind":"struct"},"2:11894":{"crate_id":2,"path":["core","str","traits","FromStr"],"kind":"trait"},"2:42083":{"crate_id":2,"path":["core","ops","range","Bound"],"kind":"enum"},"11:56":{"crate_id":11,"path":["rustc_demangle","v0","Ident"],"kind":"struct"},"15:13041":{"crate_id":15,"path":["object","pe","ImageFileHeader"],"kind":"struct"},"6:3935":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Ehdr"],"kind":"struct"},"6:3652":{"crate_id":6,"path":["libc","unix","linux_like","linux","rlimit64"],"kind":"struct"},"3:0":{"crate_id":3,"path":["compiler_builtins"],"kind":"module"},"2:43900":{"crate_id":2,"path":["core","sync","atomic","AtomicU64"],"kind":"struct"},"2:45073":{"crate_id":2,"path":["core","slice","iter","Windows"],"kind":"struct"},"2:2702":{"crate_id":2,"path":["core","cmp","PartialOrd"],"kind":"trait"},"15:12182":{"crate_id":15,"path":["object","macho","DylibCommand"],"kind":"struct"},"15:13933":{"crate_id":15,"path":["object","pe","ImageFunctionEntry64"],"kind":"struct"},"15:12287":{"crate_id":15,"path":["object","macho","RoutinesCommand32"],"kind":"struct"},"16:849":{"crate_id":16,"path":["memchr","memmem","NeedleInfo"],"kind":"struct"},"6:589":{"crate_id":6,"path":["libc","unix","linger"],"kind":"struct"},"2:43597":{"crate_id":2,"path":["core","result","IterMut"],"kind":"struct"},"5:6261":{"crate_id":5,"path":["alloc","task","Wake"],"kind":"trait"},"9:748":{"crate_id":9,"path":["hashbrown","map","Keys"],"kind":"struct"},"1:6603":{"crate_id":1,"path":["std","os","fd","raw","FromRawFd"],"kind":"trait"},"2:41993":{"crate_id":2,"path":["core","ops","range","RangeFrom"],"kind":"struct"},"15:13924":{"crate_id":15,"path":["object","pe","ImageFunctionEntry"],"kind":"struct"},"6:3923":{"crate_id":6,"path":["libc","unix","linux_like","linux","dl_phdr_info"],"kind":"struct"},"2:42428":{"crate_id":2,"path":["core","char","EscapeDefaultState"],"kind":"enum"},"14:7884":{"crate_id":14,"path":["gimli","read","unit","DebugTypesUnitHeadersIter"],"kind":"struct"},"14:4535":{"crate_id":14,"path":["gimli","constants","DwVirtuality"],"kind":"struct"},"1:10955":{"crate_id":1,"path":["std","os","unix","net","addr","SocketAddr"],"kind":"struct"},"2:4402":{"crate_id":2,"path":["rustc_error_codes","Target"],"kind":"typedef"},"14:6219":{"crate_id":14,"path":["gimli","read","aranges","ArangeEntry"],"kind":"struct"},"6:5072":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","nl_mmap_hdr"],"kind":"struct"},"15:12712":{"crate_id":15,"path":["object","macho","DataInCodeEntry"],"kind":"struct"},"2:45699":{"crate_id":2,"path":["core","str","pattern","CharArraySearcher"],"kind":"struct"},"2:47290":{"crate_id":2,"path":["core","core_arch","simd","u16x8"],"kind":"struct"},"1:7472":{"crate_id":1,"path":["std","process","exit"],"kind":"function"},"15:10448":{"crate_id":15,"path":["object","read","elf","note","NoteIterator"],"kind":"struct"},"1:11648":{"crate_id":1,"path":["std","sync","mpsc","Iter"],"kind":"struct"},"5:5377":{"crate_id":5,"path":["rustc_error_codes","Output"],"kind":"typedef"},"15:12262":{"crate_id":15,"path":["object","macho","DylinkerCommand"],"kind":"struct"},"2:3444":{"crate_id":2,"path":["core","ops","try_trait","Try"],"kind":"trait"},"14:2773":{"crate_id":14,"path":["gimli","common","LineEncoding"],"kind":"struct"},"15:10599":{"crate_id":15,"path":["object","read","macho","file","MachOComdatIterator"],"kind":"struct"},"2:0":{"crate_id":2,"path":["core"],"kind":"module"},"1:11148":{"crate_id":1,"path":["std","path","Component"],"kind":"enum"},"15:11653":{"crate_id":15,"path":["object","elf","Rel64"],"kind":"struct"},"9:447":{"crate_id":9,"path":["hashbrown","raw","RawIterHash"],"kind":"struct"},"15:13240":{"crate_id":15,"path":["object","pe","ImageSectionHeader"],"kind":"struct"},"5:537":{"crate_id":5,"path":["alloc","borrow","ToOwned"],"kind":"trait"},"17:603":{"crate_id":17,"path":["miniz_oxide","inflate","stream","InflateState"],"kind":"struct"},"2:47032":{"crate_id":2,"path":["core","core_arch","simd","u32x2"],"kind":"struct"},"1:1941":{"crate_id":1,"path":["std","collections","hash","set","Drain"],"kind":"struct"},"5:7469":{"crate_id":5,"path":["alloc","collections","btree","set","Range"],"kind":"struct"},"2:49316":{"crate_id":2,"path":["core","core_arch","x86","__m128bh"],"kind":"struct"},"15:10304":{"crate_id":15,"path":["object","read","elf","section","ElfSectionIterator"],"kind":"struct"},"12:116":{"crate_id":12,"path":["std_detect","detect","arch","Feature"],"kind":"enum"},"9:1516":{"crate_id":9,"path":["hashbrown","scopeguard","ScopeGuard"],"kind":"struct"},"6:4131":{"crate_id":6,"path":["libc","unix","linux_like","linux","regmatch_t"],"kind":"struct"},"15:10926":{"crate_id":15,"path":["object","read","pe","file","PeComdatIterator"],"kind":"struct"},"1:14392":{"crate_id":1,"path":["std","sys_common","process","CommandEnvs"],"kind":"struct"},"2:10199":{"crate_id":2,"path":["core","slice","iter","SplitInclusive"],"kind":"struct"},"2:12033":{"crate_id":2,"path":["core","str","pattern","MultiCharEqPattern"],"kind":"struct"},"14:7119":{"crate_id":14,"path":["gimli","read","op","Expression"],"kind":"struct"},"1:14016":{"crate_id":1,"path":["std","sys","unix","fs","OpenOptions"],"kind":"struct"},"5:1191":{"crate_id":5,"path":["alloc","collections","btree","map","entry","OccupiedError"],"kind":"struct"},"15:13402":{"crate_id":15,"path":["object","pe","ImageArchiveMemberHeader"],"kind":"struct"},"9:845":{"crate_id":9,"path":["hashbrown","map","RawEntryMut"],"kind":"enum"},"2:7422":{"crate_id":2,"path":["core","iter","traits","collect","FromIterator"],"kind":"trait"},"2:44465":{"crate_id":2,"path":["core","fmt","Arguments"],"kind":"struct"},"14:6620":{"crate_id":14,"path":["gimli","read","loclists","LocListsFormat"],"kind":"enum"},"6:4205":{"crate_id":6,"path":["libc","unix","linux_like","linux","nlattr"],"kind":"struct"},"14:6136":{"crate_id":14,"path":["gimli","read","abbrev","AttributeSpecification"],"kind":"struct"},"16:782":{"crate_id":16,"path":["memchr","memmem","x86","sse","Forward"],"kind":"struct"},"6:4975":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__exit_status"],"kind":"struct"},"1:15270":{"crate_id":1,"path":["std","i16"],"kind":"primitive"},"1:14245":{"crate_id":1,"path":["std","sys","unix","process","process_inner","{{impl}}","posix_spawn","PosixSpawnattr"],"kind":"struct"},"1:14742":{"crate_id":1,"path":["std","panicking","Hook"],"kind":"enum"},"2:3493":{"crate_id":2,"path":["core","ops","unsize","DispatchFromDyn"],"kind":"trait"},"2:2306":{"crate_id":2,"path":["core","ptr","unique","Unique"],"kind":"struct"},"15:10844":{"crate_id":15,"path":["object","read","macho","symbol","SymbolTable"],"kind":"struct"},"1:5476":{"crate_id":1,"path":["std","os","unix","fs","OpenOptionsExt"],"kind":"trait"},"1:3172":{"crate_id":1,"path":["std","fs","canonicalize"],"kind":"function"},"1:15259":{"crate_id":1,"path":["std","never"],"kind":"primitive"},"14:3064":{"crate_id":14,"path":["gimli","common","DebugMacinfoOffset"],"kind":"struct"},"5:5206":{"crate_id":5,"path":["alloc","slice","merge","MergeHole"],"kind":"struct"},"2:2095":{"crate_id":2,"path":["core","ptr","metadata","DynMetadata"],"kind":"struct"},"15:9528":{"crate_id":15,"path":["object","read","util","Bytes"],"kind":"struct"},"2:42465":{"crate_id":2,"path":["core","char","CaseMappingIter"],"kind":"enum"},"2:21":{"crate_id":2,"path":["core","format_args"],"kind":"macro"},"14:7406":{"crate_id":14,"path":["gimli","read","str","DebugLineStr"],"kind":"struct"},"15:13154":{"crate_id":15,"path":["object","pe","ImageNtHeaders64"],"kind":"struct"},"16:152":{"crate_id":16,"path":["memchr","memchr","iter","Memchr2"],"kind":"struct"},"2:21545":{"crate_id":2,"path":["core","num","error","ParseIntError"],"kind":"struct"},"1:15263":{"crate_id":1,"path":["std","array"],"kind":"primitive"},"5:4763":{"crate_id":5,"path":["rustc_error_codes","Target"],"kind":"typedef"},"5:1325":{"crate_id":5,"path":["alloc","collections","btree","map","Values"],"kind":"struct"},"1:11542":{"crate_id":1,"path":["std","process","Output"],"kind":"struct"},"15:11434":{"crate_id":15,"path":["object","elf","FileHeader32"],"kind":"struct"},"1:14006":{"crate_id":1,"path":["std","sys","unix","fs","FileAttr"],"kind":"struct"},"6:4981":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__timeval"],"kind":"struct"},"9:761":{"crate_id":9,"path":["hashbrown","map","Values"],"kind":"struct"},"1:7090":{"crate_id":1,"path":["rustc_error_codes","Target"],"kind":"typedef"},"15:12431":{"crate_id":15,"path":["object","macho","DylibReference"],"kind":"struct"},"2:44138":{"crate_id":2,"path":["core","fmt","num","LowerHex"],"kind":"struct"},"15:10788":{"crate_id":15,"path":["object","read","macho","segment","MachOSegmentIterator"],"kind":"struct"},"15:12073":{"crate_id":15,"path":["object","macho","SegmentCommand64"],"kind":"struct"},"1:1215":{"crate_id":1,"path":["std","collections","hash","map","IntoIter"],"kind":"struct"},"15:9186":{"crate_id":15,"path":["object","common","SectionFlags"],"kind":"enum"},"14:4955":{"crate_id":14,"path":["gimli","constants","DwLnct"],"kind":"struct"},"0:8":{"crate_id":0,"path":["rustc_error_codes","error_codes","DIAGNOSTICS"],"kind":"static"},"2:10157":{"crate_id":2,"path":["core","slice","iter","Split"],"kind":"struct"},"2:42116":{"crate_id":2,"path":["core","any","TypeId"],"kind":"struct"},"15:11337":{"crate_id":15,"path":["object","read","CompressionFormat"],"kind":"enum"},"2:42514":{"crate_id":2,"path":["core","iter","adapters","chain","Chain"],"kind":"struct"},"2:10105":{"crate_id":2,"path":["rustc_error_codes","IntoIter"],"kind":"typedef"},"2:43972":{"crate_id":2,"path":["core","sync","atomic","AtomicUsize"],"kind":"struct"},"1:8359":{"crate_id":1,"path":["std","sync","condvar","Condvar"],"kind":"struct"},"2:47471":{"crate_id":2,"path":["core","core_arch","simd","i32x4"],"kind":"struct"},"15:10827":{"crate_id":15,"path":["object","read","macho","section","MachOSectionInternal"],"kind":"struct"},"15:299":{"crate_id":15,"path":["object","read","util","DebugLen"],"kind":"struct"},"1:15274":{"crate_id":1,"path":["std","u8"],"kind":"primitive"},"2:41952":{"crate_id":2,"path":["core","ops","range","RangeFull"],"kind":"struct"},"14:5717":{"crate_id":14,"path":["gimli","read","cfi","UnwindContext"],"kind":"struct"},"2:45559":{"crate_id":2,"path":["core","str","iter","EncodeUtf16"],"kind":"struct"},"15:13348":{"crate_id":15,"path":["object","pe","ImageAuxSymbolWeak"],"kind":"struct"},"14:7571":{"crate_id":14,"path":["gimli","read","unit","AttributeValue"],"kind":"enum"},"5:5721":{"crate_id":5,"path":["alloc","string","ToString"],"kind":"trait"},"14:7250":{"crate_id":14,"path":["gimli","read","rnglists","DebugRngLists"],"kind":"struct"},"1:12291":{"crate_id":1,"path":["std","sys","unix","fs","Dir"],"kind":"struct"},"2:45225":{"crate_id":2,"path":["core","str","error","ParseBoolError"],"kind":"struct"},"14:7295":{"crate_id":14,"path":["gimli","read","rnglists","RawRngListIter"],"kind":"struct"},"16:790":{"crate_id":16,"path":["memchr","memmem","FindIter"],"kind":"struct"},"1:14483":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8CodePoints"],"kind":"struct"},"2:43545":{"crate_id":2,"path":["core","result","Result"],"kind":"enum"},"14:5736":{"crate_id":14,"path":["gimli","read","cfi","UnwindTable"],"kind":"struct"},"6:3695":{"crate_id":6,"path":["libc","unix","linux_like","linux","dqblk"],"kind":"struct"},"1:5599":{"crate_id":1,"path":["std","os","unix","net","addr","AsciiEscaped"],"kind":"struct"},"14:6718":{"crate_id":14,"path":["gimli","read","lookup","DebugLookup"],"kind":"struct"},"2:3009":{"crate_id":2,"path":["core","marker","Sized"],"kind":"trait"},"2:11636":{"crate_id":2,"path":["core","str","iter","SplitInternal"],"kind":"struct"},"2:44672":{"crate_id":2,"path":["core","hash","sip","Sip13Rounds"],"kind":"struct"},"2:4260":{"crate_id":2,"path":["core","cell","RefCell"],"kind":"struct"},"6:1518":{"crate_id":6,"path":["libc","unix","linux_like","ip_mreq_source"],"kind":"struct"},"1:14029":{"crate_id":1,"path":["std","sys","unix","fs","FilePermissions"],"kind":"struct"},"14:5632":{"crate_id":14,"path":["gimli","read","cfi","PartialFrameDescriptionEntry"],"kind":"struct"},"2:3123":{"crate_id":2,"path":["core","ops","bit","Not"],"kind":"trait"},"2:47083":{"crate_id":2,"path":["core","core_arch","simd","i8x8"],"kind":"struct"},"5:840":{"crate_id":5,"path":["alloc","collections","binary_heap","{{impl}}","drop","DropGuard"],"kind":"struct"},"2:42654":{"crate_id":2,"path":["core","iter","adapters","rev","Rev"],"kind":"struct"},"2:42545":{"crate_id":2,"path":["core","iter","adapters","cycle","Cycle"],"kind":"struct"},"5:7515":{"crate_id":5,"path":["alloc","collections","vec_deque","into_iter","IntoIter"],"kind":"struct"},"14:6591":{"crate_id":14,"path":["gimli","read","loclists","DebugLocLists"],"kind":"struct"},"1:11004":{"crate_id":1,"path":["std","os","linux","process","PidFd"],"kind":"struct"},"1:11131":{"crate_id":1,"path":["std","path","PrefixComponent"],"kind":"struct"},"2:49053":{"crate_id":2,"path":["core","core_arch","simd","f32x16"],"kind":"struct"},"2:8891":{"crate_id":2,"path":["core","sync","atomic","AtomicPtr"],"kind":"struct"},"1:12288":{"crate_id":1,"path":["std","sys","unix","fs","ReadDir"],"kind":"struct"},"6:5786":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","sigaction"],"kind":"struct"},"1:4346":{"crate_id":1,"path":["std","io","Read"],"kind":"trait"},"1:11608":{"crate_id":1,"path":["std","sync","mpsc","sync","Failure"],"kind":"enum"},"2:45253":{"crate_id":2,"path":["core","str","iter","Bytes"],"kind":"struct"},"1:11191":{"crate_id":1,"path":["std","path","Components"],"kind":"struct"},"2:42716":{"crate_id":2,"path":["core","iter","adapters","take_while","TakeWhile"],"kind":"struct"},"1:14059":{"crate_id":1,"path":["std","sys","unix","fs","DirBuilder"],"kind":"struct"},"5:5107":{"crate_id":5,"path":["alloc","slice","hack","{{impl}}","to_vec","DropGuard"],"kind":"struct"},"2:3010":{"crate_id":2,"path":["core","marker","Unsize"],"kind":"trait"},"15:11932":{"crate_id":15,"path":["object","macho","DyldCacheMappingInfo"],"kind":"struct"},"6:5828":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","siginfo_t"],"kind":"struct"},"2:2982":{"crate_id":2,"path":["core","default","Default"],"kind":"trait"},"15:9005":{"crate_id":15,"path":["object","common","ComdatKind"],"kind":"enum"},"15:9574":{"crate_id":15,"path":["object","read","util","StringTable"],"kind":"struct"},"15:9849":{"crate_id":15,"path":["object","read","any","SymbolTableInternal"],"kind":"enum"},"16:694":{"crate_id":16,"path":["memchr","memmem","rarebytes","RareNeedleBytes"],"kind":"struct"},"1:10804":{"crate_id":1,"path":["std","net","addr","SocketAddrV4"],"kind":"struct"},"1:11201":{"crate_id":1,"path":["std","path","Iter"],"kind":"struct"},"2:4395":{"crate_id":2,"path":["core","cell","RefMut"],"kind":"struct"},"1:5701":{"crate_id":1,"path":["std","os","unix","net","ancillary","ScmCredentials"],"kind":"struct"},"5:1834":{"crate_id":5,"path":["alloc","collections","btree","mem","replace","PanicGuard"],"kind":"struct"},"2:45120":{"crate_id":2,"path":["core","slice","iter","ArrayWindows"],"kind":"struct"},"1:14328":{"crate_id":1,"path":["std","sys","unix","time","Timespec"],"kind":"struct"},"6:5794":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statfs"],"kind":"struct"},"2:42597":{"crate_id":2,"path":["core","iter","adapters","fuse","Fuse"],"kind":"struct"},"1:13991":{"crate_id":1,"path":["std","sys","unix","fd","FileDesc"],"kind":"struct"},"6:5213":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","utmpx"],"kind":"struct"},"1:2176":{"crate_id":1,"path":["std","env","VarsOs"],"kind":"struct"},"15:10962":{"crate_id":15,"path":["object","read","pe","section","PeSegmentIterator"],"kind":"struct"},"11:216":{"crate_id":11,"path":["rustc_demangle","SizeLimitedFmtAdapter"],"kind":"struct"},"2:48737":{"crate_id":2,"path":["core","core_arch","simd","i16x32"],"kind":"struct"},"2:42663":{"crate_id":2,"path":["core","iter","adapters","scan","Scan"],"kind":"struct"},"15:9332":{"crate_id":15,"path":["object","endian","U32Bytes"],"kind":"struct"},"15:12467":{"crate_id":15,"path":["object","macho","PrebindCksumCommand"],"kind":"struct"},"9:1790":{"crate_id":9,"path":["hashbrown","set","SymmetricDifference"],"kind":"struct"},"2:1948":{"crate_id":2,"path":["core","mem","maybe_uninit","{{impl}}","write_slice_cloned","Guard"],"kind":"struct"},"5:196":{"crate_id":5,"path":["alloc","boxed","Box"],"kind":"struct"},"2:42931":{"crate_id":2,"path":["core","iter","sources","repeat_with","RepeatWith"],"kind":"struct"},"2:47195":{"crate_id":2,"path":["core","core_arch","simd","f64x1"],"kind":"struct"},"2:42897":{"crate_id":2,"path":["core","iter","sources","from_fn","FromFn"],"kind":"struct"},"1:6605":{"crate_id":1,"path":["std","os","fd","raw","IntoRawFd"],"kind":"trait"},"15:11822":{"crate_id":15,"path":["object","elf","NoteHeader64"],"kind":"struct"},"1:10840":{"crate_id":1,"path":["std","net","ip","Ipv6MulticastScope"],"kind":"enum"},"5:546":{"crate_id":5,"path":["alloc","borrow","Cow"],"kind":"enum"},"1:10761":{"crate_id":1,"path":["std","io","Bytes"],"kind":"struct"},"14:2754":{"crate_id":14,"path":["gimli","common","Encoding"],"kind":"struct"},"14:7195":{"crate_id":14,"path":["gimli","read","pubnames","PubNamesEntryIter"],"kind":"struct"},"2:42626":{"crate_id":2,"path":["core","iter","adapters","map","Map"],"kind":"struct"},"6:595":{"crate_id":6,"path":["libc","unix","sigval"],"kind":"struct"},"1:2355":{"crate_id":1,"path":["std","error","{{impl}}","from","StringError"],"kind":"struct"},"2:49301":{"crate_id":2,"path":["core","core_arch","x86","__m512d"],"kind":"struct"},"15:12247":{"crate_id":15,"path":["object","macho","PreboundDylibCommand"],"kind":"struct"},"15:10435":{"crate_id":15,"path":["object","read","elf","comdat","ElfComdatSectionIterator"],"kind":"struct"},"1:8079":{"crate_id":1,"path":["std","sync","mpsc","sync","Node"],"kind":"struct"},"2:2901":{"crate_id":2,"path":["core","convert","AsRef"],"kind":"trait"},"2:8436":{"crate_id":2,"path":["core","panicking","assert_matches_failed","Pattern"],"kind":"struct"},"6:527":{"crate_id":6,"path":["libc","unix","rlimit"],"kind":"struct"},"9:1764":{"crate_id":9,"path":["hashbrown","set","Drain"],"kind":"struct"},"19:0":{"crate_id":19,"path":["panic_unwind"],"kind":"module"},"2:45285":{"crate_id":2,"path":["core","str","iter","RSplit"],"kind":"struct"},"2:49100":{"crate_id":2,"path":["core","core_arch","simd","i64x8"],"kind":"struct"},"13:269":{"crate_id":13,"path":["addr2line","RangeAttributes"],"kind":"struct"},"15:11604":{"crate_id":15,"path":["object","elf","Syminfo32"],"kind":"struct"},"6:4957":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","aiocb"],"kind":"struct"},"2:47961":{"crate_id":2,"path":["core","core_arch","simd","u64x4"],"kind":"struct"},"14:3320":{"crate_id":14,"path":["gimli","common","DebugTypeSignature"],"kind":"struct"},"1:915":{"crate_id":1,"path":["std","backtrace","Backtrace"],"kind":"struct"},"2:2839":{"crate_id":2,"path":["core","convert","num","FloatToInt"],"kind":"trait"},"1:7863":{"crate_id":1,"path":["std","sync","mpsc","spsc_queue","Queue"],"kind":"struct"},"15:10317":{"crate_id":15,"path":["object","read","elf","section","ElfSection"],"kind":"struct"},"2:3102":{"crate_id":2,"path":["core","ops","arith","AddAssign"],"kind":"trait"},"14:3091":{"crate_id":14,"path":["gimli","common","DebugMacroOffset"],"kind":"struct"},"1:2174":{"crate_id":1,"path":["std","env","Vars"],"kind":"struct"},"2:21360":{"crate_id":2,"path":["core","num","dec2flt","decimal","Decimal"],"kind":"struct"},"15:13192":{"crate_id":15,"path":["object","pe","AnonObjectHeader"],"kind":"struct"},"14:3241":{"crate_id":14,"path":["gimli","common","DebugStrOffsetsBase"],"kind":"struct"},"5:2905":{"crate_id":5,"path":["alloc","collections","btree","set","Difference"],"kind":"struct"},"6:4281":{"crate_id":6,"path":["libc","unix","linux_like","linux","mq_attr"],"kind":"struct"},"6:5187":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","sifields_sigchld"],"kind":"struct"},"2:21477":{"crate_id":2,"path":["core","num","flt2dec","Sign"],"kind":"enum"},"2:10934":{"crate_id":2,"path":["core","slice","iter","GroupByMut"],"kind":"struct"},"2:45200":{"crate_id":2,"path":["core","slice","iter","RChunksExactMut"],"kind":"struct"},"15:11406":{"crate_id":15,"path":["object","archive","Header"],"kind":"struct"},"19:117":{"crate_id":19,"path":["panic_unwind","dwarf","eh","EHContext"],"kind":"struct"},"11:244":{"crate_id":11,"path":["rustc_demangle","TryDemangleError"],"kind":"struct"},"2:49331":{"crate_id":2,"path":["core","core_arch","x86","__m256bh"],"kind":"struct"},"9:159":{"crate_id":9,"path":["hashbrown","raw","Bucket"],"kind":"struct"},"15:14000":{"crate_id":15,"path":["object","pe","ImageCor20Header"],"kind":"struct"},"2:46828":{"crate_id":2,"path":["core","core_arch","simd","u8x2"],"kind":"struct"},"6:6497":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","align","sem_t"],"kind":"struct"},"14:7804":{"crate_id":14,"path":["gimli","read","unit","EntriesCursor"],"kind":"struct"},"15:10353":{"crate_id":15,"path":["object","read","elf","symbol","ElfSymbolTable"],"kind":"struct"},"15:3743":{"crate_id":15,"path":["object","read","macho","section","MachOSectionIterator"],"kind":"struct"},"1:15267":{"crate_id":1,"path":["std","f32"],"kind":"primitive"},"6:6628":{"crate_id":6,"path":["libc","unix","linux_like","linux","can_frame"],"kind":"struct"},"15:11277":{"crate_id":15,"path":["object","read","CodeView"],"kind":"struct"},"2:28777":{"crate_id":2,"path":["core","mem","manually_drop","ManuallyDrop"],"kind":"struct"},"15:13609":{"crate_id":15,"path":["object","pe","ImageDynamicRelocation64V2"],"kind":"struct"},"14:7264":{"crate_id":14,"path":["gimli","read","rnglists","RangeLists"],"kind":"struct"},"2:45317":{"crate_id":2,"path":["core","str","iter","SplitTerminator"],"kind":"struct"},"14:4890":{"crate_id":14,"path":["gimli","constants","DwLns"],"kind":"struct"},"5:1303":{"crate_id":5,"path":["alloc","collections","btree","map","IntoIter"],"kind":"struct"},"15:13620":{"crate_id":15,"path":["object","pe","ImagePrologueDynamicRelocationHeader"],"kind":"struct"},"2:12716":{"crate_id":2,"path":["core","future","pending","Pending"],"kind":"struct"},"2:3076":{"crate_id":2,"path":["core","ops","arith","Sub"],"kind":"trait"},"14:4922":{"crate_id":14,"path":["gimli","constants","DwLne"],"kind":"struct"},"15:10052":{"crate_id":15,"path":["object","read","archive","ArchiveMember"],"kind":"struct"},"1:8979":{"crate_id":1,"path":["rustc_error_codes","Target"],"kind":"typedef"},"2:21977":{"crate_id":2,"path":["core","num","nonzero","NonZeroUsize"],"kind":"struct"},"5:7103":{"crate_id":5,"path":["alloc","vec","{{impl}}","retain","BackshiftOnDrop"],"kind":"struct"},"5:3256":{"crate_id":5,"path":["alloc","collections","linked_list","IterMut"],"kind":"struct"},"15:12521":{"crate_id":15,"path":["object","macho","FilesetEntryCommand"],"kind":"struct"},"1:8417":{"crate_id":1,"path":["std","sync","mutex","Mutex"],"kind":"struct"},"5:7602":{"crate_id":5,"path":["alloc","string","String"],"kind":"struct"},"9:361":{"crate_id":9,"path":["hashbrown","raw","RawIter"],"kind":"struct"},"6:5011":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","cmsghdr"],"kind":"struct"},"6:3823":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_mask"],"kind":"struct"},"2:42565":{"crate_id":2,"path":["core","iter","adapters","filter","Filter"],"kind":"struct"},"15:13574":{"crate_id":15,"path":["object","pe","ImageDynamicRelocationTable"],"kind":"struct"},"5:2920":{"crate_id":5,"path":["alloc","collections","btree","set","Intersection"],"kind":"struct"},"15:10081":{"crate_id":15,"path":["object","read","coff","section","SectionTable"],"kind":"struct"},"2:47176":{"crate_id":2,"path":["core","core_arch","simd","f32x2"],"kind":"struct"},"2:42060":{"crate_id":2,"path":["core","ops","range","RangeToInclusive"],"kind":"struct"},"6:5947":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_fpstate"],"kind":"struct"},"6:6616":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_mutex_t"],"kind":"struct"},"1:9329":{"crate_id":1,"path":["std","sys_common","remutex","ReentrantMutexGuard"],"kind":"struct"},"2:4121":{"crate_id":2,"path":["core","array","collect_into_array","Guard"],"kind":"struct"},"2:4341":{"crate_id":2,"path":["core","cell","Ref"],"kind":"struct"},"15:12327":{"crate_id":15,"path":["object","macho","SymtabCommand"],"kind":"struct"},"1:10889":{"crate_id":1,"path":["std","net","parser","AddrParseError"],"kind":"struct"},"6:5810":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","flock"],"kind":"struct"},"14:7761":{"crate_id":14,"path":["gimli","read","unit","AttrsIter"],"kind":"struct"},"6:5176":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","seminfo"],"kind":"struct"},"2:22009":{"crate_id":2,"path":["core","num","nonzero","NonZeroI8"],"kind":"struct"},"5:2177":{"crate_id":5,"path":["alloc","collections","btree","node","NodeRef"],"kind":"struct"},"14:4704":{"crate_id":14,"path":["gimli","constants","DwCc"],"kind":"struct"},"15:11458":{"crate_id":15,"path":["object","elf","FileHeader64"],"kind":"struct"},"15:11147":{"crate_id":15,"path":["object","read","SymbolMap"],"kind":"struct"},"2:43756":{"crate_id":2,"path":["core","sync","atomic","AtomicU16"],"kind":"struct"},"6:1668":{"crate_id":6,"path":["libc","unix","linux_like","arpreq"],"kind":"struct"},"6:4258":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_user_dev"],"kind":"struct"},"6:5344":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","msqid_ds"],"kind":"struct"},"2:47667":{"crate_id":2,"path":["core","core_arch","simd","m16x8"],"kind":"struct"},"14:6964":{"crate_id":14,"path":["gimli","read","op","Location"],"kind":"enum"},"15:607":{"crate_id":15,"path":["object","read","any","Comdat"],"kind":"struct"},"2:3248":{"crate_id":2,"path":["core","ops","function","FnOnce"],"kind":"trait"},"15:9296":{"crate_id":15,"path":["object","endian","U16Bytes"],"kind":"struct"},"6:3917":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_abs_setup"],"kind":"struct"},"1:10317":{"crate_id":1,"path":["std","ffi","c_str","CString"],"kind":"struct"},"6:1654":{"crate_id":6,"path":["libc","unix","linux_like","in6_rtmsg"],"kind":"struct"},"1:4063":{"crate_id":1,"path":["std","io","stdio","StdoutRaw"],"kind":"struct"},"15:13205":{"crate_id":15,"path":["object","pe","AnonObjectHeaderV2"],"kind":"struct"},"0:4":{"crate_id":0,"path":["rustc_error_codes","error_codes"],"kind":"module"},"14:2912":{"crate_id":14,"path":["gimli","common","DebugInfoOffset"],"kind":"struct"},"1:10584":{"crate_id":1,"path":["std","io","error","Custom"],"kind":"struct"},"2:42330":{"crate_id":2,"path":["core","char","convert","ParseCharError"],"kind":"struct"},"14:6087":{"crate_id":14,"path":["gimli","read","abbrev","DebugAbbrev"],"kind":"struct"},"6:82":{"crate_id":6,"path":["libc","unix","DIR"],"kind":"enum"},"1:5671":{"crate_id":1,"path":["std","os","unix","net","ancillary","AncillaryDataIter"],"kind":"struct"},"1:15276":{"crate_id":1,"path":["std","u32"],"kind":"primitive"},"2:3092":{"crate_id":2,"path":["core","ops","arith","Rem"],"kind":"trait"},"1:1223":{"crate_id":1,"path":["std","collections","hash","map","Keys"],"kind":"struct"},"2:46222":{"crate_id":2,"path":["core","alloc","layout","Layout"],"kind":"struct"},"2:3371":{"crate_id":2,"path":["core","ops","range","RangeBounds"],"kind":"trait"},"6:3910":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_ff_erase"],"kind":"struct"},"1:932":{"crate_id":1,"path":["std","backtrace","BacktraceFrame"],"kind":"struct"},"15:8849":{"crate_id":15,"path":["object","common","Architecture"],"kind":"enum"},"14:5346":{"crate_id":14,"path":["gimli","read","addr","DebugAddr"],"kind":"struct"},"14:5595":{"crate_id":14,"path":["gimli","read","cfi","CommonInformationEntry"],"kind":"struct"},"9:2060":{"crate_id":9,"path":["hashbrown","raw","bitmask","BitMask"],"kind":"struct"},"17:927":{"crate_id":17,"path":["miniz_oxide","inflate","TINFLStatus"],"kind":"enum"},"6:4121":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_vm"],"kind":"struct"},"2:44440":{"crate_id":2,"path":["core","fmt","ArgumentV1"],"kind":"struct"},"17:469":{"crate_id":17,"path":["miniz_oxide","inflate","core","DecompressorOxide"],"kind":"struct"},"2:3118":{"crate_id":2,"path":["core","ops","arith","RemAssign"],"kind":"trait"},"1:15279":{"crate_id":1,"path":["std","isize"],"kind":"primitive"},"1:13249":{"crate_id":1,"path":["std","sys","unix","pipe","AnonPipe"],"kind":"struct"},"2:21321":{"crate_id":2,"path":["core","num","dec2flt","common","AsciiStr"],"kind":"struct"},"15:9592":{"crate_id":15,"path":["object","read","any","File"],"kind":"struct"},"2:12690":{"crate_id":2,"path":["rustc_error_codes","Future"],"kind":"typedef"},"1:4747":{"crate_id":1,"path":["rustc_error_codes","Iter"],"kind":"typedef"},"5:7222":{"crate_id":5,"path":["rustc_error_codes","Target"],"kind":"typedef"},"1:3170":{"crate_id":1,"path":["std","fs","read_link"],"kind":"function"},"2:44373":{"crate_id":2,"path":["core","fmt","rt","v1","Argument"],"kind":"struct"},"2:47542":{"crate_id":2,"path":["core","core_arch","simd","f64x2"],"kind":"struct"},"6:3735":{"crate_id":6,"path":["libc","unix","linux_like","linux","itimerspec"],"kind":"struct"},"15:10864":{"crate_id":15,"path":["object","read","macho","symbol","MachOSymbolTable"],"kind":"struct"},"1:14239":{"crate_id":1,"path":["std","sys","unix","process","process_inner","{{impl}}","posix_spawn","PosixSpawnFileActions"],"kind":"struct"},"2:12753":{"crate_id":2,"path":["core","future","poll_fn","PollFn"],"kind":"struct"},"6:3803":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_absinfo"],"kind":"struct"},"1:8315":{"crate_id":1,"path":["std","sync","barrier","BarrierWaitResult"],"kind":"struct"},"15:10529":{"crate_id":15,"path":["object","read","elf","version","VernauxIterator"],"kind":"struct"},"2:11840":{"crate_id":2,"path":["rustc_error_codes","Output"],"kind":"typedef"},"15:10938":{"crate_id":15,"path":["object","read","pe","file","PeComdat"],"kind":"struct"},"1:1934":{"crate_id":1,"path":["std","collections","hash","set","Iter"],"kind":"struct"},"1:5940":{"crate_id":1,"path":["std","os","unix","net","listener","UnixListener"],"kind":"struct"},"15:12756":{"crate_id":15,"path":["object","macho","Nlist64"],"kind":"struct"},"2:45685":{"crate_id":2,"path":["core","str","pattern","MultiCharEqSearcher"],"kind":"struct"},"2:45983":{"crate_id":2,"path":["core","str","CharEscapeUnicode"],"kind":"struct"},"1:5482":{"crate_id":1,"path":["std","os","unix","fs","MetadataExt"],"kind":"trait"},"5:6001":{"crate_id":5,"path":["alloc","sync","ArcInner"],"kind":"struct"},"15:10001":{"crate_id":15,"path":["object","read","archive","ArchiveKind"],"kind":"enum"},"2:49393":{"crate_id":2,"path":["core","core_arch","x86","cpuid","CpuidResult"],"kind":"struct"},"6:3795":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_id"],"kind":"struct"},"1:14352":{"crate_id":1,"path":["std","sys","unix","time","inner","SystemTime"],"kind":"struct"},"2:3883":{"crate_id":2,"path":["core","array","iter","IntoIter"],"kind":"struct"},"2:45995":{"crate_id":2,"path":["core","str","IsAsciiWhitespace"],"kind":"struct"},"15:12385":{"crate_id":15,"path":["object","macho","DylibModule32"],"kind":"struct"},"2:12668":{"crate_id":2,"path":["core","future","future","Future"],"kind":"trait"},"15:13554":{"crate_id":15,"path":["object","pe","ImageResourceDataEntry"],"kind":"struct"},"9:800":{"crate_id":9,"path":["hashbrown","map","ConsumeAllOnDrop"],"kind":"struct"},"15:12221":{"crate_id":15,"path":["object","macho","SubUmbrellaCommand"],"kind":"struct"},"1:10985":{"crate_id":1,"path":["std","os","unix","ucred","UCred"],"kind":"struct"},"15:10543":{"crate_id":15,"path":["object","read","macho","dyld_cache","DyldCache"],"kind":"struct"},"2:42555":{"crate_id":2,"path":["core","iter","adapters","enumerate","Enumerate"],"kind":"struct"},"1:10837":{"crate_id":1,"path":["std","net","ip","Ipv6Addr"],"kind":"struct"},"1:8663":{"crate_id":1,"path":["std","sync","rwlock","RwLockReadGuard"],"kind":"struct"},"15:12155":{"crate_id":15,"path":["object","macho","FvmlibCommand"],"kind":"struct"},"1:6824":{"crate_id":1,"path":["std","panic","always_abort"],"kind":"function"},"15:13377":{"crate_id":15,"path":["object","pe","ImageRelocation"],"kind":"struct"},"6:4107":{"crate_id":6,"path":["libc","unix","linux_like","linux","inotify_event"],"kind":"struct"},"15:11100":{"crate_id":15,"path":["object","read","SymbolIndex"],"kind":"struct"},"15:12982":{"crate_id":15,"path":["object","pe","ImageVxdHeader"],"kind":"struct"},"16:739":{"crate_id":16,"path":["memchr","memmem","twoway","Suffix"],"kind":"struct"},"5:956":{"crate_id":5,"path":["alloc","collections","btree","borrow","DormantMutRef"],"kind":"struct"},"1:10774":{"crate_id":1,"path":["std","io","Lines"],"kind":"struct"},"2:48236":{"crate_id":2,"path":["core","core_arch","simd","f32x8"],"kind":"struct"},"2:46208":{"crate_id":2,"path":["core","task","wake","RawWakerVTable"],"kind":"struct"},"2:12934":{"crate_id":2,"path":["core","task","wake","Waker"],"kind":"struct"},"2:10311":{"crate_id":2,"path":["core","slice","iter","RSplit"],"kind":"struct"},"2:12924":{"crate_id":2,"path":["core","task","wake","Context"],"kind":"struct"},"15:10950":{"crate_id":15,"path":["object","read","pe","file","PeComdatSectionIterator"],"kind":"struct"},"1:5693":{"crate_id":1,"path":["std","os","unix","net","ancillary","ScmRights"],"kind":"struct"},"2:3171":{"crate_id":2,"path":["core","ops","bit","ShrAssign"],"kind":"trait"},"2:21945":{"crate_id":2,"path":["core","num","nonzero","NonZeroU128"],"kind":"struct"},"15:9809":{"crate_id":15,"path":["object","read","any","ComdatSectionIteratorInternal"],"kind":"enum"},"9:1760":{"crate_id":9,"path":["hashbrown","set","IntoIter"],"kind":"struct"},"2:43684":{"crate_id":2,"path":["core","sync","atomic","AtomicU8"],"kind":"struct"},"6:5045":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","mallinfo2"],"kind":"struct"},"5:5169":{"crate_id":5,"path":["rustc_error_codes","Output"],"kind":"typedef"},"14:3264":{"crate_id":14,"path":["gimli","common","DebugStrOffsetsIndex"],"kind":"struct"},"6:5819":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","flock64"],"kind":"struct"},"15:13760":{"crate_id":15,"path":["object","pe","ImageHotPatchHashes"],"kind":"struct"},"2:42685":{"crate_id":2,"path":["core","iter","adapters","skip_while","SkipWhile"],"kind":"struct"},"14:7549":{"crate_id":14,"path":["gimli","read","unit","DebuggingInformationEntry"],"kind":"struct"},"1:973":{"crate_id":1,"path":["std","backtrace","LazilyResolvedCapture"],"kind":"struct"},"5:1334":{"crate_id":5,"path":["alloc","collections","btree","map","ValuesMut"],"kind":"struct"},"1:5823":{"crate_id":1,"path":["std","os","unix","net","datagram","UnixDatagram"],"kind":"struct"},"15:12610":{"crate_id":15,"path":["object","macho","DyldInfoCommand"],"kind":"struct"},"15:2484":{"crate_id":15,"path":["object","read","elf","relocation","ElfRelaIterator"],"kind":"enum"},"9:2066":{"crate_id":9,"path":["hashbrown","raw","Fallibility"],"kind":"enum"},"15:10623":{"crate_id":15,"path":["object","read","macho","file","MachOComdatSectionIterator"],"kind":"struct"},"1:10493":{"crate_id":1,"path":["std","fs","Metadata"],"kind":"struct"},"6:4920":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","statx"],"kind":"struct"},"2:46922":{"crate_id":2,"path":["core","core_arch","simd","i8x4"],"kind":"struct"},"14:5960":{"crate_id":14,"path":["gimli","read","cfi","PointerEncodingParameters"],"kind":"struct"},"5:936":{"crate_id":5,"path":["alloc","collections","btree","append","MergeIter"],"kind":"struct"},"14:5815":{"crate_id":14,"path":["gimli","read","cfi","RegisterRule"],"kind":"enum"},"1:13138":{"crate_id":1,"path":["std","sys","unix","os_str","Slice"],"kind":"struct"},"1:14011":{"crate_id":1,"path":["std","sys","unix","fs","StatxExtraFields"],"kind":"struct"},"2:43452":{"crate_id":2,"path":["core","option","Item"],"kind":"struct"},"6:1550":{"crate_id":6,"path":["libc","unix","linux_like","addrinfo"],"kind":"struct"},"2:3665":{"crate_id":2,"path":["core","any","Any"],"kind":"trait"},"1:5516":{"crate_id":1,"path":["std","os","unix","fs","FileTypeExt"],"kind":"trait"},"1:14333":{"crate_id":1,"path":["std","sys","unix","time","inner","Instant"],"kind":"struct"},"1:3803":{"crate_id":1,"path":["std","io","error","Error"],"kind":"struct"},"13:248":{"crate_id":13,"path":["addr2line","LocationRangeUnitIter"],"kind":"struct"},"2:4331":{"crate_id":2,"path":["core","cell","BorrowRef"],"kind":"struct"},"1:1265":{"crate_id":1,"path":["std","collections","hash","map","ValuesMut"],"kind":"struct"},"1:10498":{"crate_id":1,"path":["std","fs","ReadDir"],"kind":"struct"},"14:2889":{"crate_id":14,"path":["gimli","common","DebugArangesOffset"],"kind":"struct"},"15:12040":{"crate_id":15,"path":["object","macho","LcStr"],"kind":"struct"},"15:13062":{"crate_id":15,"path":["object","pe","ImageOptionalHeader32"],"kind":"struct"},"5:6565":{"crate_id":5,"path":["alloc","vec","drain","{{impl}}","drop","DropGuard"],"kind":"struct"},"14:6518":{"crate_id":14,"path":["gimli","read","line","FileEntry"],"kind":"struct"},"6:5318":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","sigset_t"],"kind":"struct"},"2:3032":{"crate_id":2,"path":["core","marker","Freeze"],"kind":"trait"},"2:5934":{"crate_id":2,"path":["core","iter","adapters","intersperse","IntersperseWith"],"kind":"struct"},"2:12984":{"crate_id":2,"path":["core","task","ready","Ready"],"kind":"struct"},"1:9239":{"crate_id":1,"path":["std","sys_common","mutex","StaticMutexGuard"],"kind":"struct"},"5:5186":{"crate_id":5,"path":["rustc_error_codes","Owned"],"kind":"typedef"},"1:15010":{"crate_id":1,"path":["std","backtrace_rs","symbolize","gimli","mmap","Mmap"],"kind":"struct"},"14:7843":{"crate_id":14,"path":["gimli","read","unit","EntriesTreeNode"],"kind":"struct"},"5:7680":{"crate_id":5,"path":["alloc","vec","drain_filter","DrainFilter"],"kind":"struct"},"1:15231":{"crate_id":1,"path":["std","backtrace_rs","types","BytesOrWideString"],"kind":"enum"},"1:11774":{"crate_id":1,"path":["std","sync","once","OnceState"],"kind":"struct"},"1:9244":{"crate_id":1,"path":["std","sys_common","mutex","MovableMutex"],"kind":"struct"},"5:7613":{"crate_id":5,"path":["alloc","string","FromUtf8Error"],"kind":"struct"},"2:46237":{"crate_id":2,"path":["core","alloc","layout","LayoutError"],"kind":"struct"},"2:42384":{"crate_id":2,"path":["core","char","decode","DecodeUtf16Error"],"kind":"struct"},"2:42484":{"crate_id":2,"path":["core","ffi","VaListImpl"],"kind":"struct"},"16:636":{"crate_id":16,"path":["memchr","memmem","genericsimd","Forward"],"kind":"struct"},"2:10098":{"crate_id":2,"path":["rustc_error_codes","Item"],"kind":"typedef"},"2:42458":{"crate_id":2,"path":["core","char","ToUppercase"],"kind":"struct"},"6:4219":{"crate_id":6,"path":["libc","unix","linux_like","linux","dirent"],"kind":"struct"},"1:14223":{"crate_id":1,"path":["std","sys","unix","process","process_inner","{{impl}}","do_exec","Reset"],"kind":"struct"},"2:47723":{"crate_id":2,"path":["core","core_arch","simd","m64x2"],"kind":"struct"},"1:9115":{"crate_id":1,"path":["std","sys_common","backtrace","_print","DisplayBacktrace"],"kind":"struct"},"2:4624":{"crate_id":2,"path":["core","char","REPLACEMENT_CHARACTER"],"kind":"constant"},"1:10708":{"crate_id":1,"path":["std","io","IoSlice"],"kind":"struct"},"6:1574":{"crate_id":6,"path":["libc","unix","linux_like","fd_set"],"kind":"struct"},"15:13842":{"crate_id":15,"path":["object","pe","ImageEnclaveConfig64"],"kind":"struct"},"9:380":{"crate_id":9,"path":["hashbrown","raw","RawIntoIter"],"kind":"struct"},"6:4045":{"crate_id":6,"path":["libc","unix","linux_like","linux","ucred"],"kind":"struct"},"5:3723":{"crate_id":5,"path":["alloc","collections","vec_deque","drain","{{impl}}","drop","DropGuard"],"kind":"struct"},"1:2235":{"crate_id":1,"path":["std","env","Args"],"kind":"struct"},"9:2082":{"crate_id":9,"path":["hashbrown","TryReserveError"],"kind":"enum"},"6:5839":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stack_t"],"kind":"struct"},"18:54":{"crate_id":18,"path":["adler","Adler32"],"kind":"struct"},"2:43792":{"crate_id":2,"path":["core","sync","atomic","AtomicI32"],"kind":"struct"},"15:13598":{"crate_id":15,"path":["object","pe","ImageDynamicRelocation32V2"],"kind":"struct"},"15:13221":{"crate_id":15,"path":["object","pe","AnonObjectHeaderBigobj"],"kind":"struct"},"2:2655":{"crate_id":2,"path":["core","cmp","PartialEq"],"kind":"trait"},"1:5101":{"crate_id":1,"path":["std","net","tcp","TcpStream"],"kind":"struct"},"6:521":{"crate_id":6,"path":["libc","unix","timespec"],"kind":"struct"},"1:5538":{"crate_id":1,"path":["std","os","unix","fs","DirBuilderExt"],"kind":"trait"},"15:10801":{"crate_id":15,"path":["object","read","macho","segment","MachOSegment"],"kind":"struct"},"2:21376":{"crate_id":2,"path":["core","num","dec2flt","number","Number"],"kind":"struct"},"2:3245":{"crate_id":2,"path":["core","ops","function","FnMut"],"kind":"trait"},"14:2991":{"crate_id":14,"path":["gimli","common","LocationListsOffset"],"kind":"struct"},"2:46011":{"crate_id":2,"path":["core","time","Duration"],"kind":"struct"},"5:7439":{"crate_id":5,"path":["alloc","collections","btree","set","BTreeSet"],"kind":"struct"},"6:6581":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_mutexattr_t"],"kind":"struct"},"1:10267":{"crate_id":1,"path":["std","collections","hash","map","RandomState"],"kind":"struct"},"2:45435":{"crate_id":2,"path":["core","str","iter","RMatchIndices"],"kind":"struct"},"14:3429":{"crate_id":14,"path":["gimli","common","SectionId"],"kind":"enum"},"2:48927":{"crate_id":2,"path":["core","core_arch","simd","i32x16"],"kind":"struct"},"1:11585":{"crate_id":1,"path":["std","process","ExitCode"],"kind":"struct"},"2:9483":{"crate_id":2,"path":["core","fmt","{{impl}}","fmt","BorrowedPlaceholder"],"kind":"struct"},"15:12771":{"crate_id":15,"path":["object","macho","Relocation"],"kind":"struct"},"1:11703":{"crate_id":1,"path":["std","sync","mpsc","TryRecvError"],"kind":"enum"},"2:43648":{"crate_id":2,"path":["core","sync","atomic","AtomicI8"],"kind":"struct"},"14:6691":{"crate_id":14,"path":["gimli","read","loclists","LocationListEntry"],"kind":"struct"},"5:4039":{"crate_id":5,"path":["alloc","collections","vec_deque","VecDeque"],"kind":"struct"},"1:8457":{"crate_id":1,"path":["std","sync","mutex","{{impl}}","fmt","LockedPlaceholder"],"kind":"struct"},"2:42422":{"crate_id":2,"path":["core","char","EscapeDefault"],"kind":"struct"},"5:7625":{"crate_id":5,"path":["alloc","string","FromUtf16Error"],"kind":"struct"},"1:10276":{"crate_id":1,"path":["std","collections","hash","map","DefaultHasher"],"kind":"struct"},"6:1525":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr"],"kind":"struct"},"14:5580":{"crate_id":14,"path":["gimli","read","cfi","AugmentationData"],"kind":"struct"},"2:45082":{"crate_id":2,"path":["core","slice","iter","Chunks"],"kind":"struct"},"1:2783":{"crate_id":1,"path":["std","ffi","os_str","OsStr"],"kind":"struct"},"1:4399":{"crate_id":1,"path":["rustc_error_codes","Target"],"kind":"typedef"},"14:6682":{"crate_id":14,"path":["gimli","read","loclists","LocListIter"],"kind":"struct"},"15:13465":{"crate_id":15,"path":["object","pe","ImageTlsDirectory32"],"kind":"struct"},"2:10404":{"crate_id":2,"path":["core","slice","iter","RSplitN"],"kind":"struct"},"15:11794":{"crate_id":15,"path":["object","elf","Vernaux"],"kind":"struct"},"2:42397":{"crate_id":2,"path":["core","char","EscapeUnicode"],"kind":"struct"},"15:10912":{"crate_id":15,"path":["object","read","pe","file","PeFile"],"kind":"struct"},"2:42536":{"crate_id":2,"path":["core","iter","adapters","copied","Copied"],"kind":"struct"},"1:14042":{"crate_id":1,"path":["std","sys","unix","fs","FileType"],"kind":"struct"},"14:5790":{"crate_id":14,"path":["gimli","read","cfi","CfaRule"],"kind":"enum"},"1:10218":{"crate_id":1,"path":["std","thread","Thread"],"kind":"struct"},"1:10173":{"crate_id":1,"path":["std","sealed","Sealed"],"kind":"trait"},"2:11420":{"crate_id":2,"path":["rustc_error_codes","Item"],"kind":"typedef"},"2:3148":{"crate_id":2,"path":["core","ops","bit","Shr"],"kind":"trait"},"5:6100":{"crate_id":5,"path":["rustc_error_codes","Target"],"kind":"typedef"},"6:5926":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","pthread_attr_t"],"kind":"struct"},"1:1089":{"crate_id":1,"path":["std","collections","hash","map","HashMap"],"kind":"struct"},"1:935":{"crate_id":1,"path":["std","backtrace","BacktraceSymbol"],"kind":"struct"},"15:11118":{"crate_id":15,"path":["object","read","SymbolSection"],"kind":"enum"},"2:44872":{"crate_id":2,"path":["core","slice","ascii","EscapeByte"],"kind":"struct"},"15:12946":{"crate_id":15,"path":["object","pe","ImageOs2Header"],"kind":"struct"},"2:3166":{"crate_id":2,"path":["core","ops","bit","ShlAssign"],"kind":"trait"},"15:11696":{"crate_id":15,"path":["object","elf","ProgramHeader64"],"kind":"struct"},"5:2662":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Dying"],"kind":"enum"},"2:45550":{"crate_id":2,"path":["core","str","iter","SplitAsciiWhitespace"],"kind":"struct"},"2:45828":{"crate_id":2,"path":["core","str","pattern","StrSearcher"],"kind":"struct"},"1:2141":{"crate_id":1,"path":["std","env"],"kind":"module"},"15:13386":{"crate_id":15,"path":["object","pe","ImageLinenumber"],"kind":"struct"},"6:501":{"crate_id":6,"path":["libc","unix","group"],"kind":"struct"},"15:11304":{"crate_id":15,"path":["object","read","RelocationTarget"],"kind":"enum"},"14:6252":{"crate_id":14,"path":["gimli","read","line","LineRows"],"kind":"struct"},"2:9369":{"crate_id":2,"path":["core","fmt","UpperHex"],"kind":"trait"},"6:1541":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_in6"],"kind":"struct"},"12:0":{"crate_id":12,"path":["std_detect"],"kind":"module"},"15:13685":{"crate_id":15,"path":["object","pe","ImageLoadConfigDirectory64"],"kind":"struct"},"17:722":{"crate_id":17,"path":["miniz_oxide","deflate","core","TDEFLFlush"],"kind":"enum"},"2:45190":{"crate_id":2,"path":["core","slice","iter","RChunksExact"],"kind":"struct"},"6:3863":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_condition_effect"],"kind":"struct"},"2:12182":{"crate_id":2,"path":["core","str","lossy","Utf8Lossy"],"kind":"struct"},"2:49263":{"crate_id":2,"path":["core","core_arch","x86","__m512i"],"kind":"struct"},"2:45566":{"crate_id":2,"path":["core","str","iter","EscapeDebug"],"kind":"struct"},"15:12051":{"crate_id":15,"path":["object","macho","SegmentCommand32"],"kind":"struct"},"14:4734":{"crate_id":14,"path":["gimli","constants","DwInl"],"kind":"struct"},"1:1938":{"crate_id":1,"path":["std","collections","hash","set","IntoIter"],"kind":"struct"},"2:33722":{"crate_id":2,"path":["core","cmp","Ordering"],"kind":"enum"},"15:12168":{"crate_id":15,"path":["object","macho","Dylib"],"kind":"struct"},"1:13798":{"crate_id":1,"path":["std","sys","unix","thread","Thread"],"kind":"struct"},"2:34900":{"crate_id":2,"path":["core","convert","Infallible"],"kind":"enum"},"1:13723":{"crate_id":1,"path":["std","sys","unix","stdio","Stderr"],"kind":"struct"},"1:7237":{"crate_id":1,"path":["rustc_error_codes","IntoIter"],"kind":"typedef"},"1:5460":{"crate_id":1,"path":["std","os","unix","fs","FileExt"],"kind":"trait"},"2:47440":{"crate_id":2,"path":["core","core_arch","simd","i16x8"],"kind":"struct"},"2:7150":{"crate_id":2,"path":["core","iter","sources","empty","Empty"],"kind":"struct"},"15:11981":{"crate_id":15,"path":["object","macho","FatArch64"],"kind":"struct"},"15:13258":{"crate_id":15,"path":["object","pe","ImageSymbol"],"kind":"struct"},"15:10458":{"crate_id":15,"path":["object","read","elf","note","Note"],"kind":"struct"},"2:9315":{"crate_id":2,"path":["core","fmt","Formatter"],"kind":"struct"},"14:5273":{"crate_id":14,"path":["gimli","constants","DwEhPe"],"kind":"struct"},"14:7467":{"crate_id":14,"path":["gimli","read","unit","DebugInfoUnitHeadersIter"],"kind":"struct"},"6:151":{"crate_id":6,"path":["libc","unix","FILE"],"kind":"enum"},"5:671":{"crate_id":5,"path":["alloc","collections","binary_heap","BinaryHeap"],"kind":"struct"},"1:3368":{"crate_id":1,"path":["std","io","buffered","bufreader","BufReader"],"kind":"struct"},"1:10283":{"crate_id":1,"path":["std","env","VarError"],"kind":"enum"},"15:11555":{"crate_id":15,"path":["object","elf","CompressionHeader64"],"kind":"struct"},"1:2212":{"crate_id":1,"path":["std","env","SplitPaths"],"kind":"struct"},"1:10979":{"crate_id":1,"path":["std","os","unix","net","listener","Incoming"],"kind":"struct"},"1:10510":{"crate_id":1,"path":["std","fs","Permissions"],"kind":"struct"},"15:11767":{"crate_id":15,"path":["object","elf","Verdaux"],"kind":"struct"},"9:1776":{"crate_id":9,"path":["hashbrown","set","Intersection"],"kind":"struct"},"14:7823":{"crate_id":14,"path":["gimli","read","unit","EntriesTree"],"kind":"struct"},"2:3154":{"crate_id":2,"path":["core","ops","bit","BitAndAssign"],"kind":"trait"},"1:11690":{"crate_id":1,"path":["std","sync","mpsc","RecvError"],"kind":"struct"},"2:45716":{"crate_id":2,"path":["core","str","pattern","CharArrayRefSearcher"],"kind":"struct"},"17:27":{"crate_id":17,"path":["miniz_oxide","deflate","buffer","HashBuffers"],"kind":"struct"},"15:12671":{"crate_id":15,"path":["object","macho","FvmfileCommand"],"kind":"struct"},"2:46945":{"crate_id":2,"path":["core","core_arch","simd","i16x2"],"kind":"struct"},"15:13370":{"crate_id":15,"path":["object","pe","ImageAuxSymbolCrc"],"kind":"struct"},"2:48990":{"crate_id":2,"path":["core","core_arch","simd","u32x16"],"kind":"struct"},"15:9264":{"crate_id":15,"path":["object","endian","LittleEndian"],"kind":"struct"},"14:6491":{"crate_id":14,"path":["gimli","read","line","CompleteLineProgram"],"kind":"struct"},"2:3158":{"crate_id":2,"path":["core","ops","bit","BitOrAssign"],"kind":"trait"},"2:42913":{"crate_id":2,"path":["core","iter","sources","once_with","OnceWith"],"kind":"struct"},"14:3604":{"crate_id":14,"path":["gimli","arch","X86_64"],"kind":"struct"},"2:45575":{"crate_id":2,"path":["core","str","iter","EscapeDefault"],"kind":"struct"},"15:11714":{"crate_id":15,"path":["object","elf","Dyn32"],"kind":"struct"},"15:9551":{"crate_id":15,"path":["object","read","util","ByteString"],"kind":"struct"},"1:13383":{"crate_id":1,"path":["std","sys","unix","process","process_common","Command"],"kind":"struct"},"2:11982":{"crate_id":2,"path":["core","str","pattern","ReverseSearcher"],"kind":"trait"},"15:11588":{"crate_id":15,"path":["object","elf","Sym64"],"kind":"struct"},"2:10133":{"crate_id":2,"path":["core","slice","iter","IterMut"],"kind":"struct"},"15:10420":{"crate_id":15,"path":["object","read","elf","comdat","ElfComdat"],"kind":"struct"},"6:6587":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_rwlockattr_t"],"kind":"struct"},"6:3768":{"crate_id":6,"path":["libc","unix","linux_like","linux","msginfo"],"kind":"struct"},"2:45987":{"crate_id":2,"path":["core","str","CharEscapeDefault"],"kind":"struct"},"1:11108":{"crate_id":1,"path":["std","path","State"],"kind":"enum"},"2:7877":{"crate_id":2,"path":["core","iter","traits","marker","TrustedLen"],"kind":"trait"},"1:9367":{"crate_id":1,"path":["std","sys_common","rwlock","StaticRWLockWriteGuard"],"kind":"struct"},"6:1608":{"crate_id":6,"path":["libc","unix","linux_like","lconv"],"kind":"struct"},"5:3243":{"crate_id":5,"path":["alloc","collections","linked_list","Iter"],"kind":"struct"},"15:10179":{"crate_id":15,"path":["object","read","coff","symbol","CoffSymbol"],"kind":"struct"},"2:2691":{"crate_id":2,"path":["core","cmp","Ord"],"kind":"trait"},"5:7463":{"crate_id":5,"path":["alloc","collections","btree","set","IntoIter"],"kind":"struct"},"2:2660":{"crate_id":2,"path":["core","cmp","Eq"],"kind":"trait"},"2:4195":{"crate_id":2,"path":["core","cell","Cell"],"kind":"struct"},"2:43520":{"crate_id":2,"path":["core","panic","panic_info","PanicInfo"],"kind":"struct"},"15:10128":{"crate_id":15,"path":["object","read","coff","section","CoffSection"],"kind":"struct"},"1:5104":{"crate_id":1,"path":["std","net","tcp","TcpListener"],"kind":"struct"},"14:6391":{"crate_id":14,"path":["gimli","read","line","ColumnType"],"kind":"enum"},"2:7435":{"crate_id":2,"path":["core","iter","traits","collect","Extend"],"kind":"trait"},"2:2086":{"crate_id":2,"path":["core","ptr","metadata","PtrComponents"],"kind":"struct"},"15:10041":{"crate_id":15,"path":["object","read","archive","ArchiveMemberIterator"],"kind":"struct"},"16:857":{"crate_id":16,"path":["memchr","memmem","SearcherConfig"],"kind":"struct"},"5:7394":{"crate_id":5,"path":["alloc","collections","binary_heap","IntoIter"],"kind":"struct"},"2:47930":{"crate_id":2,"path":["core","core_arch","simd","u32x8"],"kind":"struct"},"1:11207":{"crate_id":1,"path":["std","path","Ancestors"],"kind":"struct"},"6:4229":{"crate_id":6,"path":["libc","unix","linux_like","linux","dirent64"],"kind":"struct"},"14:3172":{"crate_id":14,"path":["gimli","common","DebugRngListsBase"],"kind":"struct"},"2:2951":{"crate_id":2,"path":["rustc_error_codes","Error"],"kind":"typedef"},"6:3836":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_trigger"],"kind":"struct"},"1:10767":{"crate_id":1,"path":["std","io","Split"],"kind":"struct"},"1:6670":{"crate_id":1,"path":["std","os","fd","owned","OwnedFd"],"kind":"struct"},"2:10432":{"crate_id":2,"path":["core","slice","iter","RSplitNMut"],"kind":"struct"},"2:49354":{"crate_id":2,"path":["core","core_arch","x86","__m512bh"],"kind":"struct"},"15:13978":{"crate_id":15,"path":["object","pe","ImageArchitectureEntry"],"kind":"struct"},"1:15262":{"crate_id":1,"path":["std","pointer"],"kind":"primitive"},"15:10140":{"crate_id":15,"path":["object","read","coff","symbol","SymbolTable"],"kind":"struct"},"2:22137":{"crate_id":2,"path":["core","num","nonzero","NonZeroI128"],"kind":"struct"},"2:3081":{"crate_id":2,"path":["core","ops","arith","Mul"],"kind":"trait"},"1:10300":{"crate_id":1,"path":["std","env","JoinPathsError"],"kind":"struct"},"5:1353":{"crate_id":5,"path":["alloc","collections","btree","map","IntoValues"],"kind":"struct"},"5:1595":{"crate_id":5,"path":["alloc","collections","btree","map","DrainFilter"],"kind":"struct"},"7:38":{"crate_id":7,"path":["unwind","libunwind","_Unwind_Reason_Code"],"kind":"enum"},"15:10266":{"crate_id":15,"path":["object","read","elf","segment","ElfSegment"],"kind":"struct"},"1:12793":{"crate_id":1,"path":["std","sys","unix","mutex","PthreadMutexAttr"],"kind":"struct"},"6:4987":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","glob64_t"],"kind":"struct"},"1:11664":{"crate_id":1,"path":["std","sync","mpsc","IntoIter"],"kind":"struct"},"9:2054":{"crate_id":9,"path":["hashbrown","raw","sse2","Group"],"kind":"struct"},"14:7971":{"crate_id":14,"path":["gimli","read","Error"],"kind":"enum"},"15:10117":{"crate_id":15,"path":["object","read","coff","section","CoffSectionIterator"],"kind":"struct"},"5:1852":{"crate_id":5,"path":["alloc","collections","btree","merge_iter","MergeIterInner"],"kind":"struct"},"1:10355":{"crate_id":1,"path":["std","ffi","c_str","FromBytesWithNulError"],"kind":"struct"},"14:5433":{"crate_id":14,"path":["gimli","read","cfi","EhFrame"],"kind":"struct"},"1:1205":{"crate_id":1,"path":["std","collections","hash","map","IterMut"],"kind":"struct"},"2:21455":{"crate_id":2,"path":["core","num","flt2dec","decoder","FullDecoded"],"kind":"enum"},"1:12782":{"crate_id":1,"path":["std","sys","unix","mutex","ReentrantMutex"],"kind":"struct"},"2:42343":{"crate_id":2,"path":["core","char","convert","CharErrorKind"],"kind":"enum"},"15:10975":{"crate_id":15,"path":["object","read","pe","section","PeSegment"],"kind":"struct"},"2:45091":{"crate_id":2,"path":["core","slice","iter","ChunksMut"],"kind":"struct"},"2:9905":{"crate_id":2,"path":["rustc_error_codes","Output"],"kind":"typedef"},"2:43461":{"crate_id":2,"path":["core","option","Iter"],"kind":"struct"},"2:47699":{"crate_id":2,"path":["core","core_arch","simd","m32x4"],"kind":"struct"},"15:10211":{"crate_id":15,"path":["object","read","coff","comdat","CoffComdat"],"kind":"struct"},"1:7701":{"crate_id":1,"path":["std","sync","mpsc","oneshot","Packet"],"kind":"struct"},"1:14598":{"crate_id":1,"path":["std","sys_common","net","LookupHost"],"kind":"struct"},"15:12208":{"crate_id":15,"path":["object","macho","SubClientCommand"],"kind":"struct"},"5:3989":{"crate_id":5,"path":["alloc","collections","vec_deque","pair_slices","PairSlices"],"kind":"struct"},"1:8671":{"crate_id":1,"path":["std","sync","rwlock","RwLockWriteGuard"],"kind":"struct"},"2:11439":{"crate_id":2,"path":["core","str","converts","from_utf8"],"kind":"function"},"9:1067":{"crate_id":9,"path":["hashbrown","map","OccupiedError"],"kind":"struct"},"2:9042":{"crate_id":2,"path":["core","fmt","builders","PadAdapterState"],"kind":"struct"},"1:8157":{"crate_id":1,"path":["std","sync","mpsc","SyncSender"],"kind":"struct"},"15:11947":{"crate_id":15,"path":["object","macho","DyldCacheImageInfo"],"kind":"struct"},"1:9362":{"crate_id":1,"path":["std","sys_common","rwlock","StaticRWLockReadGuard"],"kind":"struct"},"5:7509":{"crate_id":5,"path":["alloc","collections","linked_list","IntoIter"],"kind":"struct"},"2:45842":{"crate_id":2,"path":["core","str","pattern","StrSearcherImpl"],"kind":"enum"},"2:48044":{"crate_id":2,"path":["core","core_arch","simd","i8x32"],"kind":"struct"},"2:9037":{"crate_id":2,"path":["core","fmt","builders","PadAdapter"],"kind":"struct"},"2:3012":{"crate_id":2,"path":["core","marker","StructuralPartialEq"],"kind":"trait"},"6:4250":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_setup"],"kind":"struct"},"9:725":{"crate_id":9,"path":["hashbrown","map","IterMut"],"kind":"struct"},"15:10236":{"crate_id":15,"path":["object","read","elf","file","ElfFile"],"kind":"struct"},"5:6907":{"crate_id":5,"path":["alloc","vec","set_len_on_drop","SetLenOnDrop"],"kind":"struct"},"1:6601":{"crate_id":1,"path":["std","os","fd","raw","AsRawFd"],"kind":"trait"},"2:22465":{"crate_id":2,"path":["core","num","saturating","Saturating"],"kind":"struct"},"6:1562":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_ll"],"kind":"struct"},"6:5996":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user"],"kind":"struct"},"14:4823":{"crate_id":14,"path":["gimli","constants","DwIdx"],"kind":"struct"},"5:1316":{"crate_id":5,"path":["alloc","collections","btree","map","Keys"],"kind":"struct"},"15:9719":{"crate_id":15,"path":["object","read","any","SectionIterator"],"kind":"struct"},"2:22073":{"crate_id":2,"path":["core","num","nonzero","NonZeroI32"],"kind":"struct"},"2:21558":{"crate_id":2,"path":["core","num","error","IntErrorKind"],"kind":"enum"},"6:1707":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_un"],"kind":"struct"},"2:10099":{"crate_id":2,"path":["rustc_error_codes","IntoIter"],"kind":"typedef"},"5:7417":{"crate_id":5,"path":["alloc","collections","binary_heap","DrainSorted"],"kind":"struct"},"6:1600":{"crate_id":6,"path":["libc","unix","linux_like","Dl_info"],"kind":"struct"},"6:3813":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_keymap_entry"],"kind":"struct"},"15:11539":{"crate_id":15,"path":["object","elf","CompressionHeader32"],"kind":"struct"},"2:42574":{"crate_id":2,"path":["core","iter","adapters","filter_map","FilterMap"],"kind":"struct"},"14:6208":{"crate_id":14,"path":["gimli","read","aranges","ArangeEntryIter"],"kind":"struct"},"2:28812":{"crate_id":2,"path":["core","mem","maybe_uninit","MaybeUninit"],"kind":"union"},"6:1595":{"crate_id":6,"path":["libc","unix","linux_like","sched_param"],"kind":"struct"},"17:749":{"crate_id":17,"path":["miniz_oxide","deflate","core","TDEFLStatus"],"kind":"enum"},"2:49226":{"crate_id":2,"path":["core","core_arch","x86","__m256i"],"kind":"struct"},"15:12275":{"crate_id":15,"path":["object","macho","ThreadCommand"],"kind":"struct"},"14:7205":{"crate_id":14,"path":["gimli","read","pubtypes","PubTypesEntry"],"kind":"struct"},"1:14065":{"crate_id":1,"path":["std","sys","unix","io","IoSlice"],"kind":"struct"},"15:10253":{"crate_id":15,"path":["object","read","elf","segment","ElfSegmentIterator"],"kind":"struct"},"15:9759":{"crate_id":15,"path":["object","read","any","ComdatIterator"],"kind":"struct"},"15:13119":{"crate_id":15,"path":["object","pe","ImageOptionalHeader64"],"kind":"struct"},"15:11726":{"crate_id":15,"path":["object","elf","Dyn64"],"kind":"struct"},"15:10095":{"crate_id":15,"path":["object","read","coff","section","CoffSegmentIterator"],"kind":"struct"},"1:1307":{"crate_id":1,"path":["std","collections","hash","map","RawEntryBuilder"],"kind":"struct"},"1:11670":{"crate_id":1,"path":["std","sync","mpsc","SendError"],"kind":"struct"},"16:885":{"crate_id":16,"path":["memchr","memmem","SearcherRev"],"kind":"struct"},"6:5102":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","timex"],"kind":"struct"},"14:2794":{"crate_id":14,"path":["gimli","common","Register"],"kind":"struct"},"2:43720":{"crate_id":2,"path":["core","sync","atomic","AtomicI16"],"kind":"struct"},"2:45999":{"crate_id":2,"path":["core","str","IsNotEmpty"],"kind":"struct"},"17:809":{"crate_id":17,"path":["miniz_oxide","inflate","core","State"],"kind":"enum"},"16:766":{"crate_id":16,"path":["memchr","memmem","twoway","ApproximateByteSet"],"kind":"struct"},"15:13172":{"crate_id":15,"path":["object","pe","ImageRomHeaders"],"kind":"struct"},"2:48170":{"crate_id":2,"path":["core","core_arch","simd","i32x8"],"kind":"struct"},"2:8324":{"crate_id":2,"path":["core","panic","unwind_safe","UnwindSafe"],"kind":"trait"},"14:0":{"crate_id":14,"path":["gimli"],"kind":"module"},"2:44633":{"crate_id":2,"path":["core","hash","sip","SipHasher24"],"kind":"struct"},"14:3772":{"crate_id":14,"path":["gimli","constants","DwCfa"],"kind":"struct"},"5:1168":{"crate_id":5,"path":["alloc","collections","btree","map","entry","VacantEntry"],"kind":"struct"},"15:13306":{"crate_id":15,"path":["object","pe","ImageAuxSymbolTokenDef"],"kind":"struct"},"14:7453":{"crate_id":14,"path":["gimli","read","unit","DebugInfo"],"kind":"struct"},"1:11779":{"crate_id":1,"path":["std","time","Instant"],"kind":"struct"},"5:7409":{"crate_id":5,"path":["alloc","collections","binary_heap","Drain"],"kind":"struct"},"1:15264":{"crate_id":1,"path":["std","slice"],"kind":"primitive"},"6:5031":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","mallinfo"],"kind":"struct"},"1:10304":{"crate_id":1,"path":["std","error","private","Internal"],"kind":"struct"},"2:11673":{"crate_id":2,"path":["core","str","iter","SplitNInternal"],"kind":"struct"},"2:42037":{"crate_id":2,"path":["core","ops","range","RangeInclusive"],"kind":"struct"},"17:776":{"crate_id":17,"path":["miniz_oxide","deflate","CompressionLevel"],"kind":"enum"},"14:5029":{"crate_id":14,"path":["gimli","constants","DwRle"],"kind":"struct"},"1:15242":{"crate_id":1,"path":["std","backtrace_rs","print","PrintFmt"],"kind":"enum"},"15:13780":{"crate_id":15,"path":["object","pe","ImageArm64RuntimeFunctionEntry"],"kind":"struct"},"3:299":{"crate_id":3,"path":["compiler_builtins","float","cmp","Result"],"kind":"enum"},"11:0":{"crate_id":11,"path":["rustc_demangle"],"kind":"module"},"1:3469":{"crate_id":1,"path":["std","io","buffered","bufwriter","{{impl}}","flush_buf","BufGuard"],"kind":"struct"},"2:47321":{"crate_id":2,"path":["core","core_arch","simd","u32x4"],"kind":"struct"},"1:10701":{"crate_id":1,"path":["std","io","util","Sink"],"kind":"struct"},"1:1259":{"crate_id":1,"path":["std","collections","hash","map","DrainFilter"],"kind":"struct"},"1:14733":{"crate_id":1,"path":["std","alloc","System"],"kind":"struct"},"2:22169":{"crate_id":2,"path":["core","num","nonzero","NonZeroIsize"],"kind":"struct"},"15:11835":{"crate_id":15,"path":["object","elf","HashHeader"],"kind":"struct"},"1:10903":{"crate_id":1,"path":["std","net","tcp","Incoming"],"kind":"struct"},"14:2866":{"crate_id":14,"path":["gimli","common","DebugAddrIndex"],"kind":"struct"},"6:5869":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stat64"],"kind":"struct"},"1:2780":{"crate_id":1,"path":["std","ffi","os_str","OsString"],"kind":"struct"},"1:7606":{"crate_id":1,"path":["std","sync","mpsc","blocking","WaitToken"],"kind":"struct"},"6:5359":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","semid_ds"],"kind":"struct"},"1:15280":{"crate_id":1,"path":["std","usize"],"kind":"primitive"},"2:47804":{"crate_id":2,"path":["core","core_arch","simd","u8x32"],"kind":"struct"},"2:11987":{"crate_id":2,"path":["core","str","pattern","DoubleEndedSearcher"],"kind":"trait"},"1:9372":{"crate_id":1,"path":["std","sys_common","rwlock","MovableRWLock"],"kind":"struct"},"2:42014":{"crate_id":2,"path":["core","ops","range","RangeTo"],"kind":"struct"},"8:0":{"crate_id":8,"path":["cfg_if"],"kind":"module"},"6:3842":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_envelope"],"kind":"struct"},"15:13356":{"crate_id":15,"path":["object","pe","ImageAuxSymbolSection"],"kind":"struct"},"2:5492":{"crate_id":2,"path":["core","iter","adapters","flatten","FlatMap"],"kind":"struct"},"6:5018":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","termios"],"kind":"struct"},"1:4424":{"crate_id":1,"path":["std","io","Seek"],"kind":"trait"},"6:574":{"crate_id":6,"path":["libc","unix","pollfd"],"kind":"struct"},"15:13488":{"crate_id":15,"path":["object","pe","ImageBoundImportDescriptor"],"kind":"struct"},"2:3127":{"crate_id":2,"path":["core","ops","bit","BitAnd"],"kind":"trait"},"2:41968":{"crate_id":2,"path":["core","ops","range","Range"],"kind":"struct"},"15:10887":{"crate_id":15,"path":["object","read","macho","symbol","MachOSymbol"],"kind":"struct"},"15:9133":{"crate_id":15,"path":["object","common","RelocationEncoding"],"kind":"enum"},"1:13398":{"crate_id":1,"path":["std","sys","unix","process","process_common","Argv"],"kind":"struct"},"2:7874":{"crate_id":2,"path":["core","iter","traits","marker","FusedIterator"],"kind":"trait"},"14:6569":{"crate_id":14,"path":["gimli","read","lists","ListsHeader"],"kind":"struct"},"6:4096":{"crate_id":6,"path":["libc","unix","linux_like","linux","arpd_request"],"kind":"struct"},"15:13590":{"crate_id":15,"path":["object","pe","ImageDynamicRelocation64"],"kind":"struct"},"14:3218":{"crate_id":14,"path":["gimli","common","DebugStrOffset"],"kind":"struct"},"2:44406":{"crate_id":2,"path":["core","fmt","rt","v1","Count"],"kind":"enum"},"1:11536":{"crate_id":1,"path":["std","process","CommandArgs"],"kind":"struct"},"16:729":{"crate_id":16,"path":["memchr","memmem","twoway","Shift"],"kind":"enum"},"2:45335":{"crate_id":2,"path":["core","str","iter","RSplitTerminator"],"kind":"struct"},"1:11218":{"crate_id":1,"path":["std","path","StripPrefixError"],"kind":"struct"},"7:85":{"crate_id":7,"path":["unwind","libunwind","_Unwind_Action"],"kind":"enum"},"5:4743":{"crate_id":5,"path":["alloc","rc","{{impl}}","from_iter_exact","Guard"],"kind":"struct"},"14:6554":{"crate_id":14,"path":["gimli","read","line","FileEntryFormat"],"kind":"struct"},"2:47137":{"crate_id":2,"path":["core","core_arch","simd","i32x2"],"kind":"struct"},"16:677":{"crate_id":16,"path":["memchr","memmem","rabinkarp","Hash"],"kind":"struct"},"2:21530":{"crate_id":2,"path":["core","num","error","TryFromIntError"],"kind":"struct"},"2:8326":{"crate_id":2,"path":["core","panic","unwind_safe","AssertUnwindSafe"],"kind":"struct"},"15:9404":{"crate_id":15,"path":["object","endian","I16Bytes"],"kind":"struct"},"2:42706":{"crate_id":2,"path":["core","iter","adapters","take","Take"],"kind":"struct"},"14:6744":{"crate_id":14,"path":["gimli","read","lookup","PubStuffHeader"],"kind":"struct"},"15:9034":{"crate_id":15,"path":["object","common","SymbolKind"],"kind":"enum"},"5:1941":{"crate_id":5,"path":["alloc","collections","btree","navigate","LazyLeafHandle"],"kind":"enum"},"14:7158":{"crate_id":14,"path":["gimli","read","op","Evaluation"],"kind":"struct"},"2:12113":{"crate_id":2,"path":["rustc_error_codes","Searcher"],"kind":"typedef"},"14:6126":{"crate_id":14,"path":["gimli","read","abbrev","Attributes"],"kind":"enum"},"15:11199":{"crate_id":15,"path":["object","read","ObjectMapEntry"],"kind":"struct"},"1:3156":{"crate_id":1,"path":["std","fs","symlink_metadata"],"kind":"function"},"15:12537":{"crate_id":15,"path":["object","macho","EncryptionInfoCommand32"],"kind":"struct"},"2:47009":{"crate_id":2,"path":["core","core_arch","simd","u16x4"],"kind":"struct"},"1:8697":{"crate_id":1,"path":["std","sync","rwlock","{{impl}}","fmt","LockedPlaceholder"],"kind":"struct"},"1:10340":{"crate_id":1,"path":["std","ffi","c_str","NulError"],"kind":"struct"},"1:1967":{"crate_id":1,"path":["std","collections","hash","set","Union"],"kind":"struct"},"16:620":{"crate_id":16,"path":["memchr","cow","Imp"],"kind":"struct"},"5:1961":{"crate_id":5,"path":["alloc","collections","btree","navigate","LazyLeafRange"],"kind":"struct"},"17:0":{"crate_id":17,"path":["miniz_oxide"],"kind":"module"},"14:5766":{"crate_id":14,"path":["gimli","read","cfi","UnwindTableRow"],"kind":"struct"},"5:760":{"crate_id":5,"path":["alloc","collections","binary_heap","Iter"],"kind":"struct"},"2:42942":{"crate_id":2,"path":["core","iter","sources","successors","Successors"],"kind":"struct"},"1:3154":{"crate_id":1,"path":["std","fs","metadata"],"kind":"function"},"9:111":{"crate_id":9,"path":["hashbrown","raw","bitmask","BitMaskIter"],"kind":"struct"},"14:7786":{"crate_id":14,"path":["gimli","read","unit","EntriesRaw"],"kind":"struct"},"1:8890":{"crate_id":1,"path":["std","lazy","SyncOnceCell"],"kind":"struct"},"6:3741":{"crate_id":6,"path":["libc","unix","linux_like","linux","fsid_t"],"kind":"struct"},"2:41904":{"crate_id":2,"path":["core","ops","generator","GeneratorState"],"kind":"enum"},"15:12685":{"crate_id":15,"path":["object","macho","EntryPointCommand"],"kind":"struct"},"6:1722":{"crate_id":6,"path":["libc","unix","linux_like","utsname"],"kind":"struct"},"2:9560":{"crate_id":2,"path":["core","hash","Hash"],"kind":"trait"},"1:872":{"crate_id":1,"path":["rustc_error_codes","Owned"],"kind":"typedef"},"2:42324":{"crate_id":2,"path":["core","ascii","EscapeDefault"],"kind":"struct"},"15:13318":{"crate_id":15,"path":["object","pe","ImageAuxSymbolFunction"],"kind":"struct"},"14:2733":{"crate_id":14,"path":["gimli","common","Format"],"kind":"enum"},"1:15265":{"crate_id":1,"path":["std","str"],"kind":"primitive"},"15:13446":{"crate_id":15,"path":["object","pe","ImageImportByName"],"kind":"struct"},"1:10195":{"crate_id":1,"path":["std","thread","Builder"],"kind":"struct"},"15:10106":{"crate_id":15,"path":["object","read","coff","section","CoffSegment"],"kind":"struct"},"2:3098":{"crate_id":2,"path":["core","ops","arith","Neg"],"kind":"trait"},"14:4477":{"crate_id":14,"path":["gimli","constants","DwAccess"],"kind":"struct"},"15:9440":{"crate_id":15,"path":["object","endian","I32Bytes"],"kind":"struct"},"15:9280":{"crate_id":15,"path":["object","endian","BigEndian"],"kind":"struct"},"1:8515":{"crate_id":1,"path":["std","sync","once","Once"],"kind":"struct"},"15:10331":{"crate_id":15,"path":["object","read","elf","symbol","SymbolTable"],"kind":"struct"},"6:581":{"crate_id":6,"path":["libc","unix","winsize"],"kind":"struct"},"14:5561":{"crate_id":14,"path":["gimli","read","cfi","Augmentation"],"kind":"struct"},"16:820":{"crate_id":16,"path":["memchr","memmem","FinderRev"],"kind":"struct"},"15:10558":{"crate_id":15,"path":["object","read","macho","dyld_cache","DyldCacheImageIterator"],"kind":"struct"},"11:11":{"crate_id":11,"path":["rustc_demangle","legacy","Demangle"],"kind":"struct"},"14:5753":{"crate_id":14,"path":["gimli","read","cfi","RegisterRuleIter"],"kind":"struct"},"15:10468":{"crate_id":15,"path":["object","read","elf","hash","HashTable"],"kind":"struct"},"1:10780":{"crate_id":1,"path":["std","net","addr","SocketAddr"],"kind":"enum"},"17:963":{"crate_id":17,"path":["miniz_oxide","MZFlush"],"kind":"enum"},"15:10224":{"crate_id":15,"path":["object","read","coff","comdat","CoffComdatSectionIterator"],"kind":"struct"},"14:3338":{"crate_id":14,"path":["gimli","common","DebugFrameOffset"],"kind":"struct"},"1:3031":{"crate_id":1,"path":["std","fs","DirEntry"],"kind":"struct"},"15:13733":{"crate_id":15,"path":["object","pe","ImageHotPatchInfo"],"kind":"struct"},"15:13180":{"crate_id":15,"path":["object","pe","Guid"],"kind":"struct"},"1:6201":{"crate_id":1,"path":["std","os","unix","process","ExitStatusExt"],"kind":"trait"},"1:14315":{"crate_id":1,"path":["std","sys","unix","process","process_inner","ExitStatusError"],"kind":"struct"},"6:3983":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Sym"],"kind":"struct"},"14:6424":{"crate_id":14,"path":["gimli","read","line","LineProgramHeader"],"kind":"struct"},"14:4852":{"crate_id":14,"path":["gimli","constants","DwDefaulted"],"kind":"struct"},"16:896":{"crate_id":16,"path":["memchr","memmem","SearcherRevKind"],"kind":"enum"},"5:1180":{"crate_id":5,"path":["alloc","collections","btree","map","entry","OccupiedEntry"],"kind":"struct"},"6:1701":{"crate_id":6,"path":["libc","unix","linux_like","epoll_event"],"kind":"struct"},"6:6026":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","ipc_perm"],"kind":"struct"},"14:7392":{"crate_id":14,"path":["gimli","read","str","DebugStrOffsets"],"kind":"struct"},"16:136":{"crate_id":16,"path":["memchr","memchr","iter","Memchr"],"kind":"struct"},"1:8581":{"crate_id":1,"path":["std","sync","poison","TryLockError"],"kind":"enum"},"5:5396":{"crate_id":5,"path":["rustc_error_codes","Owned"],"kind":"typedef"},"14:5330":{"crate_id":14,"path":["gimli","endianity","BigEndian"],"kind":"struct"},"6:5169":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","Elf32_Chdr"],"kind":"struct"},"1:8150":{"crate_id":1,"path":["std","sync","mpsc","Sender"],"kind":"struct"},"2:7205":{"crate_id":2,"path":["core","iter","sources","once","once"],"kind":"function"},"14:4995":{"crate_id":14,"path":["gimli","constants","DwMacro"],"kind":"struct"},"0:3":{"crate_id":0,"path":["rustc_error_codes","register_diagnostics"],"kind":"macro"},"2:13020":{"crate_id":2,"path":["core","alloc","global","GlobalAlloc"],"kind":"trait"},"5:6520":{"crate_id":5,"path":["alloc","vec","drain","Drain"],"kind":"struct"},"1:1236":{"crate_id":1,"path":["std","collections","hash","map","Values"],"kind":"struct"},"1:10542":{"crate_id":1,"path":["std","fs","DirBuilder"],"kind":"struct"},"16:754":{"crate_id":16,"path":["memchr","memmem","twoway","SuffixOrdering"],"kind":"enum"},"15:10656":{"crate_id":15,"path":["object","read","macho","load_command","LoadCommandData"],"kind":"struct"},"16:704":{"crate_id":16,"path":["memchr","memmem","twoway","Forward"],"kind":"struct"},"2:2917":{"crate_id":2,"path":["core","convert","TryFrom"],"kind":"trait"},"5:5156":{"crate_id":5,"path":["alloc","slice","Join"],"kind":"trait"},"1:14658":{"crate_id":1,"path":["std","sys_common","net","TcpListener"],"kind":"struct"},"6:4949":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","statx_timestamp"],"kind":"struct"},"1:3034":{"crate_id":1,"path":["std","fs","read"],"kind":"function"},"6:1532":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_in"],"kind":"struct"},"1:1950":{"crate_id":1,"path":["std","collections","hash","set","Intersection"],"kind":"struct"},"2:8325":{"crate_id":2,"path":["core","panic","unwind_safe","RefUnwindSafe"],"kind":"trait"},"16:0":{"crate_id":16,"path":["memchr"],"kind":"module"},"1:6688":{"crate_id":1,"path":["std","os","fd","owned","AsFd"],"kind":"trait"},"15:11026":{"crate_id":15,"path":["object","read","traits","NoDynamicRelocationIterator"],"kind":"struct"},"1:8731":{"crate_id":1,"path":["rustc_error_codes","Target"],"kind":"typedef"},"6:4274":{"crate_id":6,"path":["libc","unix","linux_like","linux","af_alg_iv"],"kind":"struct"},"14:3488":{"crate_id":14,"path":["gimli","common","DwoId"],"kind":"struct"},"1:11008":{"crate_id":1,"path":["std","os","linux","raw","arch","stat"],"kind":"struct"},"1:10246":{"crate_id":1,"path":["std","backtrace","BacktraceStatus"],"kind":"enum"},"14:2816":{"crate_id":14,"path":["gimli","common","DebugAbbrevOffset"],"kind":"struct"},"6:5932":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_fpxreg"],"kind":"struct"},"2:45975":{"crate_id":2,"path":["core","str","LinesAnyMap"],"kind":"struct"},"1:4321":{"crate_id":1,"path":["std","io","Guard"],"kind":"struct"},"5:7400":{"crate_id":5,"path":["alloc","collections","binary_heap","IntoIterSorted"],"kind":"struct"},"15:8954":{"crate_id":15,"path":["object","common","SectionKind"],"kind":"enum"},"14:7378":{"crate_id":14,"path":["gimli","read","str","DebugStr"],"kind":"struct"},"4:0":{"crate_id":4,"path":["rustc_std_workspace_core"],"kind":"module"},"14:7738":{"crate_id":14,"path":["gimli","read","unit","Attribute"],"kind":"struct"},"1:4101":{"crate_id":1,"path":["std","io","stdio","StdinLock"],"kind":"struct"},"15:11001":{"crate_id":15,"path":["object","read","pe","section","PeSection"],"kind":"struct"},"6:4297":{"crate_id":6,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_can_addr"],"kind":"union"},"2:46163":{"crate_id":2,"path":["core","task","poll","Poll"],"kind":"enum"},"2:7495":{"crate_id":2,"path":["core","iter","traits","exact_size","ExactSizeIterator"],"kind":"trait"},"6:5965":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user_regs_struct"],"kind":"struct"},"11:231":{"crate_id":11,"path":["rustc_demangle","v0","ParseError"],"kind":"enum"},"6:5000":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","msghdr"],"kind":"struct"},"2:10349":{"crate_id":2,"path":["core","slice","iter","RSplitMut"],"kind":"struct"},"1:10965":{"crate_id":1,"path":["std","os","unix","net","ancillary","AncillaryError"],"kind":"enum"},"2:9354":{"crate_id":2,"path":["core","fmt","Debug"],"kind":"trait"},"2:3304":{"crate_id":2,"path":["core","ops","index","IndexMut"],"kind":"trait"},"6:3902":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_ff_upload"],"kind":"struct"},"15:9659":{"crate_id":15,"path":["object","read","any","SegmentIteratorInternal"],"kind":"enum"},"5:3435":{"crate_id":5,"path":["alloc","collections","linked_list","DrainFilter"],"kind":"struct"},"1:2237":{"crate_id":1,"path":["std","env","ArgsOs"],"kind":"struct"},"14:3041":{"crate_id":14,"path":["gimli","common","DebugLocListsIndex"],"kind":"struct"},"14:6357":{"crate_id":14,"path":["gimli","read","line","LineInstructions"],"kind":"struct"},"5:1154":{"crate_id":5,"path":["alloc","collections","btree","map","entry","Entry"],"kind":"enum"},"1:11819":{"crate_id":1,"path":["std","time","SystemTimeError"],"kind":"struct"},"14:6269":{"crate_id":14,"path":["gimli","read","line","LineInstruction"],"kind":"enum"},"1:11570":{"crate_id":1,"path":["std","process","ExitStatusError"],"kind":"struct"},"2:2907":{"crate_id":2,"path":["core","convert","Into"],"kind":"trait"},"2:43864":{"crate_id":2,"path":["core","sync","atomic","AtomicI64"],"kind":"struct"},"2:3004":{"crate_id":2,"path":["core","marker","Send"],"kind":"trait"},"2:46155":{"crate_id":2,"path":["core","future","ResumeTy"],"kind":"struct"},"15:12195":{"crate_id":15,"path":["object","macho","SubFrameworkCommand"],"kind":"struct"},"6:5064":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","nl_mmap_req"],"kind":"struct"},"15:12234":{"crate_id":15,"path":["object","macho","SubLibraryCommand"],"kind":"struct"},"2:3228":{"crate_id":2,"path":["core","ops","deref","DerefMut"],"kind":"trait"},"15:11186":{"crate_id":15,"path":["object","read","ObjectMap"],"kind":"struct"},"2:7433":{"crate_id":2,"path":["rustc_error_codes","IntoIter"],"kind":"typedef"},"15:13296":{"crate_id":15,"path":["object","pe","ImageSymbolExBytes"],"kind":"struct"},"1:10200":{"crate_id":1,"path":["std","thread","ThreadId"],"kind":"struct"},"17:692":{"crate_id":17,"path":["miniz_oxide","deflate","core","CompressionStrategy"],"kind":"enum"},"5:5152":{"crate_id":5,"path":["alloc","slice","Concat"],"kind":"trait"},"1:14620":{"crate_id":1,"path":["std","sys_common","net","TcpStream"],"kind":"struct"},"6:4052":{"crate_id":6,"path":["libc","unix","linux_like","linux","mntent"],"kind":"struct"},"5:4647":{"crate_id":5,"path":["alloc","rc","Rc"],"kind":"struct"},"1:10913":{"crate_id":1,"path":["std","net","Shutdown"],"kind":"enum"},"2:4348":{"crate_id":2,"path":["rustc_error_codes","Target"],"kind":"typedef"},"2:7881":{"crate_id":2,"path":["core","iter","traits","marker","TrustedStep"],"kind":"trait"},"2:42374":{"crate_id":2,"path":["core","char","decode","DecodeUtf16"],"kind":"struct"},"1:11997":{"crate_id":1,"path":["std","sys","unix","condvar","Condvar"],"kind":"struct"},"16:837":{"crate_id":16,"path":["memchr","memmem","Searcher"],"kind":"struct"},"15:12118":{"crate_id":15,"path":["object","macho","Section64"],"kind":"struct"},"6:1832":{"crate_id":6,"path":["libc","unix","linux_like","linux","fpos64_t"],"kind":"enum"},"15:11640":{"crate_id":15,"path":["object","elf","Rela32"],"kind":"struct"},"14:6780":{"crate_id":14,"path":["gimli","read","op","DieReference"],"kind":"enum"},"15:294":{"crate_id":15,"path":["object","read","util","DebugByte"],"kind":"struct"},"14:7420":{"crate_id":14,"path":["gimli","read","unit","UnitOffset"],"kind":"struct"},"1:1410":{"crate_id":1,"path":["std","collections","hash","map","OccupiedEntry"],"kind":"struct"},"1:7318":{"crate_id":1,"path":["std","process","ChildStdin"],"kind":"struct"},"2:45389":{"crate_id":2,"path":["core","str","iter","RSplitN"],"kind":"struct"},"2:21881":{"crate_id":2,"path":["core","num","nonzero","NonZeroU32"],"kind":"struct"},"5:3787":{"crate_id":5,"path":["alloc","collections","vec_deque","iter_mut","IterMut"],"kind":"struct"},"14:4417":{"crate_id":14,"path":["gimli","constants","DwDs"],"kind":"struct"},"1:9187":{"crate_id":1,"path":["std","sys_common","condvar","Condvar"],"kind":"struct"},"2:5565":{"crate_id":2,"path":["core","iter","adapters","flatten","Flatten"],"kind":"struct"},"5:7425":{"crate_id":5,"path":["alloc","collections","btree","merge_iter","Peeked"],"kind":"enum"},"15:12456":{"crate_id":15,"path":["object","macho","TwolevelHint"],"kind":"struct"},"15:11993":{"crate_id":15,"path":["object","macho","MachHeader32"],"kind":"struct"},"15:11082":{"crate_id":15,"path":["object","read","SectionIndex"],"kind":"struct"},"15:13506":{"crate_id":15,"path":["object","pe","ImageDelayloadDescriptor"],"kind":"struct"},"15:13282":{"crate_id":15,"path":["object","pe","ImageSymbolEx"],"kind":"struct"},"2:44449":{"crate_id":2,"path":["core","fmt","FlagV1"],"kind":"enum"},"2:49278":{"crate_id":2,"path":["core","core_arch","x86","__m512"],"kind":"struct"},"6:6639":{"crate_id":6,"path":["libc","unix","linux_like","linux","canfd_frame"],"kind":"struct"},"2:45979":{"crate_id":2,"path":["core","str","CharEscapeDebugContinue"],"kind":"struct"},"9:2098":{"crate_id":9,"path":["hashbrown","UnavailableMutError"],"kind":"enum"},"1:11735":{"crate_id":1,"path":["std","sync","mpsc","TrySendError"],"kind":"enum"},"1:10261":{"crate_id":1,"path":["std","backtrace","RawFrame"],"kind":"enum"},"2:2910":{"crate_id":2,"path":["core","convert","From"],"kind":"trait"},"1:3493":{"crate_id":1,"path":["std","io","buffered","bufwriter","WriterPanicked"],"kind":"struct"},"2:49139":{"crate_id":2,"path":["core","core_arch","simd","u64x8"],"kind":"struct"},"5:2671":{"crate_id":5,"path":["alloc","collections","btree","node","marker","ValMut"],"kind":"struct"},"15:9649":{"crate_id":15,"path":["object","read","any","SegmentIterator"],"kind":"struct"},"14:3195":{"crate_id":14,"path":["gimli","common","DebugRngListsIndex"],"kind":"struct"},"1:4362":{"crate_id":1,"path":["std","io","IoSliceMut"],"kind":"struct"}},"external_crates":{"5":{"name":"alloc","html_root_url":"https://doc.rust-lang.org/nightly/"},"7":{"name":"unwind","html_root_url":"https://doc.rust-lang.org/nightly/"},"12":{"name":"std_detect","html_root_url":"https://doc.rust-lang.org/nightly/"},"6":{"name":"libc","html_root_url":"https://doc.rust-lang.org/nightly/"},"2":{"name":"core","html_root_url":"https://doc.rust-lang.org/nightly/"},"4":{"name":"rustc_std_workspace_core","html_root_url":"https://doc.rust-lang.org/nightly/"},"19":{"name":"panic_unwind","html_root_url":"https://doc.rust-lang.org/nightly/"},"3":{"name":"compiler_builtins","html_root_url":"https://doc.rust-lang.org/nightly/"},"17":{"name":"miniz_oxide","html_root_url":"https://doc.rust-lang.org/nightly/"},"14":{"name":"gimli","html_root_url":"https://doc.rust-lang.org/nightly/"},"16":{"name":"memchr","html_root_url":"https://doc.rust-lang.org/nightly/"},"10":{"name":"rustc_std_workspace_alloc","html_root_url":"https://doc.rust-lang.org/nightly/"},"18":{"name":"adler","html_root_url":"https://docs.rs/adler/0.2.3/"},"9":{"name":"hashbrown","html_root_url":"https://doc.rust-lang.org/nightly/"},"1":{"name":"std","html_root_url":"https://doc.rust-lang.org/nightly/"},"13":{"name":"addr2line","html_root_url":"https://doc.rust-lang.org/nightly/"},"8":{"name":"cfg_if","html_root_url":"https://docs.rs/cfg-if/"},"15":{"name":"object","html_root_url":"https://doc.rust-lang.org/nightly/"},"11":{"name":"rustc_demangle","html_root_url":"https://doc.rust-lang.org/nightly/"}},"format_version":9}